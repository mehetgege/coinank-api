
<!DOCTYPE html>
<html lang="tr" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTIMATE TRADING WAR ROOM v3.0 | SAVAŞ ÜSSÜ</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <!-- TSParticles for visual effects -->
    <script src="https://cdn.jsdelivr.net/npm/tsparticles-slim@2.12.0/tsparticles.slim.bundle.min.js"></script>
    <!-- TensorFlow.js for Machine Learning -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <!-- ML.js for additional ML algorithms -->
    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/lib/ml-matrix.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ml-regression@6.0.1/lib/ml-regression.min.js"></script>
    <style>
        /* Yeni Tasarım Değişkenleri */
        :root {
            /* Temel Renkler */
            --metatron-color: #64B5F6;  /* Mavi - Bilgelik */
            --uriel-color: #FFA726;     /* Turuncu - Cesaret */
            --raphael-color: #81C784;   /* Yeşil - Şifa */
            --gabriel-color: #BA68C8;   /* Mor - İletişim */
            --michael-color: #EF5350;   /* Kırmızı - Savaş */
            
            /* UI Ana Değişkenler */
            --header-height: 50px;      /* Üst menü yüksekliği */
            --menu-width: 60px;         /* Yan menü genişliği */
            --menu-expanded-width: 250px; /* Genişletilmiş yan menü */
            --chart-padding: 10px;      /* Grafik etrafındaki boşluk */
            --animation-speed: 0.3s;    /* Standart animasyon hızı */
            
            /* Tema Değişkenleri - Dark Theme */
            --background: #131722;
            --panel-bg: #1c2230;
            --text-main: #e1e2e6;
            --text-secondary: #9ca3af;
            --border-color: #2a2e39;
            --input-bg: #171b26;
            --hover-bg: #22283a;
            --primary: #3b82f6;
            --primary-rgb: 59, 130, 246;
            --primary-light: #60a5fa;
            --primary-dark: #2563eb;
            
            /* Durum Renkleri */
            --success: #10b981;
            --success-rgb: 16, 185, 129;
            --danger: #ef4444;
            --danger-rgb: 239, 68, 68;
            --warning: #f59e0b;
            --warning-rgb: 245, 158, 11;
            --info: #3b82f6;
            --info-rgb: 59, 130, 246;
            
            /* Özel UI Renkleri */
            --card-gradient: linear-gradient(145deg, #1c2230, #181e2a);
            --shadow-small: 0 2px 5px rgba(0,0,0,0.2);
            --shadow-medium: 0 4px 10px rgba(0,0,0,0.3);
            --shadow-large: 0 10px 25px rgba(0,0,0,0.4);
        }
        
        /* Açık Tema */
        [data-theme="light"] {
            --background: #f1f5f9;
            --panel-bg: #ffffff;
            --text-main: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --input-bg: #f8fafc;
            --hover-bg: #e2e8f0;
            --primary: #3b82f6;
            --primary-rgb: 59, 130, 246;
            --primary-light: #60a5fa;
            --primary-dark: #2563eb;
            
            --success: #10b981;
            --success-rgb: 16, 185, 129;
            --danger: #ef4444;
            --danger-rgb: 239, 68, 68;
            --warning: #f59e0b;
            --warning-rgb: 245, 158, 11;
            --info: #3b82f6;
            --info-rgb: 59, 130, 246;
            
            --card-gradient: linear-gradient(145deg, #ffffff, #f8fafc);
            --shadow-small: 0 2px 5px rgba(0,0,0,0.05);
            --shadow-medium: 0 4px 10px rgba(0,0,0,0.1);
            --shadow-large: 0 10px 25px rgba(0,0,0,0.15);
        }
        
        /* Savaş Modu */
        [data-theme="war"] {
            --background: #1a0a0a;
            --panel-bg: #240d0d;
            --text-main: #ffd700;
            --text-secondary: #ff9e45;
            --border-color: #4d1a1a;
            --input-bg: #2d1010;
            --hover-bg: #3a1515;
            --primary: #ff4500;
            --primary-rgb: 255, 69, 0;
            --primary-light: #ff6a33;
            --primary-dark: #cc3700;
            
            --success: #ffd700;
            --success-rgb: 255, 215, 0;
            --danger: #ff0000;
            --danger-rgb: 255, 0, 0;
            --warning: #ff8c00;
            --warning-rgb: 255, 140, 0;
            --info: #ff4500;
            --info-rgb: 255, 69, 0;
            
            --card-gradient: linear-gradient(145deg, #240d0d, #1d0808);
            --shadow-small: 0 2px 5px rgba(255,0,0,0.2);
            --shadow-medium: 0 4px 10px rgba(255,0,0,0.3);
            --shadow-large: 0 10px 25px rgba(255,0,0,0.4);
        }
        
        /* Genel Panel Stilleri */
        .side-panel {
            position: fixed;
            z-index: 1200;
            background: rgba(22, 27, 34, 0.95);
            backdrop-filter: blur(6px);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            color: var(--text-main);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: all 0.3s ease-in-out;
            overflow: hidden;
            width: 320px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .side-panel.left-panel {
            left: -350px; /* Off-screen */
            top: var(--header-height);
        }
        .side-panel.left-panel.active {
            left: 60px; /* Next to vertical-icon-panel */
        }

        .side-panel.right-panel {
            right: -350px; /* Off-screen */
            top: var(--header-height);
        }
        .side-panel.right-panel.active {
            right: 60px; /* Next to vertical-icon-panel */
        }

        .side-panel .panel-header {
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            padding: 10px 15px; 
            font-size: 15px; 
            font-weight: 600; 
            border-bottom: 1px solid var(--border-color);
            background: rgba(0,0,0,0.2);
            color: var(--primary);
        }
        .side-panel .panel-body {
            padding: 10px;
            overflow-y: auto;
            flex-grow: 1;
        }

        /* Panteon Panel */
        #panteon-panel {
            top: 60px; /* Adjusted position */
            left: 60px;
        }
        #panteon-panel.active {
            left: 60px;
            top: 60px;
        }
        #panteon-panel .pp-title{
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            padding: 10px 15px; 
            font-size: 15px; 
            font-weight: 600; 
            border-bottom: 1px solid var(--border-color);
            background: rgba(0,0,0,0.2);
            color: var(--metatron-color);
        }
        #panteon-panel .pp-body{
            padding: 0;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        /* Panteon İstatistikleri */
        .panteon-stats {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(0,0,0,0.15);
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
        }
        
        .regime-indicator, .state-indicator {
            display: flex;
            gap: 8px;
        }
        
        .current-regime {
            color: var(--uriel-color);
            font-weight: 600;
        }
        
        .collective-state {
            color: var(--metatron-color);
            font-weight: 600;
        }
        
        /* Panteon Panel İyileştirmeler */
        .panteon-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
        }
        
        /* Elçi Kartları */
        .ambassador {
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .ambassador.active {
            border-color: var(--accent-color);
        }
        
        .ambassador.inactive {
            opacity: 0.6;
            filter: grayscale(0.7);
        }
        
        /* Elçi Mod Renklendirmeleri */
        .ambassador[data-mode="İNANÇLI"] {
            border-left: 4px solid var(--success);
        }
        
        .ambassador[data-mode="ŞÜPHECİ"] {
            border-left: 4px solid var(--warning);
        }
        
        .ambassador[data-mode="KIYAMET"] {
            border-left: 4px solid var(--danger);
        }
        
        /* Elçi Rol Renklendirmeleri */
        .ambassador[data-role="wisdom"] .ambassador-name {
            color: var(--metatron-color);
        }
        
        .ambassador[data-role="courage"] .ambassador-name {
            color: var(--uriel-color);
        }
        
        .ambassador[data-role="healing"] .ambassador-name {
            color: var(--raphael-color);
        }
        
        .ambassador[data-role="communication"] .ambassador-name {
            color: var(--gabriel-color);
        }
        
        .ambassador[data-role="warfare"] .ambassador-name {
            color: var(--michael-color);
        }
        
        /* Elçi Başlık */
        .ambassador-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .ambassador-name {
            font-weight: 600;
            font-size: 15px;
        }
        
        .ambassador-toggle {
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .ambassador-toggle:hover {
            background: rgba(255,255,255,0.2);
        }
        
        /* Elçi Bilgileri */
        .ambassador-info {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 8px;
        }
        
        .ambassador-role {
            opacity: 0.7;
        }
        
        .ambassador-status {
            display: flex;
            gap: 10px;
        }
        
        .ambassador-mode {
            font-weight: 600;
        }
        
        .ambassador[data-mode="İNANÇLI"] .ambassador-mode {
            color: var(--success);
        }
        
        .ambassador[data-mode="ŞÜPHECİ"] .ambassador-mode {
            color: var(--warning);
        }
        
        .ambassador[data-mode="KIYAMET"] .ambassador-mode {
            color: var(--danger);
        }
        
        .reputation {
            opacity: 0.8;
        }
        
        .reputation-score {
            font-weight: 600;
        }
        
        /* İlerleme Çubukları */
        .progress-container {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .confidence, .power {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
        }
        
        .confidence span, .power span {
            width: 45px;
            opacity: 0.7;
        }
        
        .confidence-bar, .power-bar {
            flex: 1;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }
        
        .confidence-level {
            height: 100%;
            background: linear-gradient(90deg, var(--warning), var(--success));
            border-radius: 3px;
            font-size: 9px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 4px;
            color: rgba(0,0,0,0.7);
            transition: width 0.5s ease;
        }
        
        .power-level {
            height: 100%;
            background: linear-gradient(90deg, var(--info), var(--primary-light));
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        
        /* Strateji Seçim Butonları */
        .strategy-select {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 5px;
        }
        
        .strategy-select button {
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .strategy-select button:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .strategy-select button.active {
            background: rgba(var(--primary-rgb), 0.3);
            border-color: var(--primary);
            color: var(--primary-light);
        }
        
        /* Yetenek Düğmeleri */
        .pantheon-abilities {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            padding: 10px;
            border-top: 1px solid var(--border-color);
        }
        
        .pantheon-ability {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 8px;
            border-radius: 6px;
            width: 90px;
        }
        
        .pantheon-ability:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .pantheon-ability.ready {
            border: 1px solid rgba(var(--info-rgb), 0.5);
        }
        
        .pantheon-ability.cooldown {
            opacity: 0.6;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .ability-icon {
            font-size: 18px;
        }
        
        .ability-name {
            font-size: 12px;
            font-weight: 600;
        }
        
        .cooldown-indicator {
            font-size: 10px;
            opacity: 0.7;
        }
        
        /* Aktif Konsey Efektleri */
        .pp-power-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s ease;
        }
        #amb-metatron .pp-power-fill { background: var(--metatron-color, #3b82f6); }
        #amb-uriel .pp-power-fill { background: var(--uriel-color, #ef4444); }
        #amb-raphael .pp-power-fill { background: var(--raphael-color, #10b981); }
        #amb-gabriel .pp-power-fill { background: var(--gabriel-color, #a855f7); }
        #amb-michael .pp-power-fill { background: var(--michael-color, #f97316); }
        
        .pp-expand-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            font-size: 12px;
            opacity: 0.7;
            transition: all 0.2s ease;
        }
        .pp-expand-btn:hover {
            opacity: 1;
            color: var(--primary);
        }
        
        .pp-collective-state {
            font-size: 11px;
            display: flex;
            align-items: center;
        }
        .pp-state-label {
            color: var(--text-secondary);
            margin-right: 5px;
        }
        .pp-state-value {
            font-weight: bold;
        }
        
        .pp-actions {
            display: flex;
            gap: 5px;
        }
        .pp-action-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            font-size: 12px;
            opacity: 0.7;
            transition: all 0.2s ease;
            border-radius: 3px;
        }
        .pp-action-btn:hover {
            opacity: 1;
            color: var(--primary);
            background: var(--bg-tertiary);
        }
        
        /* Renk değişkenleri - Elçi renkleri */
        :root {
            --metatron-color: #3b82f6; /* Mavi - Bilgelik */
            --uriel-color: #ef4444;    /* Kırmızı - Cesaret */
            --raphael-color: #10b981;  /* Yeşil - Şifa */
            --gabriel-color: #a855f7;  /* Mor - İletişim */
            --michael-color: #f97316;  /* Turuncu - Savaş */
        }
        
        /* Kehanet Paneli (sağ alt) */
        #kehanet-panel{ 
            right: 60px; 
            top: 60px; /* Adjusted position */
            width: 260px; 
        }
        #kehanet-panel .kp-title{ 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            padding: 8px 10px; 
            border-bottom: 1px solid var(--border-color); 
            font-weight: 700; 
            font-size: 12px; 
            color: var(--primary); 
            user-select: none; 
        }
        #kehanet-panel .kp-body{ 
            padding: 8px 10px; 
            display: grid; 
            gap: 6px; 
            font-size: 12px; 
        }
        #kehanet-panel .kp-footer {
            border-top: 1px solid var(--border-color);
            padding: 8px 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .kp-row{ 
            display: flex; 
            align-items: center; 
            justify-content: space-between;
            padding: 2px 0;
        }
        .kp-key{ 
            color: var(--text-secondary); 
        }
        .kp-val{ 
            font-weight: 700; 
        }
        .kp-divider {
            height: 1px;
            background: var(--border-color);
            margin: 4px 0;
            opacity: 0.6;
        }
        .kp-advanced {
            display: none;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }
        .kp-panel-expanded .kp-advanced {
            display: grid;
            gap: 6px;
            opacity: 1;
            transform: translateY(0);
        }
        .kp-panel-expanded {
            width: 320px;
            height: auto;
        }
        .kp-expand-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            font-size: 12px;
            opacity: 0.7;
            transition: all 0.2s ease;
        }
        .kp-expand-btn:hover {
            opacity: 1;
            color: var(--primary);
        }
        .kp-chart-container {
            margin-top: 6px;
            height: 70px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        .kp-mini-chart {
            width: 100%;
            height: 100%;
        }
        .kp-confidence-bar {
            flex: 1;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            margin-right: 10px;
        }
        .kp-confidence-fill {
            height: 100%;
            width: 75%;
            background: linear-gradient(90deg, var(--warning) 0%, var(--success) 100%);
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        .kp-confidence-label {
            position: absolute;
            top: -16px;
            right: 5px;
            font-size: 9px;
            color: var(--text-secondary);
        }
        .kp-refresh-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            font-size: 14px;
            opacity: 0.7;
            transition: all 0.2s ease;
        }
        .kp-refresh-btn:hover {
            opacity: 1;
            color: var(--primary);
            transform: rotate(180deg);
        }
        .prediction-refresh {
            animation: prediction-pulse 0.8s ease-out;
        }
        @keyframes prediction-pulse {
            0% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.3); }
            70% { box-shadow: 0 0 0 15px rgba(139, 92, 246, 0); }
            100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0); }
        }
        .trend-up { color: var(--success); }
        .trend-down { color: var(--danger); }
        .trend-neutral { color: var(--warning); }
        
        /* tsParticles katmanı (İlk Işık ve diğer efektler için) */
        #cosmic-effects-layer{
            position: fixed; 
            inset: 0; 
            z-index: 3000; 
            pointer-events: none;
        }
        
        /* Enerji Kutusu Stilleri */
        .energy-box {
            top: 60px; /* Adjusted position */
            right: 60px;
            width: 250px;
        }
        
        .energy-box-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        
        .energy-box-title {
            font-family: var(--primary-font);
            font-size: 14px;
            font-weight: bold;
            color: var(--info);
            margin: 0;
        }
        
        .energy-box-close {
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            color: var(--text-secondary);
        }
        
        .energy-box-close:hover {
            opacity: 1;
        }
        
        .energy-meter {
            width: 100%;
            height: 15px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
            position: relative;
        }
        
        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--info) 0%, var(--success) 100%);
            border-radius: 10px;
            width: 75%;
            transition: width 1s ease;
            position: relative;
        }
        
        .energy-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0) 100%);
            animation: energy-pulse 2s infinite;
        }
        
        @keyframes energy-pulse {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .energy-info {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }
        
        .energy-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            gap: 5px;
        }
        
        .energy-action-btn {
            flex: 1;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 5px;
            font-size: 11px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        
        .energy-action-btn:hover {
            background: var(--hover-bg);
            border-color: var(--primary);
        }
        
        .energy-low {
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }
        
        .energy-low .energy-fill {
            background: linear-gradient(90deg, #ff3366 0%, #ffaa00 100%);
        }
        
        .energy-status {
            text-align: center;
            font-size: 11px;
            color: var(--text-secondary);
            margin: 5px 0;
            padding: 2px;
            border-radius: 3px;
            background: var(--bg-tertiary);
        }

        /* OSIRIS Sentinel System Panel */
        #osiris-panel {
            top: 60px; /* Adjusted position */
            right: 60px;
            width: 260px;
        }

        /* Mobil uyumluluk */
        @media screen and (max-width: 768px){
            .side-panel.left-panel, .side-panel.right-panel {
                width: 90vw;
                left: -95vw; /* Initially off-screen for mobile */
                right: -95vw;
                top: 10px;
            }
            .side-panel.left-panel.active {
                left: 5vw; /* Positioned centrally with margin */
            }
            .side-panel.right-panel.active {
                right: 5vw; /* Positioned centrally with margin */
            }
            #panteon-panel, #kehanet-panel, #osiris-panel, #energy-box, #ritual-container {
                left: 5vw !important;
                right: 5vw !important;
                top: 10px !important;
            }
        }
        .energy-box {
            bottom: 120px;
            width: 200px;
        }
    </style>
    <script>
    // IndexedDB Yardımcı Sınıfları
    class IDBUtil {
        static promisifyRequest(req) {
            return new Promise((resolve, reject) => {
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }
    }
    
    // IndexedDB Yönetici Sınıfı - Panteon için
    class PanteonDBManager {
        constructor() {
            this.db = null;
            this.DB_NAME = 'UTC_PANTHEON_DB';
            this.DB_VERSION = 1;
        }
        
        static get instance() {
            if(!window.__panteonDbMan) {
                window.__panteonDbMan = new PanteonDBManager();
            }
            return window.__panteonDbMan;
        }
        
        async open() {
            if(this.db) return this.db;
            const req = indexedDB.open(this.DB_NAME, this.DB_VERSION);
            
            req.onupgradeneeded = (ev) => {
                const db = ev.target.result;
                if(!db.objectStoreNames.contains('settings')) db.createObjectStore('settings', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('panteon')) db.createObjectStore('panteon', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('strategyStats')) db.createObjectStore('strategyStats', { keyPath: 'strategyKey' });
                if(!db.objectStoreNames.contains('signals')) {
                    const s = db.createObjectStore('signals', { keyPath: 'id', autoIncrement: true });
                    s.createIndex('byTimestamp','timestamp',{unique:false});
                    s.createIndex('bySymbol','symbol',{unique:false});
                    s.createIndex('byStatus','status',{unique:false});
                    s.createIndex('byDirection','direction',{unique:false});
                }
                if(!db.objectStoreNames.contains('notifications')) {
                    const n = db.createObjectStore('notifications', { keyPath: 'id', autoIncrement: true });
                    n.createIndex('byTimestamp','timestamp',{unique:false});
                    n.createIndex('byType','type',{unique:false});
                }
                if(!db.objectStoreNames.contains('kv')) db.createObjectStore('kv', { keyPath: 'key' });
                if(!db.objectStoreNames.contains('meta')) db.createObjectStore('meta', { keyPath: 'key' });
            };
            
            this.db = await IDBUtil.promisifyRequest(req);
            return this.db;
        }
        
        store(name, mode='readonly') {
            const tx = this.db.transaction(name, mode);
            return tx.objectStore(name);
        }
        
        async getPanteonState() {
            await this.open();
            const res = await IDBUtil.promisifyRequest(this.store('panteon').get('state'));
            return res?.data || this._panteonDefaults();
        }
        
        async setPanteonState(data) {
            await this.open();
            await IDBUtil.promisifyRequest(this.store('panteon','readwrite').put({
                id: 'state',
                data,
                updatedAt: Date.now()
            }));
            return true;
        }
        
        _panteonDefaults() {
            return {
                zeus: { role: 'creator' },
                env: { createdAt: Date.now(), version: '3.2' },
                ambassadors: {
                    Metatron: { reputation: 0, mode: 'İnançlı' },
                    Uriel: { reputation: 0, mode: 'İnançlı' },
                    Raphael: { reputation: 0, mode: 'İnançlı' }
                },
                lastDormancyPenaltyAt: null
            };
        }
    }
    
    // Görsel Efektler Yöneticisi
    class EffectsManager {
        constructor() {
            this.layerId = 'cosmic-effects-layer';
            this.ensureLayer();
            this.effects = {
                firstLight: { cooldown: 5000, lastUsed: 0 },
                prediction: { cooldown: 3000, lastUsed: 0 },
                horseman: { cooldown: 10000, lastUsed: 0 },
                confluence: { cooldown: 2000, lastUsed: 0 },
                explosion: { cooldown: 1000, lastUsed: 0 }, // Added for explosion effect
                matrix: { cooldown: 8000, lastUsed: 0 } // Added for matrix effect
            };
            this._effectsEnabled = true;
        }
        
        ensureLayer() {
            if(!document.getElementById(this.layerId)) {
                const d = document.createElement('div');
                d.id = this.layerId;
                d.style.position = 'fixed';
                d.style.inset = '0';
                d.style.zIndex = '3000';
                d.style.pointerEvents = 'none';
                document.body.appendChild(d);
            }
        }
        
        async ensureTsParticles() {
            if(window.tsParticles) return;
            await new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = 'https://cdn.jsdelivr.net/npm/tsparticles@3/tsparticles.bundle.min.js';
                s.async = true;
                s.onload = () => resolve(true);
                s.onerror = () => reject(new Error('tsParticles yüklenemedi'));
                document.head.appendChild(s);
            });
        }
        
        checkCooldown(effectName) {
            if (!this._effectsEnabled) return false; // If effects are disabled, bypass cooldown
            const effect = this.effects[effectName];
            if (!effect) return true;
            
            const now = Date.now();
            if (now - effect.lastUsed < effect.cooldown) {
                return false;
            }
            
            effect.lastUsed = now;
            return true;
        }

        toggleEffects(enabled) {
            this._effectsEnabled = enabled;
            if (!enabled) {
                // Clear all active particles if effects are disabled
                if (window.tsParticles) {
                    window.tsParticles.dom().forEach(container => container.destroy());
                }
                const layer = document.getElementById(this.layerId);
                if (layer) layer.innerHTML = ''; // Clear any fallback effects
            }
        }

        async createExplosionEffect(x, y, color = '#FF0000', size = 50, duration = 1000) {
            if (!this.checkCooldown('explosion')) return;
            await this.ensureTsParticles();
            const config = {
                background: { color: 'transparent' },
                fullScreen: { enable: false },
                particles: {
                    number: { value: 0 },
                    move: { enable: true, speed: { min: 5, max: 15 }, direction: 'random', outModes: 'destroy' },
                    opacity: { value: { min: 0.1, max: 0.8 } },
                    size: { value: { min: 1, max: 5 } },
                    color: { value: color },
                    life: { duration: { min: 0.5, max: 1.5 } }
                },
                emitters: {
                    position: { x: (x / window.innerWidth) * 100, y: (y / window.innerHeight) * 100 },
                    rate: { quantity: size / 10, delay: 0.05 },
                    life: { duration: duration / 1000, count: 1 }
                }
            };
            const container = await window.tsParticles.load(this.layerId, config);
            setTimeout(() => { try { container?.destroy(); } catch { } }, duration + 200);
        }

        async createMatrixEffect(duration = 5000) {
            if (!this.checkCooldown('matrix')) return;
            await this.ensureTsParticles();
            const config = {
                background: { color: 'transparent' },
                fullScreen: { enable: false },
                particles: {
                    number: { value: 0 },
                    color: { value: '#00FF41' },
                    shape: { type: 'character', character: [{ value: ['0', '1'], font: 'Verdana', style: '', weight: '400' }] },
                    opacity: { value: { min: 0.1, max: 0.8 } },
                    size: { value: { min: 1, max: 3 } },
                    move: { enable: true, speed: { min: 0.5, max: 2 }, direction: 'bottom', outModes: 'out' }
                },
                emitters: {
                    direction: 'bottom',
                    rate: { quantity: 5, delay: 0.1 },
                    size: { width: 100, height: 0 },
                    life: { duration: duration / 1000, count: 1 }
                }
            };
            const container = await window.tsParticles.load(this.layerId, config);
            setTimeout(() => { try { container?.destroy(); } catch { } }, duration + 200);
        }
        
        async firstLight(duration=2200) {
            if (!this.checkCooldown('firstLight')) return null;
            try {
                await this.ensureTsParticles();
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: false },
                    particles: { number: { value: 0 } },
                    emitters: {
                        position: { x: 50, y: 50 },
                        rate: { delay: 0.01, quantity: 60 },
                        life: { duration: duration/1000, count: 1 },
                        particles: {
                            move: { enable: true, speed: {min: 10, max: 40}, outModes: 'destroy' },
                            color: { value: ['#ffffff','#7dd3fc','#60a5fa'] },
                            shape: { type: 'circle' },
                            size: { value: {min: 1, max: 3} },
                            opacity: { value: {min: 0.2, max: 0.8} },
                            wobble: { enable: true, distance: 5, speed: 20 },
                            shadow: { enable: true, blur: 6, color: '#a5f3fc' }
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration + 250);
                
                return container;
            } catch(e) {
                const el = document.createElement('div');
                el.style.position = 'absolute';
                el.style.inset = '0';
                el.style.background = 'radial-gradient(circle at center, rgba(255,255,255,0.9), rgba(96,165,250,0.5), rgba(2,6,23,0))';
                el.style.animation = 'firstLightPulse 1.8s ease-out forwards';
                
                const st = document.createElement('style');
                st.textContent = `
                    @keyframes firstLightPulse {
                        0% { opacity: 0; transform: scale(0.6); filter: blur(4px); }
                        25% { opacity: 1; transform: scale(1.0); filter: blur(2px); }
                        100% { opacity: 0; transform: scale(1.8); filter: blur(8px); }
                    }
                `;
                
                document.head.appendChild(st);
                document.getElementById(this.layerId).appendChild(el);
                
                setTimeout(() => {
                    try { el.remove(); } catch {}
                }, 2000);
                
                console.error('firstLight effect error:', e);
                return null;
            }
        }
        
        async showPredictionEffect(duration=2000) {
            if (!this.checkCooldown('prediction')) return null;
            try {
                await this.ensureTsParticles();
                
                // Kehanet Paneli elemanını bul
                const kehanetPanel = document.getElementById('kehanet-panel');
                if (!kehanetPanel) return null;
                
                // Panel koordinatlarını al
                const rect = kehanetPanel.getBoundingClientRect();
                const x = (rect.left + rect.right) / 2;
                const y = (rect.top + rect.bottom) / 2;
                
                // Efekt ayarları
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: false },
                    particles: { number: { value: 0 } },
                    emitters: {
                        position: { x: (x / window.innerWidth) * 100, y: (y / window.innerHeight) * 100 },
                        rate: { delay: 0.01, quantity: 30 },
                        life: { duration: duration/1000, count: 1 },
                        particles: {
                            move: { 
                                enable: true, 
                                speed: {min: 1, max: 3},
                                outModes: 'destroy',
                                direction: 'out',
                                straight: false,
                                bounce: false
                            },
                            color: { value: ['#a855f7','#3b82f6','#06b6d4'] },
                            shape: { type: 'circle' },
                            size: { value: {min: 1, max: 4} },
                            opacity: { value: {min: 0.3, max: 0.8} },
                            life: { duration: {min: 1, max: 3} },
                            roll: { 
                                enable: true,
                                speed: 3
                            },
                            wobble: { 
                                enable: true, 
                                distance: 3,
                                speed: 10
                            },
                            tilt: {
                                enable: true,
                                direction: 'random',
                                value: {
                                    min: 0,
                                    max: 360
                                },
                                animation: {
                                    enable: true,
                                    speed: 10
                                }
                            },
                            shadow: { 
                                enable: true, 
                                blur: 3,
                                color: '#a5f3fc' 
                            }
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration);
                
                return container;
            } catch(e) {
                console.error('prediction effect error:', e);
                return null;
            }
        }
        
        async showHorsemanEffect(horseman, duration=3500) {
            if (!this.checkCooldown('horseman')) return null;
            try {
                await this.ensureTsParticles();
                
                // Atlı tipine göre renkleri ve efekt tipini belirle
                let colors, emitterShape, speed, particleShape;
                
                switch(horseman) {
                    case 'KITLIK':
                        colors = ['#fbbf24', '#f59e0b', '#d97706']; // Sarı/Turuncu
                        emitterShape = 'square';
                        speed = {min: 1, max: 3};
                        particleShape = 'square';
                        break;
                    case 'SALGIN':
                        colors = ['#10b981', '#059669', '#047857']; // Yeşil
                        emitterShape = 'circle';
                        speed = {min: 2, max: 5};
                        particleShape = 'circle';
                        break;
                    case 'SAVAŞ':
                        colors = ['#ef4444', '#dc2626', '#b91c1c']; // Kırmızı
                        emitterShape = 'triangle';
                        speed = {min: 5, max: 15};
                        particleShape = 'triangle';
                        break;
                    case 'ÖLÜM':
                        colors = ['#8b5cf6', '#7c3aed', '#6d28d9']; // Mor
                        emitterShape = 'star';
                        speed = {min: 10, max: 25};
                        particleShape = 'polygon';
                        break;
                    default:
                        colors = ['#ffffff', '#e2e8f0', '#cbd5e1']; // Beyaz/Gri
                        emitterShape = 'circle';
                        speed = {min: 3, max: 8};
                        particleShape = 'circle';
                }
                
                // Efekt konfigürasyonu
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: true },
                    particles: { 
                        number: { value: 0 },
                        move: {
                            enable: true,
                            speed: speed,
                            direction: 'random',
                            outModes: 'out'
                        },
                        opacity: {
                            value: {min: 0.3, max: 0.7}
                        },
                        size: {
                            value: {min: 1, max: 5}
                        },
                        color: {
                            value: colors
                        },
                        shape: {
                            type: particleShape
                        },
                        life: {
                            duration: {min: 1, max: duration/1000}
                        }
                    },
                    emitters: {
                        direction: 'random',
                        position: {
                            x: 50,
                            y: 50
                        },
                        rate: {
                            delay: 0.1,
                            quantity: 5
                        },
                        size: {
                            width: 100,
                            height: 100
                        },
                        life: {
                            duration: duration/1000 - 0.5,
                            count: 1
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration);
                
                return container;
            } catch(e) {
                console.error('horseman effect error:', e);
                return null;
            }
        }
        
        async showConfluenceEffect(position, signalType, duration=1500) {
            if (!this.checkCooldown('confluence')) return null;
            try {
                await this.ensureTsParticles();
                
                // Sinyal tipine göre renkleri belirle
                let colors;
                if (signalType === 'BUY') {
                    colors = ['#22c55e', '#16a34a', '#15803d']; // Yeşil tonları
                } else if (signalType === 'SELL') {
                    colors = ['#ef4444', '#dc2626', '#b91c1c']; // Kırmızı tonları
                } else {
                    colors = ['#3b82f6', '#2563eb', '#1d4ed8']; // Mavi tonları (nötr/bilgi)
                }
                
                // Pozisyon bilgisi
                const x = position?.x || 50;
                const y = position?.y || 50;
                
                // Efekt konfigürasyonu
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: false },
                    particles: { number: { value: 0 } },
                    emitters: {
                        position: { x, y },
                        rate: { delay: 0.01, quantity: 20 },
                        life: { duration: duration/1000, count: 1 },
                        particles: {
                            move: { 
                                enable: true, 
                                speed: {min: 3, max: 7},
                                outModes: 'destroy',
                                direction: 'none',
                                gravity: { 
                                    enable: true,
                                    acceleration: 0.2
                                },
                                trail: {
                                    enable: true,
                                    fillColor: '#000',
                                    length: 4
                                }
                            },
                            color: { value: colors },
                            shape: { type: 'circle' },
                            size: { value: {min: 2, max: 5} },
                            opacity: { 
                                value: {min: 0.4, max: 0.8},
                                animation: {
                                    enable: true,
                                    speed: 1,
                                    minimumValue: 0,
                                    destroy: 'min'
                                }
                            },
                            life: { duration: {min: 0.5, max: 1.5} },
                            rotate: {
                                enable: true,
                                value: {
                                    min: 0,
                                    max: 360
                                },
                                animation: {
                                    enable: true,
                                    speed: 5
                                }
                            },
                            shadow: { 
                                enable: true, 
                                blur: 5,
                                color: colors[0]
                            }
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration);
                
                return container;
            } catch(e) {
                console.error('confluence effect error:', e);
                return null;
            }
        }
    }
    
    // IndexedDB yardımcıları - Panteon için
    async function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('coinank_data', 2);
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Panteon durumu için object store
                if (!db.objectStoreNames.contains('panteon_state')) {
                    db.createObjectStore('panteon_state');
                }
                
                // Diğer store'lar burada eklenebilir
            };
            
            request.onsuccess = (event) => {
                resolve({
                    db: event.target.result,
                    get: async (store, key) => {
                        return new Promise((resolve, reject) => {
                            const transaction = event.target.result.transaction(store, 'readonly');
                            const objectStore = transaction.objectStore(store);
                            const getRequest = objectStore.get(key);
                            
                            getRequest.onsuccess = () => {
                                resolve(getRequest.result);
                            };
                            
                            getRequest.onerror = (error) => {
                                reject(error);
                            };
                        });
                    },
                    put: async (store, value, key) => {
                        return new Promise((resolve, reject) => {
                            const transaction = event.target.result.transaction(store, 'readwrite');
                            const objectStore = transaction.objectStore(store);
                            const putRequest = objectStore.put(value, key);
                            
                            putRequest.onsuccess = () => {
                                resolve(putRequest.result);
                            };
                            
                            putRequest.onerror = (error) => {
                                reject(error);
                            };
                        });
                    },
                    delete: async (store, key) => {
                        return new Promise((resolve, reject) => {
                            const transaction = event.target.result.transaction(store, 'readwrite');
                            const objectStore = transaction.objectStore(store);
                            const deleteRequest = objectStore.delete(key);
                            
                            deleteRequest.onsuccess = () => {
                                resolve();
                            };
                            
                            deleteRequest.onerror = (error) => {
                                reject(error);
                            };
                        });
                    }
                });
            };
            
            request.onerror = (event) => {
                reject(event.target.error);
            };
        });
    }
    
    // Panteon Bootstrap
    async function bootstrapPantheon() {
        if(!('indexedDB' in window)) {
            console.error('IndexedDB desteklenmiyor. Geçici bellek modu.');
        }
        
        const db = PanteonDBManager.instance; // Use the PanteonDBManager
        await db.open();
        
        // İlk Işık Efekti
        const fx = new EffectsManager();
        await fx.firstLight(2200);
        
        // UI mitolojik isimlendirme (buton/metin güncellemeleri)
        const renameUI = () => {
            const honorBtn = document.getElementById('honor-board-btn'); 
            if(honorBtn) honorBtn.textContent = 'Panteon';
            
            const bannedBtn = document.getElementById('banned-board-btn'); 
            if(bannedBtn) bannedBtn.textContent = 'Zindan';
            
            const saveBtn = document.getElementById('save-settings-btn'); 
            if(saveBtn) saveBtn.textContent = 'Kaderi Mühürle';
            
            const resetBtn = document.getElementById('reset-all-settings-btn'); 
            if(resetBtn) resetBtn.textContent = 'Evreni Sıfırla';
            
            const mobileHonor = document.getElementById('mobile-honor-board-btn'); 
            if(mobileHonor) mobileHonor.textContent = '🏛️';
            
            const mobileBanned = document.getElementById('mobile-banned-board-btn'); 
            if(mobileBanned) mobileBanned.textContent = 'ZDN';
            
            const settingsTitle = document.querySelector('.settings-modal-header span'); 
            if(settingsTitle) settingsTitle.textContent = 'AMELİYATHANE & OPTİMİZASYON';
            
            const clearSignals = document.getElementById('modal-clear-signals-btn'); 
            if(clearSignals) clearSignals.textContent = 'Kurban Et';
        };
        
        // Panteon panelini persist edilen değerlerle başlat
        const initPanteonPanel = async () => {
            const state = await db.getPanteonState();
            const envEl = document.getElementById('pp-env'); 
            if(envEl) envEl.textContent = state.env?.version || 'v3.5';
            
            const setAmb = (id, data) => {
                const root = document.querySelector(`.ambassador[data-name="${id.replace('amb-','')}"`);
                if(!root) return;
                
                const rep = root.querySelector('.reputation-score'); 
                if(rep) {
                    rep.textContent = String(data.reputation ?? 0);
                }
                
                const mode = root.querySelector('.ambassador-mode'); 
                if(mode) {
                    mode.textContent = data.mode || 'İnançlı';
                    root.dataset.mode = data.mode || 'İnançlı';
                }
            };
            
            setAmb('amb-metatron', state.ambassadors?.Metatron || { reputation: 0, mode: 'İnançlı' });
            setAmb('amb-uriel', state.ambassadors?.Uriel || { reputation: 0, mode: 'İnançlı' });
            setAmb('amb-raphael', state.ambassadors?.Raphael || { reputation: 0, mode: 'İnançlı' });
            setAmb('amb-gabriel', state.ambassadors?.Gabriel || { reputation: 0, mode: 'İnançlı' });
            setAmb('amb-michael', state.ambassadors?.Michael || { reputation: 0, mode: 'İnançlı' });
        };
        
        initPanteonPanel();
        renameUI();
        
        // Global export
        window.Pantheon = {
            db,
            effects: new EffectsManager()
        };
    }
    
    // Kehanet Paneli Sınıfı - Piyasa Tahmini ve Analizi
    class KehanetPanel {
        constructor() {
            this.panel = document.getElementById('kehanet-panel');
            this.expandBtn = document.getElementById('kp-expand-btn');
            this.refreshBtn = document.getElementById('kp-refresh-btn');
            this.confidenceFill = document.getElementById('kp-confidence-fill');
            this.confidenceLabel = document.getElementById('kp-confidence-label');
            this.miniChart = document.getElementById('kp-mini-chart');
            
            this.elements = {
                regime: document.getElementById('kp-regime'),
                session: document.getElementById('kp-session'),
                guardian: document.getElementById('kp-guardian'),
                pulse: document.getElementById('kp-pulse'),
                trend: document.getElementById('kp-trend'),
                prediction: document.getElementById('kp-prediction'),
                probability: document.getElementById('kp-probability'),
                timeframe: document.getElementById('kp-timeframe'),
                liquidity: document.getElementById('kp-liquidity'),
                pressure: document.getElementById('kp-pressure')
            };
            
            this.predictions = {
                trend: null,
                direction: null,
                probability: 0,
                timeTarget: null,
                confidence: 0,
                lastUpdate: null,
                supportLevels: [],
                resistanceLevels: []
            };
            
            this.marketData = {
                price: 0,
                volume: 0,
                atr: 0,
                regime: '—',
                liquidityImbalance: 0
            };
            
            this.isExpanded = false;
            this.chart = null;
            
            this.init();
        }
        
        init() {
            this.bindEvents();
            this.initMiniChart();
            this.loadPanelState();
            
            // İlk senkronizasyonu başlat
            this.sync();
            
            // Düzenli güncelleme aralığı
            setInterval(() => this.sync(), 1500);
            
            // Her 5 dakikada bir yeni tahmin oluştur
            setInterval(() => this.generatePrediction(), 5 * 60 * 1000);
            
            // İlk tahmini oluştur
            this.generatePrediction();
            
            console.log('Kehanet Paneli başlatıldı');
        }
        
        bindEvents() {
            // Panel genişletme/daraltma düğmesi
            if (this.expandBtn) {
                this.expandBtn.addEventListener('click', () => {
                    this.togglePanelExpand();
                });
            }
            
            // Tahmin yenileme düğmesi
            if (this.refreshBtn) {
                this.refreshBtn.addEventListener('click', () => {
                    this.generatePrediction(true);
                });
            }
            
            // Piyasa olaylarına abone ol
            if (window.app) {
                // Piyasa rejimi değiştiğinde
                window.app.on('marketRegimeChanged', (regime) => {
                    this.marketData.regime = regime;
                    this.generatePrediction();
                });
                
                // Yeni mum oluştuğunda
                window.app.on('newCandle', (candle) => {
                    this.updateMiniChart(candle);
                });
            }
        }
        
        sync() {
            if (!window.app) return;
            
            // Temel veriler
            const regime = window.app.marketRegime || '—';
            const session = window.app.sessionState || '—';
            const guardian = (window.app.settings?.features?.enableRiskGuardian) ? 'Aktif' : 'Pasif';
            
            // ATR (Average True Range) hesaplama
            const atr = window.app.indicators?.atr || 0;
            const price = window.app.marketData?.price || 0;
            const atrPct = (atr && price) ? (atr / price) : 0;
            const pulse = atrPct ? `${(atrPct*100).toFixed(2)}%` : '—';
            
            // Tüm piyasa verilerini güncelle
            this.marketData = {
                price: price,
                volume: window.app.marketData?.volume || 0,
                atr: atr,
                regime: regime,
                liquidityImbalance: this.calculateLiquidityImbalance()
            };
            
            // Temel bilgileri güncelle
            this.updateElement('regime', regime);
            this.updateElement('session', session);
            this.updateElement('guardian', guardian);
            this.updateElement('pulse', pulse);
            
            // Eğilim bilgisini güncelle
            const trend = this.determineTrend();
            this.updateElement('trend', trend);
            
            // Gelişmiş panel değerlerini güncelle (tahminlere dayalı)
            this.updateAdvancedPanelValues();
        }
        
        updateElement(key, value) {
            const element = this.elements[key];
            if (element) {
                element.textContent = value;
                
                // Bazı değerler için renk sınıflarını güncelle
                if (key === 'trend') {
                    element.className = 'kp-val'; // Reset
                    if (value.includes('Yükseliş')) {
                        element.classList.add('trend-up');
                    } else if (value.includes('Düşüş')) {
                        element.classList.add('trend-down');
                    } else if (value.includes('Yatay')) {
                        element.classList.add('trend-neutral');
                    }
                }
            }
        }
        
        togglePanelExpand() {
            this.isExpanded = !this.isExpanded;
            
            if (this.isExpanded) {
                this.panel.classList.add('kp-panel-expanded');
                // Mini grafiği yeniden boyutlandır
                if (this.chart) {
                    this.chart.resize(280, 70);
                }
            } else {
                this.panel.classList.remove('kp-panel-expanded');
            }
            
            // Panel durumunu kaydet
            localStorage.setItem('kehanet_panel_expanded', this.isExpanded);
        }
        
        loadPanelState() {
            const savedState = localStorage.getItem('kehanet_panel_expanded');
            if (savedState === 'true') {
                this.isExpanded = true;
                this.panel.classList.add('kp-panel-expanded');
            }
        }
        
        determineTrend() {
            if (!window.app || !window.app.indicators) {
                return 'Belirsiz';
            }
            
            // Trend belirlemek için kullanılabilecek göstergeler
            const macd = window.app.indicators.macd;
            const rsi = window.app.indicators.rsi;
            const ema200 = window.app.indicators.ema200;
            const price = window.app.marketData?.price || 0;
            
            if (!macd || !rsi || !ema200 || !price) {
                return 'Veri Yok';
            }
            
            // MACD ve RSI'ye dayalı trend belirleme
            let trendStrength = 0;
            
            // MACD trendi
            if (macd.histogram > 0 && macd.signal < macd.macd) {
                trendStrength += 1; // Yükseliş sinyali
            } else if (macd.histogram < 0 && macd.signal > macd.macd) {
                trendStrength -= 1; // Düşüş sinyali
            }
            
            // RSI trendi
            if (rsi > 60) {
                trendStrength += 1; // Yükseliş
            } else if (rsi < 40) {
                trendStrength -= 1; // Düşüş
            }
            
            // Fiyat ve EMA200 ilişkisi
            if (price > ema200) {
                trendStrength += 1; // Uzun vadeli yükseliş
            } else if (price < ema200) {
                trendStrength -= 1; // Uzun vadeli düşüş
            }
            
            // Son trendi belirle
            if (trendStrength >= 2) {
                return '↗️ Yükseliş';
            } else if (trendStrength <= -2) {
                return '↘️ Düşüş';
            } else {
                return '↔️ Yatay';
            }
        }
        
        calculateLiquidityImbalance() {
            // Emir defteri verilerini al (eğer mevcutsa)
            if (!window.app || !window.app.orderBook) {
                return 0;
            }
            
            const asks = window.app.orderBook.asks || [];
            const bids = window.app.orderBook.bids || [];
            
            if (asks.length === 0 || bids.length === 0) {
                return 0;
            }
            
            // En iyi 5 seviyenin toplam likidite hacmini hesapla
            let totalAskVolume = 0;
            let totalBidVolume = 0;
            
            for (let i = 0; i < Math.min(5, asks.length); i++) {
                totalAskVolume += asks[i].quantity;
            }
            
            for (let i = 0; i < Math.min(5, bids.length); i++) {
                totalBidVolume += bids[i].quantity;
            }
            
            // Likidite dengesizliği hesapla (-1 ile 1 arasında)
            const totalVolume = totalAskVolume + totalBidVolume;
            if (totalVolume === 0) return 0;
            
            return (totalBidVolume - totalAskVolume) / totalVolume;
        }
        
        initMiniChart() {
            if (!this.miniChart) return;
            
            try {
                // LightweightCharts'ı kullanarak mini grafik oluştur
                this.chart = LightweightCharts.createChart(this.miniChart, {
                    width: 280,
                    height: 70,
                    layout: {
                        background: { type: 'solid', color: 'transparent' },
                        textColor: 'rgba(255, 255, 255, 0.5)',
                    },
                    grid: {
                        vertLines: { color: 'rgba(42, 46, 57, 0)' },
                        horzLines: { color: 'rgba(42, 46, 57, 0.2)' },
                    },
                    timeScale: {
                        visible: false
                    },
                    rightPriceScale: {
                        visible: false
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                        vertLine: { visible: false },
                        horzLine: { visible: false }
                    },
                    handleScale: false,
                    handleScroll: false
                });
                
                // Fiyat serisini oluştur
                this.priceSeries = this.chart.addAreaSeries({
                    topColor: 'rgba(33, 150, 243, 0.56)',
                    bottomColor: 'rgba(33, 150, 243, 0.04)',
                    lineColor: 'rgba(33, 150, 243, 1)',
                    lineWidth: 2
                });
                
                // Başlangıç verileri (son 10 mum)
                const initialData = this.getInitialChartData();
                this.priceSeries.setData(initialData);
                
            } catch (error) {
                console.error('Mini grafik oluşturma hatası:', error);
            }
        }
        
        getInitialChartData() {
            // App'den geçmiş verileri al veya varsayılan oluştur
            if (window.app && window.app.candles && window.app.candles.length > 0) {
                return window.app.candles.slice(-10).map(candle => ({
                    time: candle.time / 1000, // Unix zaman damgası
                    value: candle.close
                }));
            }
            
            // Varsayılan veriler
            const data = [];
            const now = Math.floor(Date.now() / 1000);
            const price = 20000; // Varsayılan fiyat
            
            for (let i = 9; i >= 0; i--) {
                data.push({
                    time: now - i * 60,
                    value: price + Math.random() * 500 - 250
                });
            }
            
            return data;
        }
        
        updateMiniChart(candle) {
            if (!this.priceSeries || !candle) return;
            
            // Yeni mumu grafiğe ekle
            this.priceSeries.update({
                time: candle.time / 1000,
                value: candle.close
            });
        }
        
        generatePrediction(userTriggered = false) {
            if (!window.app) return;
            
            // Tahmin için gerekli verileri topla
            const price = window.app.marketData?.price || 0;
            const volume = window.app.marketData?.volume || 0;
            const regime = window.app.marketRegime || 'NORMAL';
            const indicators = window.app.indicators || {};
            
            // Eğer kullanıcı tetiklediyse, özel efekt göster
            if (userTriggered) {
                this.showPredictionEffect();
            }
            
            // Tahmin algoritması
            let direction = null;
            let probability = 0;
            let confidence = 0;
            
            // Trend belirle
            const trend = this.determineTrend();
            
            // Farklı stratejilerin sinyallerini ağırlıklandırarak topla
            const signals = this.aggregateSignals();
            
            // Yön ve olasılık hesapla
            if (signals.bullish > signals.bearish) {
                direction = 'YUKARI';
                probability = Math.min(90, 50 + (signals.bullish - signals.bearish) * 5);
            } else if (signals.bearish > signals.bullish) {
                direction = 'AŞAĞI';
                probability = Math.min(90, 50 + (signals.bearish - signals.bullish) * 5);
            } else {
                direction = 'YATAY';
                probability = 50;
            }
            
            // Güven seviyesi hesaplama
            confidence = this.calculateConfidence(signals, regime);
            
            // Destek/direnç seviyeleri hesaplama
            const levels = this.calculateSupportResistanceLevels(price);
            
            // Zaman hedefi (dakika cinsinden)
            const timeTarget = this.calculateTimeTarget(regime, signals.volatility);
            
            // Tahmin sonuçlarını güncelle
            this.predictions = {
                trend: trend,
                direction: direction,
                probability: probability,
                timeTarget: timeTarget,
                confidence: confidence,
                lastUpdate: new Date(),
                supportLevels: levels.support,
                resistanceLevels: levels.resistance,
                liquidityImbalance: this.marketData.liquidityImbalance
            };
            
            // UI'ı güncelle
            this.updateAdvancedPanelValues();
            this.updateConfidenceBar(confidence);
            
            return this.predictions;
        }
        
        aggregateSignals() {
            if (!window.app || !window.app.indicators) {
                return { bullish: 0, bearish: 0, neutral: 0, volatility: 0 };
            }
            
            const ind = window.app.indicators;
            let bullish = 0;
            let bearish = 0;
            let neutral = 0;
            let volatility = 0;
            
            // MACD sinyalleri
            if (ind.macd) {
                if (ind.macd.histogram > 0 && ind.macd.histogram > ind.macd.histogramPrev) {
                    bullish += 2;
                } else if (ind.macd.histogram < 0 && ind.macd.histogram < ind.macd.histogramPrev) {
                    bearish += 2;
                } else {
                    neutral += 1;
                }
            }
            
            // RSI sinyalleri
            if (ind.rsi) {
                if (ind.rsi > 70) {
                    bearish += 1; // Aşırı alım
                } else if (ind.rsi < 30) {
                    bullish += 1; // Aşırı satım
                } else if (ind.rsi > 55) {
                    bullish += 0.5;
                } else if (ind.rsi < 45) {
                    bearish += 0.5;
                } else {
                    neutral += 1;
                }
            }
            
            // Bollinger Bandı sinyalleri
            if (ind.bb && window.app.marketData?.price) {
                const price = window.app.marketData.price;
                if (price > ind.bb.upper) {
                    bearish += 1.5; // Üst banda dokunma
                } else if (price < ind.bb.lower) {
                    bullish += 1.5; // Alt banda dokunma
                } else if (price > ind.bb.middle) {
                    bullish += 0.5;
                } else if (price < ind.bb.middle) {
                    bearish += 0.5;
                }
                
                // Volatilite hesaplama (bant genişliği)
                volatility = (ind.bb.upper - ind.bb.lower) / ind.bb.middle;
            }
            
            // Hareketli ortalama sinyalleri
            if (ind.ema9 && ind.ema21 && ind.ema55) {
                if (ind.ema9 > ind.ema21 && ind.ema21 > ind.ema55) {
                    bullish += 2; // Güçlü yükseliş trendi
                } else if (ind.ema9 < ind.ema21 && ind.ema21 < ind.ema55) {
                    bearish += 2; // Güçlü düşüş trendi
                } else if (ind.ema9 > ind.ema21) {
                    bullish += 0.5;
                } else if (ind.ema9 < ind.ema21) {
                    bearish += 0.5;
                }
            }
            
            // Hacim analizi
            if (window.app.marketData?.volume && window.app.marketData?.volumeAvg) {
                const volumeRatio = window.app.marketData.volume / window.app.marketData.volumeAvg;
                
                if (volumeRatio > 1.5 && bullish > bearish) {
                    bullish += volumeRatio - 1; // Hacim artışı ile birlikte alım sinyali güçlenir
                } else if (volumeRatio > 1.5 && bearish > bullish) {
                    bearish += volumeRatio - 1; // Hacim artışı ile birlikte satım sinyali güçlenir
                }
            }
            
            // ATR (volatilite göstergesi)
            if (ind.atr && window.app.marketData?.price) {
                const atrPct = ind.atr / window.app.marketData.price;
                volatility += atrPct * 100; // Volatiliteyi yüzde olarak ekle
            }
            
            return { bullish, bearish, neutral, volatility };
        }
        
        calculateConfidence(signals, regime) {
            // Güven seviyesi hesaplama (0-100 arasında)
            const totalSignals = signals.bullish + signals.bearish + signals.neutral;
            if (totalSignals === 0) return 50;
            
            // Dominant sinyalin gücü
            const dominantForce = Math.max(signals.bullish, signals.bearish);
            const dominantRatio = dominantForce / totalSignals;
            
            // Volatilite faktörü
            const volatilityFactor = Math.max(0, Math.min(1, 2 - signals.volatility / 5));
            
            // Rejim faktörü
            let regimeFactor = 1;
            if (regime === 'KITLIK') regimeFactor = 0.9; // Düşük volatilite, tahminler daha zor
            if (regime === 'SALGIN') regimeFactor = 0.7; // Kaotik piyasa, tahminler çok zor
            if (regime === 'SAVAŞ') regimeFactor = 1.1; // Trendli piyasada, tahminler daha kolay
            if (regime === 'ÖLÜM') regimeFactor = 0.5; // Ekstrem olaylar, tahminler çok zor
            
            // Güven seviyesi
            const confidence = dominantRatio * 100 * volatilityFactor * regimeFactor;
            
            return Math.min(95, Math.max(5, Math.round(confidence)));
        }
        
        calculateSupportResistanceLevels(currentPrice) {
            if (!currentPrice) return { support: [], resistance: [] };
            
            // Son fiyat hareketlerine dayalı pivot noktaları hesaplama
            const candles = window.app?.candles || [];
            if (candles.length < 10) {
                // Varsayılan seviyeler (basitleştirilmiş)
                return {
                    support: [currentPrice * 0.99, currentPrice * 0.98, currentPrice * 0.97],
                    resistance: [currentPrice * 1.01, currentPrice * 1.02, currentPrice * 1.03]
                };
            }
            
            // Geçmiş fiyat verilerinden pivot noktaları bulma
            const pivots = this.findPivotPoints(candles);
            const atr = window.app.indicators?.atr || (currentPrice * 0.01);
            
            // Mevcut fiyata göre destek ve direnç seviyelerini filtrele
            const support = pivots.filter(p => p < currentPrice).sort((a, b) => b - a).slice(0, 3);
            const resistance = pivots.filter(p => p > currentPrice).sort((a, b) => a - b).slice(0, 3);
            
            // Eğer yeterli seviye bulunamadıysa, ATR'ye dayalı seviyeler ekle
            while (support.length < 3) {
                const lastSupport = support.length > 0 ? support[support.length - 1] : currentPrice;
                support.push(lastSupport - atr);
            }
            
            while (resistance.length < 3) {
                const lastResistance = resistance.length > 0 ? resistance[resistance.length - 1] : currentPrice;
                resistance.push(lastResistance + atr);
            }
            
            return { support, resistance };
        }
        
        findPivotPoints(candles) {
            const pivots = [];
            const lookback = Math.min(candles.length, 100); // Son 100 mum
            
            // Basit pivot noktaları (yüksek ve düşük noktalar)
            for (let i = 5; i < lookback - 5; i++) {
                const isHighPivot = candles[i].high > candles[i-1].high && 
                                   candles[i].high > candles[i-2].high &&
                                   candles[i].high > candles[i+1].high && 
                                   candles[i].high > candles[i+2].high;
                
                const isLowPivot = candles[i].low < candles[i-1].low && 
                                  candles[i].low < candles[i-2].low &&
                                  candles[i].low < candles[i+1].low && 
                                  candles[i].low < candles[i+2].low;
                
                if (isHighPivot) pivots.push(candles[i].high);
                if (isLowPivot) pivots.push(candles[i].low);
            }
            
            // Yakın pivot noktalarını birleştir
            const uniquePivots = [];
            const tolerance = window.app.indicators?.atr || 0;
            
            pivots.forEach(pivot => {
                // Benzer bir pivot noktası var mı kontrol et
                const similarPivot = uniquePivots.find(p => Math.abs(p - pivot) < tolerance);
                if (!similarPivot) {
                    uniquePivots.push(pivot);
                }
            });
            
            return uniquePivots;
        }
        
        calculateTimeTarget(regime, volatility) {
            // Zaman hedefi (dakika cinsinden) hesaplama
            let baseTime = 30; // Varsayılan 30 dakika
            
            // Rejime göre ayarla
            if (regime === 'KITLIK') baseTime = 60; // Yatay piyasada daha uzun sürer
            if (regime === 'SALGIN') baseTime = 15; // Dalgalı piyasada daha hızlı değişir
            if (regime === 'SAVAŞ') baseTime = 45; // Trend devam edecek
            if (regime === 'ÖLÜM') baseTime = 10; // Çok hızlı değişimler
            
            // Volatiliteye göre ayarla
            const volatilityFactor = Math.max(0.5, Math.min(2, 1 + volatility / 10));
            const targetMinutes = Math.round(baseTime / volatilityFactor);
            
            return targetMinutes;
        }
        
        updateAdvancedPanelValues() {
            // Tahmin yönü
            this.updateElement('prediction', this.predictions.direction || '—');
            
            // Olasılık
            const probability = this.predictions.probability ? `%${this.predictions.probability}` : '—';
            this.updateElement('probability', probability);
            
            // Zaman hedefi
            const timeframe = this.predictions.timeTarget ? `${this.predictions.timeTarget} dk` : '—';
            this.updateElement('timeframe', timeframe);
            
            // Likidite
            const liquidityImbalance = this.marketData.liquidityImbalance;
            let liquidityText = '—';
            
            if (liquidityImbalance > 0.2) {
                liquidityText = '🟢 Alım Baskısı';
            } else if (liquidityImbalance < -0.2) {
                liquidityText = '🔴 Satış Baskısı';
            } else if (liquidityImbalance !== 0) {
                liquidityText = '⚪ Dengeli';
            }
            
            this.updateElement('liquidity', liquidityText);
            
            // Baskı göstergesi
            let pressureText = '—';
            if (window.app && window.app.indicators && window.app.indicators.rsi) {
                const rsi = window.app.indicators.rsi;
                if (rsi > 75) {
                    pressureText = '🔴 Aşırı Alım';
                } else if (rsi > 60) {
                    pressureText = '🟠 Yüksek';
                } else if (rsi < 25) {
                    pressureText = '🔵 Aşırı Satım';
                } else if (rsi < 40) {
                    pressureText = '🔷 Düşük';
                } else {
                    pressureText = '⚪ Normal';
                }
            }
            
            this.updateElement('pressure', pressureText);
        }
        
        updateConfidenceBar(confidence) {
            if (this.confidenceFill && this.confidenceLabel) {
                this.confidenceFill.style.width = `${confidence}%`;
                this.confidenceLabel.textContent = `Güven: %${confidence}`;
                
                // Renk değişimi
                if (confidence < 30) {
                    this.confidenceFill.style.background = 'linear-gradient(90deg, var(--danger) 0%, var(--warning) 100%)';
                } else if (confidence < 60) {
                    this.confidenceFill.style.background = 'linear-gradient(90deg, var(--warning) 0%, var(--info) 100%)';
                } else {
                    this.confidenceFill.style.background = 'linear-gradient(90deg, var(--info) 0%, var(--success) 100%)';
                }
            }
        }
        
        showPredictionEffect() {
            // Tahmin yenileme efekti
            if (this.panel) {
                this.panel.classList.add('prediction-refresh');
                setTimeout(() => {
                    this.panel.classList.remove('prediction-refresh');
                }, 1000);
            }
            
            // Özel efekt (tsParticles kullanarak)
            if (window.Pantheon && window.Pantheon.effects) {
                window.Pantheon.effects.showPredictionEffect();
            }
        }
    }
    
    // Kehanet Paneli JS Fonksiyonu
    const initKehanetPanel = () => {
        // Kehanet Panelini oluştur ve başlat
        window.kehanetPanel = new KehanetPanel();
    };
    
    // Sayfa yüklenince Panteon ve Kehanet Panelini başlat
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            // Panteon sistemini başlat - ABM (Ajan Tabanlı Modelleme) ile yeni versiyonu başlat
            window.pantheonSystem = new PantheonSystem();
            
            // Panteon olaylarını dinle
            document.addEventListener('pantheon:state_change', (event) => {
                console.log('Panteon Durum Değişikliği:', event.detail);
                // Burada durum değişikliğini UI'da gösterebilir veya başka işlemler yapabilirsiniz
            });
            
            document.addEventListener('pantheon:decision', (event) => {
                console.log('Panteon Kararı:', event.detail);
                
                // Karar UI'da gösterme
                const decision = event.detail;
                showNotification(
                    `Elçiler Konseyi: ${decision.recommendation}`,
                    `Güven: ${decision.confidence.toFixed(1)}% | Risk: ${(decision.riskLevel * 100).toFixed(1)}%`,
                    decision.recommendation === 'ATAK' ? 'success' : 
                    decision.recommendation === 'GERİÇEKİL' ? 'error' : 'info',
                    5000
                );
            });
            
            document.addEventListener('pantheon:revelation', (event) => {
                console.log('Metatron Vahiy:', event.detail);
                showNotification(
                    'Metatron\'un Vahyi',
                    `Öngörü Gücü: ${event.detail.power.toFixed(1)}%`,
                    'info',
                    4000
                );
            });
            
            document.addEventListener('pantheon:valor', (event) => {
                console.log('Uriel Cesaret:', event.detail);
                showNotification(
                    'Uriel\'in Cesareti',
                    `Cesaret Gücü: ${event.detail.power.toFixed(1)}%`,
                    'warning',
                    4000
                );
            });
            
            // Kehanet panelini başlat
            initKehanetPanel();
            
            // App hazır olduğunda window.app'e veri erişimini enjekte et
            const ensureInject = setInterval(() => {
                if(window.app && window.Pantheon) {
                    clearInterval(ensureInject);
                }
            }, 100);
        } catch(e) {
            console.error('Panteon bootstrap hatası:', e);
        }
    });
    
    // Önemli sınıfları önce tanımla (PantheonSystem)
    /**
     * PantheonSystem - Ajan Tabanlı Modelleme yaklaşımıyla geliştirilmiş,
     * stratejileri kategorize eden ve kararları etkileyen akıllı sistem
     */
    class PantheonSystem {
        constructor() {
            // Elçi ajanlarını tanımla (her biri otonomdur ve kendi durumuna sahiptir)
            this.ambassadors = {
                metatron: {
                    name: 'Metatron',
                    role: 'wisdom',
                    displayName: 'Metatron',
                    archetype: 'Bilgelik, Analiz',
                    color: 'var(--metatron-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'İNANÇLI', // İNANÇLI, ŞÜPHECİ, KIYAMET
                        confidence: 75,
                        power: 0, // Anlık güç/etki seviyesi (0-100)
                        active: true,
                        risk_appetite: 0.5, // 0-1 arası risk iştahı
                        confirmation_bias: 0.3, // Onaylama yanlılığı
                        mean_reversion_bias: 0, // Ortalamaya dönüş yanlılığı
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranışı (Behavior Rules)
                    strategies: ['SupportResistanceStrategy', 'MeanReversionStrategy', 'OrderBookImbalanceStrategy'],
                    primaryDataSources: ['Price Levels', 'Order Book Depth', 'RSI'],
                    
                    // ABM - Çevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 1.2, weight_modifier: 1.3 }, // Yatay piyasada güçlü
                        'SALGIN': { risk_modifier: 0.9, weight_modifier: 1.1 }, // Dalgalı piyasada orta
                        'SAVAŞ': { risk_modifier: 0.7, weight_modifier: 0.8 },  // Trendli piyasada zayıf
                        'ÖLÜM': { risk_modifier: 0.4, weight_modifier: 0.5 }    // Çöküşte çok zayıf
                    }
                },
                
                uriel: {
                    name: 'Uriel',
                    role: 'courage',
                    displayName: 'Uriel',
                    archetype: 'Cesaret, Hız',
                    color: 'var(--uriel-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'İNANÇLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.8,
                        trend_following_bias: 0.7,
                        aggression_level: 0.6,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranışı (Behavior Rules)
                    strategies: ['BreakoutPatternStrategy', 'MomentumStrategy', 'TrendFollowingStrategy'],
                    primaryDataSources: ['Price Velocity', 'Volume Spikes', 'Volatility'],
                    
                    // ABM - Çevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.6, weight_modifier: 0.5 },  // Yatay piyasada zayıf
                        'SALGIN': { risk_modifier: 0.8, weight_modifier: 0.7 },  // Dalgalı piyasada orta
                        'SAVAŞ': { risk_modifier: 1.4, weight_modifier: 1.5 },   // Trendli piyasada çok güçlü
                        'ÖLÜM': { risk_modifier: 1.2, weight_modifier: 1.1 }     // Çöküşte güçlü
                    }
                },
                
                raphael: {
                    name: 'Raphael',
                    role: 'healing',
                    displayName: 'Raphael',
                    archetype: 'Şifa, Denge',
                    color: 'var(--raphael-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'İNANÇLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.4,
                        mean_reversion_bias: 0.8,
                        information_sensitivity: 0.5,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranışı (Behavior Rules)
                    strategies: ['StatArbitrageStrategy', 'LiquidityGapStrategy', 'OverboughtOversoldStrategy'],
                    primaryDataSources: ['Correlations', 'Spreads', 'Order Flow'],
                    
                    // ABM - Çevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.9, weight_modifier: 1.0 },  // Yatay piyasada normal
                        'SALGIN': { risk_modifier: 1.3, weight_modifier: 1.4 },  // Dalgalı piyasada çok güçlü
                        'SAVAŞ': { risk_modifier: 0.5, weight_modifier: 0.4 },   // Trendli piyasada zayıf
                        'ÖLÜM': { risk_modifier: 0.7, weight_modifier: 0.9 }     // Çöküşte orta
                    }
                },
                
                gabriel: {
                    name: 'Gabriel',
                    role: 'communication',
                    displayName: 'Gabriel',
                    archetype: 'İletişim, Bilgi',
                    color: 'var(--gabriel-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'İNANÇLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.6,
                        information_sensitivity: 0.9,
                        social_influence: 0.7,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranışı (Behavior Rules)
                    strategies: ['SmartMoneyStrategy', 'VolumeProfileStrategy', 'SentimentAnalysisStrategy'],
                    primaryDataSources: ['Volume', 'News Flow', 'Social Media Data'],
                    
                    // ABM - Çevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.8, weight_modifier: 0.7 },  // Yatay piyasada orta
                        'SALGIN': { risk_modifier: 0.7, weight_modifier: 0.8 },  // Dalgalı piyasada orta
                        'SAVAŞ': { risk_modifier: 0.9, weight_modifier: 1.0 },   // Trendli piyasada normal
                        'ÖLÜM': { risk_modifier: 1.3, weight_modifier: 1.5 }     // Çöküşte çok güçlü (haberler önemli)
                    }
                },
                
                michael: {
                    name: 'Michael',
                    role: 'warfare',
                    displayName: 'Michael',
                    archetype: 'Savaş, Güç',
                    color: 'var(--michael-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'İNANÇLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.9,
                        aggression_level: 0.8,
                        opportunistic_bias: 0.7,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranışı (Behavior Rules)
                    strategies: ['AggressiveCandleStrategy', 'LiquidationCascadeStrategy', 'VolatilityBreakoutStrategy'],
                    primaryDataSources: ['Candle Patterns', 'Open Interest', 'Liquidation Data'],
                    
                    // ABM - Çevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.4, weight_modifier: 0.3 },  // Yatay piyasada çok zayıf
                        'SALGIN': { risk_modifier: 0.6, weight_modifier: 0.7 },  // Dalgalı piyasada orta
                        'SAVAŞ': { risk_modifier: 1.3, weight_modifier: 1.2 },   // Trendli piyasada güçlü
                        'ÖLÜM': { risk_modifier: 1.5, weight_modifier: 1.6 }     // Çöküşte çok güçlü
                    }
                }
            };
            
            // Yetenekler ve bekleme süreleri
            this.abilities = {
                revelation: { cooldown: 45000, lastUsed: 0, description: 'Metatron\'un öngörüsü' },
                valor: { cooldown: 30000, lastUsed: 0, description: 'Uriel\'in cesareti' },
                restoration: { cooldown: 35000, lastUsed: 0, description: 'Raphael\'in iyileşmesi' },
                communication: { cooldown: 35000, lastUsed: 0, description: 'Gabriel\'in bilgi analizi ve sosyal medya taraması' },
                warfare: { cooldown: 25000, lastUsed: 0, description: 'Michael\'in agresif saldırı analizi ve likidite avı' }
            };
            
            // Sistem durum değişkenleri
            this.system = {
                initialized: false,
                currentRegime: 'NORMAL',
                collectiveState: 'Dengeli',
                confidenceThreshold: 65,
                lastUpdateTime: Date.now(),
                decayRate: 0.05, // Saniyede %0.05 güç azalması
                usageHistory: [],
                version: '3.5'
            };
            
            // Sistemi başlat
            this.init();
        }
        
        async init() {
            if (this.system.initialized) return;
            
            try {
                // Kaydedilmiş verileri yükle
                await this.loadState();
                
                // UI elemanlarını bul ve olayları bağla
                this.bindUI();
                
                // UI'ı güncelle
                this.updateUI();
                
                // Düzenli güncelleme için zamanlayıcı başlat
                this.startUpdateLoop();
                
                this.system.initialized = true;
                console.log('Panteon Sistemi başlatıldı (v' + this.system.version + ')');
            } catch (error) {
                console.error('Panteon Sistemi başlatılamadı:', error);
            }
        }

        async loadState() {
            // Placeholder: Load state from IndexedDB or localStorage
            // For now, use default values
            console.log("Loading Pantheon state...");
            // Example:
            // const savedState = await PanteonDBManager.instance.getPanteonState();
            // Object.assign(this.ambassadors.Metatron.state, savedState.ambassadors.Metatron);
        }

        bindUI() {
            // Toggle button
            const toggleBtn = document.querySelector('#pantheon-ui .pantheon-toggle-btn');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => this.toggleContent());
            }

            // Close button
            const closeBtn = document.querySelector('#pantheon-ui .pantheon-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    const pantheonUI = document.getElementById('pantheon-ui');
                    if (pantheonUI) {
                        pantheonUI.classList.remove('active');
                        pantheonUI.style.transform = 'translateX(-100%)';
                        localStorage.setItem('pantheonUIVisible', 'false');
                    }
                });
            }

            // Ability buttons
            Object.keys(this.abilities).forEach(abilityId => {
                const abilityEl = document.getElementById(`ability-${abilityId}`);
                if (abilityEl) {
                    abilityEl.addEventListener('click', () => this.activateAbility(abilityId));
                }
            });
        }

        toggleContent() {
            const content = document.querySelector('#pantheon-ui .pantheon-content');
            const toggleBtn = document.querySelector('#pantheon-ui .pantheon-toggle-btn');
            if (content && toggleBtn) {
                const isVisible = content.style.maxHeight !== '0px' && content.style.maxHeight !== '';
                content.style.maxHeight = isVisible ? '0px' : content.scrollHeight + 'px';
                content.style.opacity = isVisible ? '0' : '1';
                toggleBtn.textContent = isVisible ? '▼' : '▲';
            }
        }

        awardPowerForSignal(signal) {
            const powerIncrease = signal.score * 2; // Example: stronger signals give more power
            // Distribute power based on signal type or contributing strategies
            if (signal.direction === 'buy') {
                this.increasePower('uriel', powerIncrease * 0.7); // Courage for bullish signals
                this.increasePower('michael', powerIncrease * 0.3); // Warfare for aggressive buys
            } else {
                this.increasePower('metatron', powerIncrease * 0.7); // Wisdom for cautious sells
                this.increasePower('gabriel', powerIncrease * 0.3); // Communication for market insight sells
            }
            // All get a little bit for overall activity
            this.increasePower('raphael', powerIncrease * 0.1);
        }
        
        loadPowers() {
            // Placeholder: Load powers from persistent storage
        }
        
        savePowers() {
            // Placeholder: Save powers to persistent storage
        }
        
        increasePower(ambassadorName, amount = 1) {
            const ambassador = this.ambassadors[ambassadorName];
            if (ambassador) {
                ambassador.state.power = Math.min(100, ambassador.state.power + amount);
                this.updateUI();
                this.checkSpecialAbilities(ambassadorName);
                if (window.app && window.app.effectsManager) {
                    window.app.effectsManager.createExplosionEffect(
                        Math.random() * window.innerWidth,
                        Math.random() * window.innerHeight,
                        ambassador.color,
                        amount * 2
                    );
                }
            }
        }
        
        checkSpecialAbilities(ambassadorName) {
            const ambassador = this.ambassadors[ambassadorName];
            if (ambassador && ambassador.state.power >= 100) {
                this.triggerAmbassadorSpecialAbility(ambassadorName);
                ambassador.state.power = 0; // Reset power after ability use
                this.updateUI();
            }
        }
        
        triggerAmbassadorSpecialAbility(ambassadorName) {
            switch (ambassadorName) {
                case 'metatron': this.activateRevelation(); break;
                case 'uriel': this.activateValor(); break;
                case 'raphael': this.activateRestoration(); break;
                case 'gabriel': this.activateCommunication(); break;
                case 'michael': this.activateWarfare(); break;
            }
            if (window.app) {
                window.app.showNotification(`${ambassadorName.toUpperCase()}'ın özel yeteneği aktive edildi!`, 'success');
            }
        }
        
        activateRevelation() {
            if (window.app) {
                window.app.showNotification('Metatron\'un Vahyi: Stratejilerin doğruluk oranı geçici olarak arttı!', 'info');
                // Implement actual effect, e.g., temporarily boost strategy weights
                if (window.app.effectsManager) {
                    window.app.effectsManager.createMatrixEffect();
                }
            }
        }
        
        activateValor() {
            if (window.app) {
                window.app.showNotification('Uriel\'in Cesareti: Risk toleransı geçici olarak artırıldı!', 'warning');
                // Implement actual effect, e.g., temporarily increase risk appetite
                if (window.app.combatModeActive) {
                    window.app.showNotification('Savaş Modu\'nda ek Cesaret bonusu!', 'success');
                }
            }
        }
        
        activateRestoration() {
            if (window.app) {
                window.app.showNotification('Raphael\'in Şifası: Kayıplar telafi ediliyor ve stratejiler iyileştiriliyor!', 'success');
                // Implement actual effect, e.g., reduce shadowban duration, boost recovery of underperforming strategies
            }
        }

        activateCommunication() {
            if (window.app) {
                window.app.showNotification('Gabriel\'in İletişimi: Veri akışı optimize edildi, sinyal kalitesi arttırıldı!', 'info');
                // Implement actual effect, e.g., temporarily boost data processing speed or filter noise
            }
        }

        activateWarfare() {
            if (window.app) {
                window.app.showNotification('Michael\'in Savaşı: Düşman pozisyonları tespit edildi! Karşı hamle yapılıyor!', 'danger');
                // Implement actual effect, e.g., trigger a high-risk, high-reward signal or identify market manipulation
            }
        }
        
        activateAbility(abilityId) {
            const ability = this.abilities[abilityId];
            if (!ability) return;
            
            const now = Date.now();
            const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
            
            if (cooldownLeft > 0) {
                if (window.app) {
                    window.app.showNotification(`Bekleyin: ${(cooldownLeft/1000).toFixed(1)} saniye kaldı`, 'warning');
                }
                return;
            }
            
            // Yeteneği etkinleştir
            ability.lastUsed = now;
            this.startCooldown(abilityId, ability.cooldown);
            
            // Yeteneğe özel işlemler
            switch(abilityId) {
                case 'revelation': this.activateRevelation(); break;
                case 'valor': this.activateValor(); break;
                case 'restoration': this.activateRestoration(); break;
                case 'communication': this.activateCommunication(); break;
                case 'warfare': this.activateWarfare(); break;
            }
        }
        
        startCooldown(abilityId, duration) {
            const abilityEl = document.getElementById(`ability-${abilityId}`);
            if (!abilityEl) return;
            
            const cooldownEl = abilityEl.querySelector('.ability-cooldown');
            const statusEl = abilityEl.querySelector('.ability-status');
            
            abilityEl.classList.add('on-cooldown');
            if (cooldownEl) {
                cooldownEl.style.transition = `transform ${duration}ms linear`;
                cooldownEl.style.transform = 'scaleX(0)';
            }
            
            let remaining = duration;
            const timerInterval = setInterval(() => {
                remaining -= 1000;
                if (statusEl) statusEl.textContent = `${Math.ceil(remaining / 1000)}s`;
                if (remaining <= 0) {
                    clearInterval(timerInterval);
                    abilityEl.classList.remove('on-cooldown');
                    if (statusEl) statusEl.textContent = 'Ready';
                    if (cooldownEl) {
                        cooldownEl.style.transition = 'none';
                        cooldownEl.style.transform = 'scaleX(1)';
                    }
                }
            }, 1000);
        }
        
        startUpdateLoop() {
            setInterval(() => this.updateUI(), 1000);
            setInterval(() => this.decayPower(), 5000); // Decay every 5 seconds
        }

        decayPower() {
            const now = Date.now();
            const deltaTime = (now - this.system.lastUpdateTime) / 1000;
            this.system.lastUpdateTime = now;

            Object.values(this.ambassadors).forEach(ambassador => {
                if (ambassador.state.power > 0) {
                    ambassador.state.power = Math.max(0, ambassador.state.power - this.system.decayRate * deltaTime);
                }
            });
            this.updateUI();
        }
        
        updateUI() {
            Object.entries(this.ambassadors).forEach(([key, ambassador]) => {
                const rootEl = document.querySelector(`.ambassador[data-name="${key}"]`);
                if (!rootEl) return;

                const repEl = rootEl.querySelector('.reputation-score');
                if (repEl) repEl.textContent = ambassador.state.reputation.toFixed(1);

                const modeEl = rootEl.querySelector('.ambassador-mode');
                if (modeEl) modeEl.textContent = ambassador.state.mode;

                const confidenceEl = rootEl.querySelector('.confidence-level');
                if (confidenceEl) {
                    confidenceEl.style.width = `${ambassador.state.confidence}%`;
                    confidenceEl.textContent = `${ambassador.state.confidence}%`;
                }

                const powerEl = rootEl.querySelector('.power-level');
                if (powerEl) powerEl.style.width = `${ambassador.state.power}%`;
            });

            // Update ability states (cooldowns)
            Object.keys(this.abilities).forEach(abilityId => {
                const abilityEl = document.getElementById(`ability-${abilityId}`);
                if (!abilityEl) return;
                const ability = this.abilities[abilityId];
                const now = Date.now();
                const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
                const statusEl = abilityEl.querySelector('.ability-status');
                const cooldownBar = abilityEl.querySelector('.ability-cooldown');

                if (cooldownLeft > 0) {
                    abilityEl.classList.add('on-cooldown');
                    if (statusEl) statusEl.textContent = `${Math.ceil(cooldownLeft / 1000)}s`;
                    if (cooldownBar) {
                        cooldownBar.style.transform = `scaleX(${1 - cooldownLeft / ability.cooldown})`;
                    }
                } else {
                    abilityEl.classList.remove('on-cooldown');
                    if (statusEl) statusEl.textContent = 'Ready';
                    if (cooldownBar) {
                        cooldownBar.style.transition = 'none'; // Reset transition for instant full bar
                        cooldownBar.style.transform = 'scaleX(1)';
                    }
                }
            });
        }
    }

    // Veritabanı yöneticisi sınıfı
    class DBManager {
        constructor() {
            this.dbName = 'ultimateTrader';
            this.dbVersion = 1;
            this.db = null;
            this.ready = false;
            this.initPromise = null;
        }
        
        init() {
            if (this.initPromise) return this.initPromise;
            
            this.initPromise = new Promise((resolve, reject) => {
                // IndexedDB'yi desteklemiyor mu?
                if (!window.indexedDB) {
                    console.error('Bu tarayıcı IndexedDB desteklemiyor!');
                    reject(new Error('IndexedDB desteklenmiyor'));
                    return;
                }
                
                const request = indexedDB.open(this.dbName, this.dbVersion);
                
                request.onerror = (event) => {
                    console.error('Veritabanı açılırken hata oluştu:', event);
                    reject(event.target.error);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Depolanacak objeler için object stores oluştur
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'id' });
                    }
                    
                    if (!db.objectStoreNames.contains('signals')) {
                        db.createObjectStore('signals', { keyPath: 'id', autoIncrement: true });
                    }
                    
                    if (!db.objectStoreNames.contains('stats')) {
                        db.createObjectStore('stats', { keyPath: 'id' });
                    }
                    
                    if (!db.objectStoreNames.contains('panteon')) {
                        db.createObjectStore('panteon', { keyPath: 'id' });
                    }
                    
                    console.log('Veritabanı şeması güncellendi');
                };
                
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    this.ready = true;
                    console.log('Veritabanı başarıyla açıldı');
                    resolve(this.db);
                };
            });
            
            return this.initPromise;
        }
        
        async get(storeName, key) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                
                request.onerror = (event) => {
                    console.error(`Veri getirme hatası (${storeName}):`, event);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve(request.result);
                };
            });
        }
        
        async put(storeName, data) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                
                request.onerror = (event) => {
                    console.error(`Veri kaydetme hatası (${storeName}):`, event);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve(request.result);
                };
            });
        }
        
        async delete(storeName, key) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);
                
                request.onsuccess = () => {
                    resolve();
                };
                
                request.onerror = (error) => {
                    reject(error);
                };
            });
        }
        
        async getAll(storeName) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                
                request.onerror = (event) => {
                    console.error(`Tüm verileri getirme hatası (${storeName}):`, event);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve(request.result);
                };
            });
        }
        
        async clear(storeName) {
            await this.init();
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();
                request.onerror = (event) => {
                    console.error(`Depo temizleme hatası (${storeName}):`, event);
                    reject(event.target.error);
                };
                request.onsuccess = (event) => {
                    resolve();
                };
            });
        }
    }
    
    // TheOracle sınıfı - Piyasadaki Mahşerin Atlıları durumlarını analiz eder
    /**
     * TheOracle - Piyasa rejimi tespit motoru
     * Mahşerin Dört Atlısını (KITLIK, SALGIN, SAVAŞ, ÖLÜM) metriklerle tespit eder
     * ve diğer sistem bileşenlerine piyasa koşullarını bildirir
     */
    class TheOracle {
        constructor(app) {
            this.app = app;
            this.isInitialized = false;
            
            // Piyasa Rejimleri
            this.marketRegimes = {
                NORMAL: "NORMAL",   // Normal piyasa koşulları
                KITLIK: "KITLIK",   // Düşük volatilite, düşük hacim (Yatay/Konsolidasyon)
                SALGIN: "SALGIN",   // Yüksek volatilite, yönsüz (Dalgalı/Ortalamaya Dönen)
                SAVAS: "SAVAŞ",     // Yüksek volatilite, yüksek hacim, yönlü (Güçlü Trend)
                OLUM: "ÖLÜM"        // Ekstrem olay, yapısal kırılma (Çöküş/Ani Yükseliş)
            };
            
            // Aktif piyasa rejimi (varsayılan: normal)
            this.currentRegime = this.marketRegimes.NORMAL;
            this.previousRegime = this.marketRegimes.NORMAL;
            
            // Legacy horsemen desteği
            this.horsemen = {
                war: false,       // Savaş (yüksek volatilite)
                famine: false,    // Kıtlık (düşük likidite)
                pestilence: false, // Veba (ani trendler)
                death: false      // Ölüm (ciddi düşüş)
            };
            
            // Analiz pencereleri (periyot sayısı)
            this.volatilityWindow = 14;     // ATR hesaplama penceresi
            this.volumeWindow = 20;         // Hacim normalizasyon penceresi
            this.adxWindow = 14;           // ADX hesaplama penceresi
            this.maWindow = 50;            // Trend analiz penceresi
            
            // Rejim eşikleri
            this.thresholds = {
                // KITLIK için eşikler
                lowVolatility: 0.7,        // ATR ortalamaya göre % olarak (< %70 = düşük volatilite)
                lowVolume: 0.8,            // Hacim ortalamaya göre % olarak (< %80 = düşük hacim)
                
                // SALGIN için eşikler
                highVolatility: 1.5,       // ATR ortalamaya göre % olarak (> %150 = yüksek volatilite)
                lowAdx: 20,                // Düşük ADX değeri (< 20 = zayıf trend)
                
                // SAVAŞ için eşikler
                warVolatility: 1.3,        // ATR ortalamaya göre % olarak (> %130)
                highAdx: 25,               // Yüksek ADX değeri (> 25 = güçlü trend)
                highVolume: 1.3,           // Hacim ortalamaya göre % olarak (> %130)
                
                // ÖLÜM için eşikler
                extremeVolatility: 2.5,    // ATR ortalamaya göre % olarak (> %250 = ekstrem volatilite)
                crashThreshold: -5.0,      // Tek periyotta % düşüş (< -%5 = çöküş)
                spikeThreshold: 5.0        // Tek periyotta % yükseliş (> %5 = ani yükseliş)
            };
            
            // Metrik depoları
            this.metrics = {
                atr: [],              // ATR değerleri
                atrAvg: 0,            // Ortalama ATR
                volume: [],           // Hacim değerleri
                volumeAvg: 0,         // Ortalama hacim
                adx: 0,               // En son ADX değeri
                priceChange: 0,       // Son periyottaki % fiyat değişimi
                maSlope: 0            // Hareketli ortalama eğimi
            };
            
            // Zaman içinde takip için
            this.regimeHistory = [];  // Rejim değişikliklerini takip eder
            this.lastUpdate = Date.now();
            this.updateFrequency = 60000; // ms cinsinden güncelleme sıklığı (1 dakika)
            
            this.averageVolume = 0;
            this.averageRange = 0;
            this.trendStrength = 0;
            
            this.updateInterval = 60000; // 1 dakika
            this.lastUpdate = 0;
        }
        
        async init() {
            if (this.isInitialized) return;
            
            try {
                // İlk metrikleri hesapla
                await this.calculateMetrics();
                
                // İlk rejim analizi yap
                this.detectMarketRegime();
                
                // Düzenli güncelleme ayarla
                this.updateTimer = setInterval(() => this.update(), this.updateFrequency);
                
                this.isInitialized = true;
                console.log('TheOracle initialized with market regime detection v2.0');
            } catch (error) {
                console.error('TheOracle initialization error:', error);
            }
        }
        
        async update() {
            try {
                const now = Date.now();
                const elapsed = now - this.lastUpdate;
                // Eğer son güncellemeden sonra yeterli zaman geçmediyse çık
                if (elapsed < this.updateFrequency * 0.9) return;
                this.lastUpdate = now;
                // Metrikleri güncelle
                await this.calculateMetrics();
                // Önceki rejimi hatırla
                this.previousRegime = this.currentRegime;
                // Piyasa rejimini tespit et
                this.detectMarketRegime();
                // Eğer rejim değiştiyse bildir
                if (this.previousRegime !== this.currentRegime) {
                    this.notifyRegimeChange();
                }
                // Legacy horsemen'i güncelle
                this.updateHorsemenFromRegime();
            } catch (error) {
                console.error('TheOracle update error:', error);
            }
        }

        async calculateMetrics() {
            // Placeholder: Implement actual metric calculations
            // For now, use app's indicators
            if (this.app.indicators && this.app.marketData) {
                this.metrics.atr = [this.app.indicators.atr]; // Simplified
                this.metrics.atrAvg = this.app.indicators.atr;
                this.metrics.volume = [this.app.marketData.volume]; // Simplified
                this.metrics.volumeAvg = this.app.marketData.volumeAvg;
                this.metrics.adx = this.app.indicators.adx?.adx || 0;
                // Add price change and MA slope if available
            }
            return true;
        }

        updateHorsemenFromRegime() {
            Object.keys(this.horsemen).forEach(key => this.horsemen[key] = false); // Reset all

            switch (this.currentRegime) {
                case 'KITLIK': this.horsemen.famine = true; break;
                case 'SALGIN': this.horsemen.pestilence = true; break;
                case 'SAVAŞ': this.horsemen.war = true; break;
                case 'ÖLÜM': this.horsemen.death = true; break;
            }
        }
        
        // Four Horsemen Piyasa Rejim Tespiti
        detectMarketRegime() {
            if (!this.app || !this.app.candles || this.app.candles.length < 20) {
                this.currentRegime = 'NORMAL';
                return;
            }
            
            const candles = this.app.candles.slice(-20);
            const prices = candles.map(c => c.close);
            const volumes = candles.map(c => c.volume);
            
            // Volatilite analizi
            const volatility = this.calculateVolatility(prices);
            const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            const recentVolume = volumes.slice(-5).reduce((a, b) => a + b, 0) / 5;
            
            // Trend analizi
            const trendStrength = this.calculateTrendStrength(prices);
            const priceChange = ((prices[prices.length - 1] - prices[0]) / prices[0]) * 100;
            
            // ATR ile volatilite ölçümü
            const atr = this.app.indicators?.atr || 0;
            const currentPrice = prices[prices.length - 1];
            const atrPercentage = atr / currentPrice * 100;
            
            // Four Horsemen Rejim Tespiti
            this.previousRegime = this.currentRegime;
            
            // ÖLÜM: Büyük düşüş ve yüksek volatilite
            if (priceChange < -5 && atrPercentage > 3) {
                this.currentRegime = 'ÖLÜM';
            }
            // SAVAŞ: Güçlü trend ve artan volatilite
            else if (Math.abs(trendStrength) > 0.7 && atrPercentage > 2) {
                this.currentRegime = 'SAVAŞ';
            }
            // SALGIN: Yüksek volatilite ama zayıf trend
            else if (atrPercentage > 2 && Math.abs(trendStrength) < 0.3) {
                this.currentRegime = 'SALGIN';
            }
            // KITLIK: Düşük volatilite ve hacim
            else if (atrPercentage < 1 && recentVolume < avgVolume * 0.7) {
                this.currentRegime = 'KITLIK';
            }
            else {
                this.currentRegime = 'NORMAL';
            }
            
            // Panteon sistemine rejim güncellemesi gönder
            if (window.pantheonSystem && window.pantheonSystem.system) {
                window.pantheonSystem.system.currentRegime = this.currentRegime;
            }
            
            console.log(`Market Regime: ${this.currentRegime} (Vol: ${atrPercentage.toFixed(2)}%, Trend: ${trendStrength.toFixed(2)}, Price Change: ${priceChange.toFixed(2)}%)`);
        }
        
        notifyRegimeChange() {
            if (this.previousRegime === this.currentRegime) return;
            
            const regimeNames = {
                'KITLIK': 'Kıtlık Atlısı - Düşük likidite ve volatilite',
                'SALGIN': 'Salgın Atlısı - Kaotik ve dalgalı piyasa',
                'SAVAŞ': 'Savaş Atlısı - Güçlü trend ve yüksek volatilite',
                'ÖLÜM': 'Ölüm Atlısı - Büyük düşüş ve ekstrem volatilite',
                'NORMAL': 'Normal Piyasa Durumu'
            };
            
            const message = `🏇 Piyasa Rejimi Değişti: ${regimeNames[this.currentRegime]}`;
            
            if (this.app.showNotification) {
                this.app.showNotification(message, 'divine');
            }
            
            if (this.app.speak) {
                this.app.speak(`Piyasa rejimi değişti. ${regimeNames[this.currentRegime]}`);
            }
        }
        
        calculateBaseMetrics() {
            if (!this.app.candles || this.app.candles.length < 20) return;
            
            const candles = this.app.candles.slice(-20);
            
            // Ortalama hacim hesapla
            let totalVolume = 0;
            candles.forEach(candle => {
                totalVolume += candle.volume;
            });
            this.averageVolume = totalVolume / candles.length;
            
            // Ortalama fiyat aralığı hesapla
            let totalRange = 0;
            candles.forEach(candle => {
                const range = candle.high - candle.low;
                totalRange += range;
            });
            this.averageRange = totalRange / candles.length;
            
            // Trend gücü hesapla (basit lineer regresyon eğimi)
            const prices = candles.map(c => c.close);
            this.trendStrength = this.calculateTrendStrength(prices);
        }
        
        calculateTrendStrength(prices) {
            const n = prices.length;
            let sumX = 0;
            let sumY = 0;
            let sumXY = 0;
            let sumX2 = 0;
            
            for (let i = 0; i < n; i++) {
                sumX += i;
                sumY += prices[i];
                sumXY += i * prices[i];
                sumX2 += i * i;
            }
            
            // Lineer regresyon eğimi hesapla
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            
            // Normalize edilmiş eğim (yüzde olarak)
            const normalizedSlope = (slope / prices[0]) * 100;
            
            return normalizedSlope;
        }
        
        updateHorsemen() {
            if (!this.app.candles || this.app.candles.length < 20) return;
            
            const candles = this.app.candles;
            const recent = candles.slice(-5);
            const current = candles[candles.length - 1];
            const previous = candles[candles.length - 2];
            
            this.calculateBaseMetrics();
            
            // Reset statuses
            Object.keys(this.horsemen).forEach(key => {
                this.horsemen[key] = false;
            });
            
            // Savaş: Yüksek volatilite
            const recentVolatility = this.calculateVolatility(recent.map(c => c.close));
            if (recentVolatility > this.volatilityThreshold) {
                this.horsemen.war = true;
            }
            
            // Kıtlık: Düşük likidite
            const currentVolume = current.volume;
            if (currentVolume < this.averageVolume * this.liquidityThreshold) {
                this.horsemen.famine = true;
            }
            
            // Veba: Ani trendler
            const recentTrendStrength = this.calculateTrendStrength(recent.map(c => c.close));
            if (Math.abs(recentTrendStrength) > Math.abs(this.trendStrength) * this.trendThreshold) {
                this.horsemen.pestilence = true;
            }
            
            // Ölüm: Ciddi düşüş
            const priceChange = ((current.close - previous.close) / previous.close) * 100;
            if (priceChange < this.dropThreshold) {
                this.horsemen.death = true;
            }
            
            this.lastUpdate = Date.now();
            
            // UI güncelle
            this.updateUI();
            
            // Eğer atlılardan biri aktifse, bildirim gönder
            const activeHorsemen = Object.entries(this.horsemen).filter(([_, active]) => active);
            
            if (activeHorsemen.length > 0) {
                const names = {
                    war: "Savaş",
                    famine: "Kıtlık",
                    pestilence: "Veba",
                    death: "Ölüm"
                };
                
                const message = `Mahşerin ${activeHorsemen.length > 1 ? "Atlıları" : "Atlısı"} görüldü: ${activeHorsemen.map(([key, _]) => names[key]).join(", ")}`;
                
                if (this.app.notificationManager) {
                    this.app.notificationManager.notify(message, 'warning', 3);
                }
            }
        }
        
        calculateVolatility(prices) {
            const n = prices.length;
            if (n < 2) return 0;
            
            // Ortalama hesapla
            const avg = prices.reduce((sum, price) => sum + price, 0) / n;
            
            // Varyans hesapla
            const variance = prices.reduce((sum, price) => {
                return sum + Math.pow(price - avg, 2);
            }, 0) / (n - 1);
            
            // Standart sapma
            const stdDev = Math.sqrt(variance);
            
            // Fiyat yüzdesi olarak volatilite
            return (stdDev / avg) * 100;
        }
        
        updateUI() {
            // This is handled by the PanteonHorsemenIntegration class
        }
        
        getHorsemanName(key) {
            const names = {
                war: "Savaş",
                famine: "Kıtlık",
                pestilence: "Veba",
                death: "Ölüm"
            };
            return names[key] || key;
        }
        
        getActiveHorsemen() {
            return Object.entries(this.horsemen)
                .filter(([_, active]) => active)
                .map(([key, _]) => key);
        }
        
        isAnyHorsemanActive() {
            return Object.values(this.horsemen).some(active => active);
        }
    }

    // MultiTimeframeManager sınıfı - Çoklu zaman dilimi analizi
    class MultiTimeframeManager {
        constructor(app) {
            this.app = app;
            this.timeframes = ['1m', '5m', '15m', '1h', '4h', '1d'];
            this.data = {}; // Her zaman dilimi için ayrı veri
            this.signals = {}; // Her zaman dilimi için ayrı sinyal
            this.activeTimeframe = '15m'; // Varsayılan zaman dilimi
            this.isInitialized = false;
            this.updateIntervals = {
                '1m': 60000,
                '5m': 300000,
                '15m': 900000,
                '1h': 3600000,
                '4h': 14400000,
                '1d': 86400000
            };
            this.updateTimers = {};
            this.accuracyFactor = 1.0; // Ritual effect
        }
        
        async init() {
            if (this.isInitialized) return;
            
            try {
                // Arayüz elementlerini oluştur
                this.createTimeframeTabs();
                
                // Her zaman dilimi için veri yükle
                for (const tf of this.timeframes) {
                    await this.loadTimeframeData(tf);
                }
                
                // Güncelleme zamanlayıcılarını ayarla
                this.setupUpdateTimers();
                
                this.isInitialized = true;
                console.log('MultiTimeframeManager başlatıldı');
            } catch (error) {
                console.error('MultiTimeframeManager başlatma hatası:', error);
            }
        }
        
        // initialize metodu için uyumluluk katmanı
        async initialize(symbol, timeframes) {
            this.timeframes = timeframes || this.timeframes;
            // Sembol ayarını güncelle
            if (symbol && this.app) {
                this.app.currentSymbol = symbol;
            }
            // init metodunu çağır
            return this.init();
        }
        
        createTimeframeTabs() {
            const controlsContainer = document.querySelector('.controls');
            if (!controlsContainer) return;
            
            // Sekmeleri içerecek konteyner
            const tabsContainer = document.createElement('div');
            tabsContainer.className = 'tabs-container';
            tabsContainer.style.marginLeft = '10px';
            
            // Zaman dilimlerini sırayla sekmelere ekle
            this.timeframes.forEach(tf => {
                const tab = document.createElement('div');
                tab.className = 'tab';
                tab.dataset.timeframe = tf;
                tab.textContent = tf;
                if (tf === this.activeTimeframe) {
                    tab.classList.add('active');
                }
                
                tab.addEventListener('click', () => this.switchTimeframe(tf));
                
                tabsContainer.appendChild(tab);
            });
            
            controlsContainer.appendChild(tabsContainer);
        }
        
        // Binance veya başka bir kaynaktan API endpoint oluşturur
        buildApiEndpoint(timeframe) {
            const symbol = this.app.symbol || 'BTCUSDT';
            const limit = 500;
            
            // Zaman dilimini Binance formatına çevir
            let interval;
            switch (timeframe) {
                case '1m': interval = '1m'; break;
                case '5m': interval = '5m'; break;
                case '15m': interval = '15m'; break;
                case '1h': interval = '1h'; break;
                case '4h': interval = '4h'; break;
                case '1d': interval = '1d'; break;
                default: interval = '15m';
            }
            
            // Demo veri kullanıyoruz - gerçek API'ye bağlanmak yerine statik veriyi kullan
            return `https://api.example.com/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        }
        
        async loadTimeframeData(timeframe) {
            try {
                // Endpoint oluştur - app'e bağlı olmadan kendi metodumuzu kullanıyoruz
                const endpoint = this.buildApiEndpoint(timeframe);
                
                // Demo veri kullanıyoruz - gerçek API'ye bağlanmak yerine
                // Eğer app nesnesi içinde candles verisi varsa onu kullanalım
                if (this.app && this.app.candles && this.app.candles.length > 0) {
                    this.data[timeframe] = [...this.app.candles]; // var olan verileri kullan
                    
                    // Sinyalleri hesapla
                    this.generateSignals(timeframe);
                    
                    console.log(`${timeframe} verileri yüklendi (yerel veri)`);
                    
                    // Aktif zaman dilimi ise, ana uygulamada kullan
                    if (timeframe === this.activeTimeframe) {
                        this.applyTimeframeData(timeframe);
                    }
                    
                    return this.data[timeframe];
                }
                
                // Gerçek API'ye bağlanmayı simüle edelim
                console.log(`${timeframe} için demo veri kullanılıyor`);
                
                // Demo veri oluştur
                const demoData = this.generateDemoData(timeframe, 500);
                this.data[timeframe] = demoData;
                
                // Sinyalleri hesapla
                this.generateSignals(timeframe);
                
                console.log(`${timeframe} verileri yüklendi (demo veri)`);
                
                // Aktif zaman dilimi ise, ana uygulamada kullan
                if (timeframe === this.activeTimeframe) {
                    this.applyTimeframeData(timeframe);
                }
                
                return demoData;
            } catch (error) {
                console.log(`${timeframe} verileri yüklenirken hata:`, error);
                return [];
            }
        }
        
        // Demo veri oluşturma metodu
        generateDemoData(timeframe, count = 500) {
            const now = new Date().getTime();
            const data = [];
            
            // Zaman aralığını belirle (milisaniye cinsinden)
            let interval;
            switch (timeframe) {
                case '1m': interval = 60 * 1000; break;
                case '5m': interval = 5 * 60 * 1000; break;
                case '15m': interval = 15 * 60 * 1000; break;
                case '1h': interval = 60 * 60 * 1000; break;
                case '4h': interval = 4 * 60 * 60 * 1000; break;
                case '1d': interval = 24 * 60 * 60 * 1000; break;
                default: interval = 15 * 60 * 1000;
            }
            
            // Son fiyat
            let lastPrice = 40000 + Math.random() * 10000;
            
            // Geçmiş verileri oluştur
            for (let i = count - 1; i >= 0; i--) {
                const time = now - (i * interval);
                
                // Fiyat değişimi (yüzde -1 ile +1 arası)
                const change = (Math.random() * 2 - 1) * 0.01;
                lastPrice = lastPrice * (1 + change);
                
                // Açılış, yüksek, düşük ve kapanış fiyatları
                const open = lastPrice;
                const high = open * (1 + Math.random() * 0.005);
                const low = open * (1 - Math.random() * 0.005);
                const close = (open + high + low) / 3; // Ortalama bir kapanış
                
                // Hacim
                const volume = Math.random() * 100 + 50;
                
                data.push({
                    time: time,
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: volume
                });
            }
            
            return data;
        }
        
        // Sinyal oluşturma metodu - zaman dilimine özgü sinyaller üretir
        generateSignals(timeframe) {
            if (!this.signals[timeframe]) {
                this.signals[timeframe] = [];
            }
            
            if (!this.data[timeframe] || this.data[timeframe].length === 0) {
                return; // Veri yoksa sinyal üretme
            }
            
            // İlgili zaman dilimi için stratejileri kullanarak sinyal üret
            const candles = this.data[timeframe];
            if (this.app.strategies) {
                // Strateji sınıflarını kullanarak sinyal üret
                for (const strategy of Object.values(this.app.strategies)) {
                    if (!strategy.isEnabled()) continue;
                    
                    const strategySignals = strategy.analyze(candles);
                    if (strategySignals && strategySignals.length > 0) {
                        this.signals[timeframe] = this.signals[timeframe].concat(strategySignals);
                    }
                }
            } else {
                // Basit örnek: Her 10 mumda bir sinyal üret
                for (let i = 10; i < candles.length; i += 10) {
                    const candle = candles[i];
                    
                    if (candle.close > candle.open) {
                        // Yükselen mum - alış sinyali
                        this.signals[timeframe].push({
                            time: candle.time,
                            type: 'buy',
                            price: candle.close,
                            reason: `${timeframe} zaman diliminde yükselen mum paterni`,
                            strength: 0.7
                        });
                    } else {
                        // Düşen mum - satış sinyali
                        this.signals[timeframe].push({
                            time: candle.time,
                            type: 'sell',
                            price: candle.close,
                            reason: `${timeframe} zaman diliminde düşen mum paterni`,
                            strength: 0.7
                        });
                    }
                }
            }
            
            // Sinyalleri sınırla
            if (this.signals[timeframe].length > 50) {
                this.signals[timeframe] = this.signals[timeframe].slice(-50);
            }
        }
        
        applyTimeframeData(timeframe) {
            if (!this.data[timeframe]) return;
            
            // Ana uygulama verilerini güncelle
            this.app.candles = this.data[timeframe];
            this.app.signals = this.signals[timeframe] || [];
            
            // Grafik ve sinyal gösterimini güncelle
            if (this.app.updateChart) this.app.updateChart();
            if (this.app.updateSignals) this.app.updateSignals();
        }
        
        switchTimeframe(timeframe) {
            if (!this.timeframes.includes(timeframe) || timeframe === this.activeTimeframe) return;
            
            // Sekme arayüzünü güncelle
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.timeframe === timeframe);
            });
            
            // Aktif zaman dilimini güncelle
            this.activeTimeframe = timeframe;
            
            // Veriyi uygula
            this.applyTimeframeData(timeframe);
            
            // Kullanıcıyı bilgilendir
            if (this.app.notificationManager) {
                this.app.notificationManager.notify(`Zaman dilimi ${timeframe} olarak değiştirildi`, 'info', 1);
            }
        }
        
        setupUpdateTimers() {
            // Her zaman dilimi için otomatik güncelleme ayarla
            for (const tf of this.timeframes) {
                const interval = this.updateIntervals[tf];
                
                if (interval) {
                    // Önceki zamanlayıcıyı temizle
                    if (this.updateTimers[tf]) {
                        clearInterval(this.updateTimers[tf]);
                    }
                    
                    // Yeni zamanlayıcı oluştur
                    this.updateTimers[tf] = setInterval(async () => {
                        console.log(`${tf} verileri güncelleniyor...`);
                        await this.loadTimeframeData(tf);
                        
                        if (tf === this.activeTimeframe) {
                            this.applyTimeframeData(tf);
                        }
                    }, interval);
                }
            }
        }
        
        destroy() {
            // Zamanlayıcıları temizle
            for (const timer of Object.values(this.updateTimers)) {
                clearInterval(timer);
            }
            
            // Veriyi temizle
            this.data = {};
            this.updateTimers = {};
            
            console.log('MultiTimeframeManager temizlendi');
        }
        
        // cleanup metodu destroy metodunun alias'ı olarak tanımlanıyor
        cleanup() {
            return this.destroy();
        }
    }

    // Confluence Engine - Farklı sinyallerin birleşimi
    // Strateji birleştirme motoru
    class ConfluenceEngine {
        constructor(app) {
            this.app = app;
            this.confluenceEnabled = true;
            this.minConfluenceScore = 3; // Minimum gerekli birleşim puanı
            this.weightedStrategies = {
                'rsi': 1,
                'macd': 1.2,
                'supertrend': 1.5,
                'bollinger': 1.2,
                'ichimoku': 1.3,
                'fractals': 0.7
            };
            this.confluenceMultiplier = 1.0; // Ritual effect
        }
        
        validateSignal(signal) {
            if (!this.confluenceEnabled) return true;
            
            const confluenceScore = this.calculateConfluenceScore(signal);
            return confluenceScore >= this.minConfluenceScore;
        }
        
        calculateConfluenceScore(signal) {
            if (!signal || !signal.type || !this.app.strategies) return 0;
            
            let score = 0;
            const direction = signal.type === 'buy' ? 1 : -1;
            
            // Tüm stratejilerden son sinyalleri al
            for (const [name, strategy] of Object.entries(this.app.strategies)) {
                if (!strategy.isEnabled()) continue;
                
                const latestSignal = strategy.getLastSignal();
                if (!latestSignal) continue;
                
                // Son sinyal ile aynı yönde mi?
                const signalDirection = latestSignal.type === 'buy' ? 1 : -1;
                
                // Aynı yönde ise, stratejinin ağırlığını skora ekle
                if (signalDirection === direction) {
                    const weight = this.weightedStrategies[name] || 1;
                    score += weight;
                }
            }
            
            // Zaman çerçevesi kontrolü (birden fazla zaman diliminde aynı sinyal varsa bonus)
            if (this.app.multiTimeframeManager && this.app.multiTimeframeManager.signals) {
                const mtfSignals = this.app.multiTimeframeManager.signals;
                let timeframeConfluence = 0;
                
                for (const [tf, signals] of Object.entries(mtfSignals)) {
                    if (tf === this.app.multiTimeframeManager.activeTimeframe) continue;
                    
                    // Son 3 sinyale bak
                    const recentSignals = signals.slice(-3);
                    for (const tfSignal of recentSignals) {
                        if (tfSignal.type === signal.type) {
                            // Farklı zaman diliminde aynı yönde sinyal
                            timeframeConfluence += 0.5;
                            break;
                        }
                    }
                }
                
                score += timeframeConfluence;
            }
            
            // TheOracle kontrolü - Mahşerin Atlıları durumları
            if (this.app.oracle && this.app.oracle.isAnyHorsemanActive()) {
                const activeHorsemen = this.app.oracle.getActiveHorsemen();
                
                // Ölüm atlısı aktifse ve alış sinyali ise, skoru düşür
                if (activeHorsemen.includes('death') && signal.type === 'buy') {
                    score -= 1;
                }
                
                // Savaş atlısı aktifse ve yüksek volatilite varsa, skoru düşür
                if (activeHorsemen.includes('war')) {
                    score -= 0.5;
                }
            }
            
            return Math.round((score * this.confluenceMultiplier) * 10) / 10; // Bir ondalık basamağa yuvarla
        }
        
        setMinConfluenceScore(score) {
            this.minConfluenceScore = score;
        }
        
        toggleConfluence(enabled) {
            this.confluenceEnabled = enabled;
        }
        
        setStrategyWeight(strategyName, weight) {
            if (this.weightedStrategies.hasOwnProperty(strategyName)) {
                this.weightedStrategies[strategyName] = weight;
            }
        }
        
        propose(strategy, direction, reason, score) {
            // Stratejilerden gelen sinyal önerilerini işle
            console.log(`[CONFLUENCE] ${strategy} stratejisinden ${direction} sinyali alındı: ${reason}`);
            
            // Burada sinyal işleme ve birleştirme mantığı eklenebilir
            // Şimdilik sadece log'lama ve temel işleme yapıyoruz
            const normalizedScore = score || 1.0;
            
            if (this.app && this.app.recordSignal) {
                this.app.recordSignal({
                    type: direction,
                    strategy: strategy,
                    reason: reason,
                    score: normalizedScore,
                    time: Date.now()
                });
            }
        }
    }

    // Sayfa yüklendiğinde çalışacak ana fonksiyon
    function initApp() {
        console.log('initApp başlatılıyor...');
        // Panteon UI için sürükleme özelliği ve mobil uyumluluğu
        const pantheonUI = document.getElementById('panteon-panel');
        if (pantheonUI) {
            let isDragging = false;
            let offsetX, offsetY;
            
            function startDrag(e) {
                isDragging = true;
                offsetX = e.clientX - pantheonUI.getBoundingClientRect().left;
                offsetY = e.clientY - pantheonUI.getBoundingClientRect().top;
                pantheonUI.style.cursor = 'grabbing';
                e.preventDefault();
            }
            
            function onDrag(e) {
                if (!isDragging) return;
                pantheonUI.style.left = (e.clientX - offsetX) + 'px';
                pantheonUI.style.top = (e.clientY - offsetY) + 'px';
            }
            
            function stopDrag() {
                isDragging = false;
                pantheonUI.style.cursor = 'grab';
                
                // Pozisyonu kaydet
                const rect = pantheonUI.getBoundingClientRect();
                localStorage.setItem('pantheonUIPosition', JSON.stringify({
                    left: rect.left,
                    top: rect.top
                }));
            }
            
            // Event listener'ları ekle
            pantheonUI.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('mouseleave', stopDrag);
            
            // Kayıtlı pozisyonu yükle (sadece mobil değilse)
            if (window.innerWidth > 768) {
                const savedPosition = localStorage.getItem('pantheonUIPosition');
                if (savedPosition) {
                    try {
                        const { left, top } = JSON.parse(savedPosition);
                        pantheonUI.style.left = `${left}px`;
                        pantheonUI.style.top = `${top}px`;
                    } catch (e) {
                        console.error('Pozisyon yüklenirken hata:', e);
                    }
                }
            }
        }
        
        // Dikey panel butonları için olayları ekle
        const notificationsBtn = document.getElementById('notifications-btn');
        const pantheonToggleBtn = document.getElementById('pantheon-toggle-btn');
        const energyToggleBtn = document.getElementById('energy-toggle-btn');
        const ritualToggleBtn = document.getElementById('ritual-toggle-btn');
        const quickSettingsBtn = document.getElementById('quick-settings-btn');
        const verticalStatsBtn = document.getElementById('vertical-stats-btn');
        const verticalLogBtn = document.getElementById('vertical-log-btn');
        const kehanetToggleBtn = document.getElementById('kehanet-toggle-btn');
        const osirisToggleBtn = document.getElementById('osiris-toggle-btn');
        
        // Bildirim paneli kontrolü ve Bildirimler Menüsü
        if(notificationsBtn) {
            const notificationsContainer = document.getElementById('notifications-container');
            
            // Bildirimler menüsü oluştur
            const notificationMenu = document.createElement('div');
            notificationMenu.className = 'notification-menu';
            notificationMenu.style.display = 'none';
            notificationMenu.style.position = 'fixed';
            notificationMenu.style.left = '75px';
            notificationMenu.style.top = '50%';
            notificationMenu.style.transform = 'translateY(-50%)';
            notificationMenu.style.background = 'var(--panel-bg)';
            notificationMenu.style.border = '1px solid var(--border-color)';
            notificationMenu.style.borderRadius = '8px';
            notificationMenu.style.zIndex = '2100';
            notificationMenu.style.padding = '10px';
            notificationMenu.style.boxShadow = '0 2px 10px rgba(0,0,0,0.3)';
            
            notificationMenu.innerHTML = `
                <div class="notification-header" style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border-color);">
                    <span style="font-weight: bold; color: var(--primary);">BİLDİRİMLER</span>
                    <div style="display: flex; gap: 5px;">
                        <button id="notification-history-btn" class="btn btn-tiny" title="Bildirim Geçmişi">📋</button>
                        <button id="clear-notifications" class="btn btn-tiny" title="Bildirimleri Temizle">🗑️</button>
                        <button id="toggle-notification-sound" class="btn btn-tiny" title="Sesi Aç/Kapat">🔊</button>
                    </div>
                </div>
                <div id="notifications-list" style="max-height: 200px; overflow-y: auto;"></div>
            `;
            
            document.body.appendChild(notificationMenu);
            
            // Bildirim butonuna tıklandığında menüyü göster/gizle
            notificationsBtn.addEventListener('click', function() {
                const isMenuVisible = notificationMenu.style.display !== 'none';
                notificationMenu.style.display = isMenuVisible ? 'none' : 'block';
                notificationsBtn.classList.toggle('active', !isMenuVisible);
            });
            
            // Bildirimler konteynerinin göster/gizle mantığı
            const toggleNotifications = function() {
                const isVisible = notificationsContainer.style.display !== 'none';
                notificationsContainer.style.display = isVisible ? 'none' : 'block';
            };
            
            // Menüdeki butonlar için olay dinleyicileri
            document.getElementById('notification-history-btn')?.addEventListener('click', function() {
                if (window.app && window.app.notificationCenter) {
                    window.app.notificationCenter.showHistory();
                }
            });
            
            document.getElementById('clear-notifications')?.addEventListener('click', function() {
                if (window.app && window.app.notificationCenter) {
                    window.app.notificationCenter.clearAll();
                }
            });
            
            document.getElementById('toggle-notification-sound')?.addEventListener('click', function() {
                if (window.app && window.app.notificationCenter) {
                    const notificationManager = window.app.notificationCenter;
                    notificationManager.soundEnabled = !notificationManager.soundEnabled;
                    this.innerHTML = notificationManager.soundEnabled ? '🔊' : '🔇';
                    notificationManager.notify('Bildirim sesleri ' + (notificationManager.soundEnabled ? 'açıldı' : 'kapatıldı'), 'system', 1);
                }
            });
            
            // Sayfa dışına tıklandığında menüyü kapat
            document.addEventListener('click', function(event) {
                if (!notificationsBtn.contains(event.target) && 
                    !notificationMenu.contains(event.target) && 
                    notificationMenu.style.display !== 'none') {
                    notificationMenu.style.display = 'none';
                    notificationsBtn.classList.remove('active');
                }
            });
        }
        
        // Pantheon paneli kontrolü
        if(pantheonToggleBtn && pantheonUI) {
            pantheonToggleBtn.addEventListener('click', function() {
                pantheonUI.classList.toggle('active');
                pantheonUI.style.transform = pantheonUI.classList.contains('active') ? 'translateX(0)' : 'translateX(-100%)';
                pantheonToggleBtn.classList.toggle('active');
            });
        }
        
        // Enerji Yönetimi butonu
        if(energyToggleBtn) {
            energyToggleBtn.addEventListener('click', function() {
                if (window.app && window.app.energyManager) {
                    window.app.energyManager.toggleEnergyBox();
                    energyToggleBtn.classList.add('active');
                    setTimeout(() => energyToggleBtn.classList.remove('active'), 500);
                    
                    // Sesli bildirim
                    if (window.app.speak) {
                        window.app.speak("Enerji yönetim sistemi etkinleştirildi. Mevcut sistem enerjisi yüzde " + 
                            Math.round(window.app.energyManager.currentEnergy) + " seviyesinde.");
                    }
                }
            });
        }
        
        // Ritüel Sistemi butonu
        if(ritualToggleBtn) {
            ritualToggleBtn.addEventListener('click', function() {
                if (window.app && window.app.ritualManager) {
                    window.app.ritualManager.toggleRitualContainer();
                    ritualToggleBtn.classList.add('active');
                    setTimeout(() => ritualToggleBtn.classList.remove('active'), 500);
                    
                    // Sesli bildirim
                    if (window.app.speak) {
                        window.app.speak("Ritüel sistemi etkinleştirildi. Gizli güçlere erişim sağlanıyor.");
                    }
                }
            });
        }
        
        // Hızlı ayarlar butonu
        if(quickSettingsBtn) {
            quickSettingsBtn.addEventListener('click', function() {
                document.getElementById('settings-modal-overlay').classList.add('visible');
                quickSettingsBtn.classList.add('active');
                setTimeout(() => quickSettingsBtn.classList.remove('active'), 500);
            });
        }
        
        // İstatistikler butonu
        if(verticalStatsBtn) {
            verticalStatsBtn.addEventListener('click', function() {
                document.getElementById('honor-modal-overlay').style.display = 'flex';
                verticalStatsBtn.classList.add('active');
                setTimeout(() => verticalStatsBtn.classList.remove('active'), 500);
            });
        }
        
        // Log butonu
        if(verticalLogBtn) {
            verticalLogBtn.addEventListener('click', function() {
                document.getElementById('log-modal-overlay').classList.add('visible');
                verticalLogBtn.classList.add('active');
                setTimeout(() => verticalLogBtn.classList.remove('active'), 500);
            });
        }

        // Kehanet Paneli Butonu (Sağ panel)
        if(kehanetToggleBtn) {
            kehanetToggleBtn.addEventListener('click', function() {
                document.getElementById('kehanet-panel').classList.toggle('active');
                document.getElementById('kehanet-panel').style.transform = document.getElementById('kehanet-panel').classList.contains('active') ? 'translateX(0)' : 'translateX(100%)';
                kehanetToggleBtn.classList.toggle('active');
            });
        }

        // OSIRIS Paneli Butonu (Sağ panel)
        if(osirisToggleBtn) {
            osirisToggleBtn.addEventListener('click', function() {
                document.getElementById('osiris-panel').classList.toggle('active');
                document.getElementById('osiris-panel').style.transform = document.getElementById('osiris-panel').classList.contains('active') ? 'translateX(0)' : 'translateX(100%)';
                osirisToggleBtn.classList.toggle('active');
            });
        }
        
        // Pantheon kapatma butonu
        const pantheonCloseBtn = document.querySelector('#panteon-panel .pp-expand-btn');
        if(pantheonCloseBtn && pantheonUI) {
            pantheonCloseBtn.addEventListener('click', function() {
                pantheonUI.classList.remove('active');
                pantheonUI.style.transform = 'translateX(-100%)';
                if(pantheonToggleBtn) pantheonToggleBtn.classList.remove('active');
            });
        }

        // Kehanet kapatma butonu
        const kehanetCloseBtn = document.querySelector('#kehanet-panel .kp-expand-btn');
        if(kehanetCloseBtn) {
            kehanetCloseBtn.addEventListener('click', function() {
                document.getElementById('kehanet-panel').classList.remove('active');
                document.getElementById('kehanet-panel').style.transform = 'translateX(100%)';
                if(kehanetToggleBtn) kehanetToggleBtn.classList.remove('active');
            });
        }

        // OSIRIS kapatma butonu
        const osirisCloseBtn = document.querySelector('#osiris-panel .panel-header span:last-child'); // Assuming it's the last span
        if(osirisCloseBtn) {
            osirisCloseBtn.addEventListener('click', function() {
                document.getElementById('osiris-panel').classList.remove('active');
                document.getElementById('osiris-panel').style.transform = 'translateX(100%)';
                if(osirisToggleBtn) osirisToggleBtn.classList.remove('active');
            });
        }
        
        // Sistemleri güvenli bir şekilde başlatma
        try {
            // App nesnesini başlat
            if (!window.app) {
                console.log('Trading Command Center başlatılıyor...');
                
                // UltimateTradingCommandCenter sınıfını kontrol et ve başlat
                if (typeof UltimateTradingCommandCenter === 'function') {
                    window.app = new UltimateTradingCommandCenter();
                    
                    // İleri düzey özellikleri başlat
                    if (typeof DBManager === 'function') {
                        window.app.dbManager = new DBManager();
                        window.app.dbManager.init();
                    }
                    
                    if (typeof EffectsManager === 'function') {
                        window.app.effectsManager = new EffectsManager();
                        // init is called later
                    }
                    
                    // Panteon sistemini başlat
                    if (typeof PantheonSystem === 'function') {
                        window.app.panteonManager = new PantheonSystem();
                        // init is called later
                    }
                    
                    // Oracle (Mahşerin Atlıları) sistemini başlat
                    if (typeof TheOracle === 'function') {
                        window.app.oracle = new TheOracle(window.app);
                        // init is called later
                    }
                    
                    // Çoklu zaman dilimi yöneticisini başlat
                    if (typeof MultiTimeframeManager === 'function') {
                        window.app.multiTimeframeManager = new MultiTimeframeManager(window.app);
                        // init is called later
                    }
                    
                    // Confluence motorunu başlat
                    if (typeof ConfluenceEngine === 'function') {
                        window.app.confluenceEngine = new ConfluenceEngine(this.app);
                    }
                } else {
                    console.error('UltimateTradingCommandCenter sınıfı tanımlı değil!');
                }
            }
        } catch (e) {
            console.error('Sistemleri başlatırken hata:', e);
        }
        
        // Panteon güç yönetimini başlat
        if (window.app && !window.app.pantheonPower) {
            window.app.pantheonPower = {
                buy: 0,
                sell: 0,
                lastUpdate: Date.now()
            };
        }
        
        // Panteon metodlarını app nesnesine güvenli bir şekilde bağla
        if (window.pantheonSystem && window.app) {
            const pantheonMethods = [
                'increasePower',
                'updateUI',
                'triggerAmbassadorSpecialAbility'
            ];
            
            // Her metodu kontrol et ve bağla
            pantheonMethods.forEach(methodName => {
                if (typeof window.pantheonSystem[methodName] === 'function' && !window.app[methodName]) {
                    window.app[methodName] = function(...args) {
                        if (window.pantheonSystem && typeof window.pantheonSystem[methodName] === 'function') {
                            return window.pantheonSystem[methodName].apply(window.pantheonSystem, args);
                        } else {
                            console.warn(`Panteon metodu ${methodName} artık mevcut değil.`);
                            return null;
                        }
                    };
                }
            });
            console.log('Panteon metodları başarıyla bağlandı.');
        } else {
            console.warn('Panteon veya App nesneleri henüz hazır değil.');
        }
        
        // Panteon arayüzünü güncelle
        if (window.app && window.app.updateUI) {
            window.app.updateUI();
        }
    }
    
    // Sayfa yüklendiğinde başlatma işlemlerini sıraya koyuyoruz
    // Tüm sınıfların yüklenmesinin ardından çalışması için setTimeout kullanıyoruz
    document.addEventListener('DOMContentLoaded', function() {
        // Sınıfların yüklenmesi için bir mikrosaniye bekle
        setTimeout(function() {
            // İlk olarak ana uygulamayı başlat
            initApp();
            
            // Ardından ek sistemleri güvenli bir şekilde başlat
            try {
                // Önce UltimateTradingCommandCenter'ın başlatılmış olduğunu kontrol et
                if (!window.app && typeof UltimateTradingCommandCenter === 'function') {
                    window.app = new UltimateTradingCommandCenter();
                    console.log('UltimateTradingCommandCenter tekrar başlatıldı');
                }
                
                // Panteon Sistemini başlat (eğer henüz başlatılmadıysa)
                if (typeof PantheonSystem === 'function' && !window.pantheonSystem) {
                    window.pantheonSystem = new PantheonSystem();
                    console.log('Panteon Sistemi başlatıldı');
                }
                
                // Advanced Trading Visualization Manager
                if (typeof AdvancedTradingVisualizer === 'function' && window.app) {
                    window.advancedVisualizer = new AdvancedTradingVisualizer(window.app);
                }
                
                // Enhanced Risk Management System
                if (typeof EnhancedRiskManagement === 'function' && window.app) {
                    window.riskManager = new EnhancedRiskManagement(window.app);
                }
                
                // Panteon metodlarını app nesnesine güvenli bir şekilde bağla (eğer henüz bağlanmadıysa)
                if (window.pantheonSystem && window.app) {
                    const pantheonMethods = [
                        'increasePower',
                        'updateUI',
                        'triggerAmbassadorSpecialAbility'
                    ];
                    
                    // Her metodu kontrol et ve bağla
                    pantheonMethods.forEach(methodName => {
                        if (typeof window.pantheonSystem[methodName] === 'function' && !window.app[methodName]) {
                            window.app[methodName] = function(...args) {
                                if (window.pantheonSystem && typeof window.pantheonSystem[methodName] === 'function') {
                                    return window.pantheonSystem[methodName].apply(window.pantheonSystem, args);
                                } else {
                                    console.warn(`Panteon metodu ${methodName} artık mevcut değil.`);
                                    return null;
                                }
                            };
                        }
                    });
                    
                    console.log('Panteon metodları başarıyla bağlandı.');
                }
                
                console.log('Tüm sistemler başlatıldı ve hazır.');
            } catch (error) {
                console.error('Ek sistemler başlatılırken hata:', error);
            }
        }, 100); // 100ms bekleyerek tüm sınıfların yüklenmesini garanti edelim
    });
    </script>

    <style>
        :root {
            --primary-font: 'Orbitron', monospace;
            --secondary-font: 'Roboto Mono', monospace;
            
            /* Dark Theme - Default War Room */
            --bg-primary: #0a0a0f;
            --bg-secondary: #14141f;
            --bg-tertiary: #1a1a2e;
            --border-color: #2a2a3e;
            --text-primary: #e8e8ff;
            --text-secondary: #a8a8c8;
            --text-muted: #686888;
            
            /* Status Colors */
            --success: #00ff88;
            --danger: #ff3366;
            --warning: #ffaa00;
            --info: #00aaff;
            
            /* Special Effects */
            --glow-success: 0 0 20px rgba(0, 255, 136, 0.5);
            --glow-danger: 0 0 20px rgba(255, 51, 102, 0.5);
            --glow-warning: 0 0 20px rgba(255, 170, 0, 0.5);
            --glow-info: 0 0 20px rgba(0, 170, 255, 0.5);
            
            /* War Mode */
            --war-bg: linear-gradient(135deg, #1a0000 0%, #000000 50%, #1a0000 100%);
            --war-accent: #ff0040;
            --war-glow: 0 0 30px rgba(255, 0, 64, 0.8);

            /* Backward compatibility */
            --background-dark: var(--bg-primary); 
            --panel-bg-dark: var(--bg-secondary); 
            --text-main-dark: var(--text-primary);
            --text-secondary-dark: var(--text-secondary);
            --border-color-dark: var(--border-color);
            --input-bg-dark: #070711;
            --hover-bg-dark: #22223a;
            --primary-dark: var(--info);
            
            --background-light: #ffffff; 
            --panel-bg-light: #f6f8fa; 
            --text-main-light: #24292f; 
            --text-secondary-light: #57606a; 
            --border-color-light: #d0d7de; 
            --input-bg-light: #f0f2f5; 
            --hover-bg-light: #e8eaed; 
            --primary-light: #0969da;
            
            --war-mode-bg: var(--war-bg);
            --war-mode-panel-bg: rgba(255, 0, 0, 0.08); 
            --war-mode-border: #8B0000; 
            --war-mode-text: #ff5858; 
            --war-mode-primary: var(--war-accent);
            
            --positive: var(--success);
            --negative: var(--danger);
            --neutral: var(--warning);
            
            --ticker-height: 30px; 
            --signal-bar-height: 40px;
            --header-min-height: 40px;
            
            /* Panteon Renkleri - Geliştirilmiş */
            --metatron-color: #3b82f6; --metatron-glow: rgba(59, 130, 246, 0.3); --metatron-bg: rgba(59, 130, 246, 0.1);
            --uriel-color: #f59e0b; --uriel-glow: rgba(245, 158, 11, 0.3); --uriel-bg: rgba(245, 158, 11, 0.1);
            --raphael-color: #10b981; --raphael-glow: rgba(16, 185, 129, 0.3); --raphael-bg: rgba(16, 185, 129, 0.1);
            --gabriel-color: #8b5cf6; --gabriel-glow: rgba(139, 92, 246, 0.3); --gabriel-bg: rgba(139, 92, 246, 0.1);
            --michael-color: #ef4444; --michael-glow: rgba(239, 68, 68, 0.3); --michael-bg: rgba(239, 68, 68, 0.1);
        }
        /* Fullscreen modda gizlenecek elemanlar */
        body.fullscreen-chart #super-top-ticker,
        body.fullscreen-chart #signal-progress-bar-container,
        body.fullscreen-chart .header,
        body.fullscreen-chart .panel-title,
        body.fullscreen-chart .vertical-icon-panel { /* Hide icon panels in fullscreen */
            display: none !important;
        }

        /* Fullscreen modda chart'ı büyütme */
        body.fullscreen-chart .container { padding-top: 0 !important; height: 100vh !important; }
        body.fullscreen-chart .main-grid { height: 100vh !important; margin: 0 !important; }
        body.fullscreen-chart .center-panel { flex-grow: 1 !important; height: 100vh !important; border-radius: 0 !important; margin: 0 !important; }
        body.fullscreen-chart .data-container { height: 100% !important; }
        body.fullscreen-chart #chart-container-view,
        body.fullscreen-chart #live-chart { height: 100% !important; flex-grow: 1 !important; }
        body.fullscreen-chart .heatmap-container { display: none !important; }
        body.fullscreen-chart .chart-zoom-controls { background: rgba(0,0,0,0.7); }
        body.fullscreen-chart #exit-fullscreen-btn { display: block !important; }
        body.fullscreen-chart #chart-countdown-overlay { display: block !important; }

        [data-theme="light"] { --background: var(--background-light); --panel-bg: var(--panel-bg-light); --text-main: var(--text-main-light); --text-secondary: var(--text-secondary-light); --border-color: var(--border-color-light); --input-bg: var(--input-bg-light); --hover-bg: var(--hover-bg-light); --primary: var(--primary-light); }
        [data-theme="dark"] { --background: var(--background-dark); --panel-bg: var(--panel-bg-dark); --text-main: var(--text-main-dark); --text-secondary: var(--text-secondary-dark); --border-color: var(--border-color-dark); --input-bg: #070711; --hover-bg: #22223a; --primary: var(--primary-dark); }
        [data-theme="war"] {
            --bg-primary: #0d0000;
            --bg-secondary: #1a0505;
            --bg-tertiary: #2a0a0a;
            --border-color: #4a0a0a;
            --text-primary: #ff6666;
            --text-secondary: #cc4444;
            --success: #ffff00;
            --danger: #ff0000;
            --background: var(--war-mode-bg);
            --panel-bg: var(--war-mode-panel-bg);
            --text-main: var(--war-mode-text);
            --text-secondary: #ffaaaa;
            --border-color: var(--war-mode-border);
            --input-bg: rgba(255, 255, 255, 0.05);
            --hover-bg: rgba(255, 255, 255, 0.1);
            --primary: var(--war-mode-primary);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: var(--secondary-font);
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            position: relative;
            transition: background 0.5s, color 0.5s;
        }

        /* Animasyonlu Arka Plan Izgarası */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 136, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: grid-move 10s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes grid-move {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }
        
        #super-top-ticker { 
            display: flex; position: fixed; top: 0; left: 0; width: 100%; background: var(--panel-bg); 
            border-bottom: 1px solid var(--border-color); padding: 2px 10px; z-index: 1100; 
            align-items: center; justify-content: space-between; font-size: 11px; font-weight: 700; 
            height: var(--ticker-height); 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .super-top-left { display: flex; align-items: center; gap: 10px; flex-shrink: 0;}
        #ticker-bar-symbol { color: var(--primary); }
        #ticker-bar-price { color: var(--text-main); font-size: 12px; }
        .super-top-right-buttons { display: flex; gap: 5px; }

        .container { display: flex; flex-direction: column; height: 100vh; padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); }

        .header { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; flex-shrink: 0; box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 5px; position: relative; }
        .header-top-bar { display: flex; align-items: center; width: 100%; padding: 5px 15px; min-height: var(--header-min-height); justify-content: space-between; cursor: pointer; font-weight: 700; font-size: 16px; color: var(--primary); }
        .header-collapsible-content { transition: max-height 0.35s ease-in-out, opacity 0.3s ease, padding 0.35s ease, visibility 0.35s; max-height: 300px; opacity: 1; overflow: hidden; visibility: visible; padding: 0 15px 8px 15px; }
        body.header-collapsed .header-collapsible-content { max-height: 0; opacity: 0; visibility: hidden; padding-top: 0; padding-bottom: 0; }

        .main-controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; padding-bottom: 8px; }
        .form-control { background: var(--input-bg); color: var(--text-main); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-family: 'Roboto Mono', monospace; }
        
        .status { display: flex; align-items: center; gap: 5px; font-size: 11px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--negative); transition: background-color 0.5s; }
        .status-dot.online { background: var(--positive); animation: pulse 2s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 #28a745b3; } 70% { box-shadow: 0 0 0 6px #28a74500; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        [data-theme="war"] .status-dot.online { background: var(--war-mode-primary); animation: war-pulse 1s infinite; }
        @keyframes war-pulse { 0% { box-shadow: 0 0 0 0 #ffc107b3; } 70% { box-shadow: 0 0 0 6px #ffc10700; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        .btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-family: var(--secondary-font);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border-color: var(--primary);
        }

        .btn-success {
            background: linear-gradient(135deg, #00aa44, #00ff88);
            border-color: var(--success);
            color: #000;
            box-shadow: var(--glow-success);
        }

        .btn-danger {
            background: linear-gradient(135deg, #cc0033, #ff3366);
            border-color: var(--danger);
            box-shadow: var(--glow-danger);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #cc8800, #ffaa00);
            border-color: var(--warning);
            color: #000;
            box-shadow: var(--glow-warning);
        }

        .btn-tiny {
            padding: 2px 6px;
            font-size: 10px;
            line-height: 1;
            min-width: 0;
            white-space: nowrap;
            letter-spacing: 0.5px;
        }
        
        .main-grid { 
            display: grid; 
            grid-template-columns: 60px 1fr 60px; /* Left panel width, chart, right panel width */
            gap: 5px; 
            flex-grow: 1; 
            margin: 5px; 
            overflow: hidden; 
            height: calc(100% - var(--header-min-height) - 10px - var(--ticker-height) - var(--signal-bar-height)); 
        }
        body.header-collapsed .main-grid { height: calc(100vh - var(--ticker-height) - var(--signal-bar-height) - 10px); margin-top: 0; } 
        
        .panel {
            background: var(--bg-secondary);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .panel-title {
            padding: 12px 16px;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            border-bottom: 1px solid var(--border-color);
            font-family: var(--primary-font);
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-content { padding: 10px; overflow-y: auto; flex-grow: 1; }
        .settings-group { margin-bottom: 15px; } .form-group { margin-bottom: 8px; } .form-label { display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px; }
        .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 12px; padding: 4px 0;}
        
        .price-display { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; width: 100%; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; font-size: 10px; margin-top: 8px; } 
        .price-item .price-label { color: var(--text-secondary); } 
        .price-item .price-value { font-size: 18px; font-weight: 700; }
        .price-item.countdown { grid-column: 1 / span 2; display: flex; justify-content: center; align-items: center; font-size: 14px; font-weight: 700; color: var(--primary); padding-top: 5px;}
        
        .center-panel { 
            grid-column: 2; /* Positioned in the middle column */
            display: grid; 
            grid-template-rows: 1fr; 
            gap: 5px; 
            padding: 0 !important; 
        } 
        .data-container { display: grid; grid-template-rows: 1fr auto; overflow: hidden; height: 100%; } 
        .data-grid { position: relative; overflow: hidden; min-height: 0; } 

        #live-chart { width: 100%; height: 100%; } 
        .heatmap-container { display: grid; grid-template-rows: auto 1fr; border-top: 1px solid var(--border-color); }
        #orderbook-heatmap { width: 100%; height: 100%; display: block; }

        .chart-zoom-controls { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; z-index: 100; }
        .chart-zoom-controls .btn-tiny { background: rgba(1, 4, 9, 0.7); backdrop-filter: blur(2px); }

        #exit-fullscreen-btn {
            position: absolute; top: 10px; right: 10px; z-index: 101; 
            background: rgba(1, 4, 9, 0.7); color: white; border-radius: 4px; 
            padding: 2px 6px; font-size: 16px; cursor: pointer; border: 1px solid var(--border-color);
            line-height: 1;
            display: none; /* Hidden by default */
        }
        #chart-countdown-overlay {
            position: absolute; top: 10px; left: 10px; z-index: 100; 
            background: rgba(1, 4, 9, 0.7); padding: 4px 8px; border-radius: 4px; 
            color: var(--primary); font-size: 14px; font-weight: bold;
            display: none; /* Hidden by default */
        }

        .data-table-container { width: 100%; height: 100%; overflow: auto; }
        .data-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .data-table th, .data-table td { padding: 6px 8px; text-align: left; border-bottom: 1px solid var(--border-color); white-space: nowrap;}
        .data-table th { font-weight: 700; position: sticky; top: 0; background: var(--panel-bg); z-index: 10;}
        .data-table tr:hover { background: var(--hover-bg); }
        .signal-buy { background-color: #28a74514; } .signal-sell { background-color: #dc354514; }
        .signal-tp { background-color: #28a74533; } .signal-sl { background-color: #dc354533; }
        .signal-pending { background-color: #ffc1071a; } /* Neutral/warning color with transparency */

        .stat-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border-color); font-size: 12px; }
        .stat-item:last-child { border-bottom: none; } .stat-label { color: var(--text-secondary); } .stat-value { font-weight: 700; }
        .btn-sm { padding: 1px 4px; font-size: 9px; margin-left: 4px; border-radius: 3px; cursor: pointer;}
        ::-webkit-scrollbar { width: 6px; height: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: var(--text-secondary); border-radius: 3px; }
        /* Bildirimlerin yeni stili ve konumu - sol dikey panel içinde */
        #notifications-container { 
            top: 60px; /* Adjusted position */
            left: 60px; /* Positioned right of the vertical icon panel */
            width: 280px; 
            max-height: 80vh;
            overflow-y: auto;
            pointer-events: auto; /* Allow interaction */
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            transition: all 0.3s ease-in-out;
            transform: translateX(-100%); /* Initially off-screen */
        }
        #notifications-container.active {
            transform: translateX(0); /* Slide in */
        }
        .notification { 
            background: rgba(22, 27, 34, 0.9); /* Hafif transparan */
            backdrop-filter: blur(4px);
            border: 1px solid var(--border-color); 
            border-right-width: 4px; /* Sağ kenarda renkli bordür */
            border-radius: 4px; 
            padding: 8px 12px; /* Daha küçük padding */
            font-size: 12px; /* Daha küçük font */
            box-shadow: 0 2px 8px rgba(0,0,0,0.3); 
            margin-top: 8px; 
            animation: slide-in-left 0.3s ease-out;
            pointer-events: auto; /* Bildirimler tıklanabilir olsun */
        }
        @keyframes slide-in-left {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slide-in-right {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slide-in {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .notification.success { border-right-color: var(--positive); } 
        .notification.danger { border-right-color: var(--negative); } 
        .notification.warning { border-right-color: var(--neutral); }
        
        /* Bildirim Menüsü Stilleri */
        .notification-menu {
            min-width: 200px;
        }
        
        .notification-menu .notification-header {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
            margin-bottom: 8px;
        }
        
        aside#settings-panel, aside#analytics-panel { display: none !important; }
        .hidden-view { display: none !important; } 

        /* YENİ LOG PANELİ STİLLERİ */
        #log-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 2550; }
        #log-modal-overlay.visible { display: flex; }
        .log-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 95%; max-width: 1000px; height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); }
        .log-modal-header { padding: 10px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 14px; color: var(--primary); }
        .log-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
        .log-modal-body { padding: 0; overflow-y: auto; flex-grow: 1; }
        #log-output { font-family: 'Roboto Mono', monospace; font-size: 11px; color: var(--text-secondary); padding: 10px; margin: 0; white-space: pre-wrap; word-break: break-all; }
        #log-output .log-error { color: var(--negative); }
        #log-output .log-warn { color: var(--neutral); }
        #log-output .log-info { color: var(--positive); }

        
        aside#settings-panel, aside#analytics-panel { display: none !important; }
        .hidden-view { display: none !important; } 

        #settings-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 2500; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        #settings-modal-overlay.visible { opacity: 1; visibility: visible; transform: translateY(0); }
        .settings-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 90%; max-width: 900px; max-height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); transform: translateY(20px); transition: transform 0.3s ease; }
        #settings-modal-overlay.visible .settings-modal-content { transform: translateY(0); }
        .settings-modal-header { padding: 12px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 15px; color: var(--primary); }
        .settings-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
        .settings-modal-header .close-btn:hover { color: var(--negative); }
        .settings-modal-body { padding: 15px; overflow-y: auto; flex-grow: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .settings-modal-footer { padding: 12px 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 10px; }

        /* Yeni Sinyal Barı */
        #signal-progress-bar-container {
            display: flex; gap: 5px; width: 100%; padding: 5px 10px; background: var(--panel-bg); 
            border-bottom: 1px solid var(--border-color); justify-content: space-around; align-items: center;
            position: fixed; top: var(--ticker-height); left: 0; z-index: 1099;
            height: var(--signal-bar-height);
        }
        .signal-bar-wrapper { flex: 1; text-align: center; }
        .signal-bar-label { font-size: 10px; color: var(--text-secondary); margin-bottom: 3px; }
        .signal-bar { width: 100%; height: 10px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 5px; overflow: hidden; position: relative; }
        .signal-bar-fill { height: 100%; width: 0%; transition: width 0.2s ease-out; position: absolute; left: 0; top: 0; background: linear-gradient(90deg, transparent, var(--positive)); }
        .signal-bar-fill.buy { background: linear-gradient(90deg, transparent, var(--positive)); }
        .signal-bar-fill.sell { background: linear-gradient(90deg, transparent, var(--negative)); }
        .signal-score-text { font-size: 9px; margin-top: 2px; color: var(--primary); }

        /* Resizable Handle */
        .resize-handle { position: absolute; bottom: 0; left: 0; width: 100%; height: 8px; cursor: ns-resize; background: var(--border-color); z-index: 10; border-top: 1px solid var(--border-color); }
        .center-panel.resizing { user-select: none; }

        /* Dikey İkon Paneli Stilleri - Sol tarafta konumlandırıldı */
        .vertical-icon-panel {
            position: fixed;
            top: var(--ticker-height); /* Below the ticker */
            left: 0; 
            transform: translateY(0%);
            z-index: 2000;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-left: none; 
            border-radius: 0 10px 10px 0; 
            padding: 10px 5px;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2); 
            display: flex;
            flex-direction: column;
            gap: 10px;
            opacity: 0.95;
            transition: opacity 0.3s ease, transform 0.3s ease;
            height: calc(100vh - var(--ticker-height) - var(--header-min-height) - 10px); /* Fill remaining height */
        }

        /* Right vertical icon panel */
        .vertical-icon-panel.right-icons {
            left: auto; /* Override left for right panel */
            right: 0;
            border-radius: 10px 0 0 10px; /* Rounded left corners */
            border-right: none;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.2);
        }
        
        .vertical-icon-panel:hover {
            opacity: 1;
        }
        
        .vertical-icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-main);
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .vertical-icon-btn:hover {
            background: var(--hover-bg);
            transform: translateX(-3px);
        }
        .vertical-icon-panel.right-icons .vertical-icon-btn:hover {
            transform: translateX(3px);
        }
        
        .vertical-icon-btn.active {
            background: var(--primary);
            color: #000;
        }
        
        /* Panteon UI Stilleri - Sade ve Zarif */
        .pantheon-ui {
            position: fixed;
            top: var(--ticker-height); /* Adjusted to be below ticker */
            left: 60px; /* Positioned to the right of the vertical icon panel */
            transform: translateX(-100%); /* Initially off-screen */
            background: rgba(13, 17, 23, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 10px;
            width: 320px;
            height: auto;
            max-height: calc(100vh - var(--ticker-height) - var(--header-min-height) - 10px);
            z-index: 1200; 
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease-in-out;
            display: flex; /* Flexbox for internal layout */
            flex-direction: column;
        }
        
        /* Activate class for sliding in */
        .pantheon-ui.active {
            transform: translateX(0);
            opacity: 1;
            visibility: visible;
        }
        
        /* Mobil cihazlar için Pantheon UI stilleri */
        @media screen and (max-width: 768px) {
            .vertical-icon-panel {
                top: auto;
                bottom: 70px;
                left: 0;
                transform: none;
                border-radius: 0 10px 10px 0;
                padding: 10px 5px;
                height: auto;
            }
            .vertical-icon-panel.right-icons {
                right: 0;
                left: auto;
                border-radius: 10px 0 0 10px;
            }
            
            .pantheon-ui, #kehanet-panel, #osiris-panel, #energy-box, #ritual-container, #notifications-container {
                width: 90vw;
                left: 5vw !important; /* Centered with some margin */
                right: 5vw !important; /* Centered with some margin */
                top: 60px !important; /* Adjusted top to avoid ticker/signal bar */
                transform: translateY(-100%); /* Slide from top for mobile */
                opacity: 0;
                visibility: hidden;
            }
            .pantheon-ui.active, #kehanet-panel.active, #osiris-panel.active, #energy-box.active, #ritual-container.active, #notifications-container.active {
                transform: translateY(0);
                opacity: 1;
                visibility: visible;
            }
            
            .pantheon-content {
                max-height: 350px;
            }
            
            .god {
                height: 55px;
            }
            
            .ability {
                height: 45px;
            }
        }
        
        .pantheon-ui:hover {
            opacity: 1;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .pantheon-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .pantheon-title {
            font-weight: 700;
            color: var(--primary);
            font-size: 12px;
            letter-spacing: 1px;
            text-transform: uppercase;
            background: linear-gradient(90deg, var(--primary), #9ca3af);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .pantheon-controls {
            display: flex;
            gap: 8px;
        }
        
        .pantheon-toggle-btn,
        .pantheon-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .pantheon-toggle-btn:hover,
        .pantheon-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-main);
        }
        
        .pantheon-close:hover {
            color: var(--negative);
        }
        
        .pantheon-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: auto;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
        }
        
        /* Custom scrollbar for webkit browsers */
        .pantheon-content::-webkit-scrollbar {
            width: 5px;
        }
        
        .pantheon-content::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .pantheon-content::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .pantheon-content::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        .pantheon-gods {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
        }
        
        .god {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px;
            height: 60px;
            border-radius: 6px;
            background: rgba(22, 27, 34, 0.6);
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.03);
            box-sizing: border-box;
        }
        
        .god:hover {
            background: rgba(33, 38, 45, 0.8);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }
        
        .god-info {
            display: flex;
            align-items: center;
            gap: 10px;
            height: 32px;
            width: 100%;
        }
        
        .god-icon {
            font-size: 18px;
            min-width: 30px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .god-details {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .god-name {
            font-weight: 500;
            font-size: 13px;
            color: var(--text-main);
        }
        
        .god-power {
            font-size: 12px;
            font-weight: 600;
            color: var(--primary);
        }
        
        .god-progress {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .god-progress-fill {
            height: 100%;
            width: 0%;
            border-radius: 2px;
            transition: width 0.3s ease, opacity 0.3s ease;
        }
        
        /* Enhanced god-specific gradients */
        .metatron .god-progress-fill { background: linear-gradient(90deg, var(--metatron-color), #7e6be8); }
        .uriel .god-progress-fill { background: linear-gradient(90deg, var(--uriel-color), #e06c75); }
        .raphael .god-progress-fill { background: linear-gradient(90deg, var(--raphael-color), #98c379); }
        .gabriel .god-progress-fill { background: linear-gradient(90deg, var(--gabriel-color), #61afef); }
        .michael .god-progress-fill { background: linear-gradient(90deg, var(--michael-color), #d19a66); }
        
        .pantheon-abilities {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 4px;
            width: 100%;
        }
        
        .ability {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            height: 50px;
            border-radius: 6px;
            background: rgba(22, 27, 34, 0.6);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.03);
            cursor: pointer;
            transition: all 0.2s ease;
            box-sizing: border-box;
        }
        
        .ability:hover {
            background: rgba(33, 38, 45, 0.8);
            transform: translateY(-1px);
        }
        
        .ability-icon {
            font-size: 16px;
            margin-right: 12px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 50%;
        }
        
        .ability-details {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 100%;
            width: calc(100% - 40px);
        }
        
        .ability-name {
            font-weight: 500;
            font-size: 13px;
            color: var(--text-main);
        }
        
        .ability-status {
            font-size: 11px;
            font-weight: 500;
            color: #98c379;
        }
        
        .ability.on-cooldown .ability-status {
            color: #e06c75;
        }
        
        .ability-cooldown {
            position: absolute;
            left: 0;
            bottom: 0;
            height: 2px;
            width: 100%;
            background: linear-gradient(90deg, var(--primary), #56b6c2);
            transform-origin: left;
            transform: scaleX(1);
        }
        
        .ability.on-cooldown::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }
        
        .god-icon {
            font-size: 13px;
            margin-bottom: 2px;
            text-align: center;
        }
        
        .god-name {
            font-weight: 600;
            font-size: 9px;
            text-align: center;
            margin-bottom: 2px;
            font-family: 'Roboto Mono', monospace;
        }
        
        .god-power {
            font-size: 8px;
            text-align: center;
            margin-bottom: 2px;
            font-family: 'Roboto Mono', monospace;
        }
        
        .god-progress {
            width: 100%;
            height: 4px; /* Çok daha ince çubuk */
            background: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .god-progress-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        
        /* Her tanrı için özel renkler */
        .metatron .god-progress-fill { background: var(--metatron-color); }
        .uriel .god-progress-fill { background: var(--uriel-color); }
        .raphael .god-progress-fill { background: var(--raphael-color); }
        .gabriel .god-progress-fill { background: var(--gabriel-color); }
        .michael .god-progress-fill { background: var(--michael-color); }
        
        .pantheon-abilities {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 sütunlu grid */
            gap: 4px;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid var(--border-color);
        }
        
        .ability {
            background: var(--input-bg);
            border-radius: 5px;
            padding: 4px 2px; /* Minimum padding */
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .ability:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .ability-icon {
            font-size: 13px;
            margin-bottom: 1px;
        }
        
        .ability-name {
            font-size: 8px; /* Daha da küçük font */
            font-weight: 600;
        }
        
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: var(--primary);
            width: 100%;
            transform-origin: left;
            transform: scaleX(0);
            transition: transform 0.1s linear;
        }
        
        /* Animasyonlar */
        @keyframes pulse {
            0% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.6; transform: scale(1); }
        }
        
        .ability.active {
            animation: pulse 1.5s infinite;
        }

        /* DÜZELTME: Metinlerin yanlışlıkla seçilmesini engelle */
        .btn, .panel-title, .header-top-bar, .signal-bar-label, .form-label {
            user-select: none; /* Standart */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
        }

        /* Ritüel Sistemi Stilleri */
        .ritual-container {
            top: 60px; /* Adjusted position */
            right: 60px;
            width: 320px;
        }
        
        .ritual-container.hidden {
            transform: translateY(150%);
            opacity: 0;
        }
        
        .ritual-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: linear-gradient(90deg, var(--bg-tertiary), var(--panel-bg));
            border-bottom: 1px solid var(--border-color);
            border-radius: 8px 8px 0 0;
        }
        
        .ritual-title {
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .ritual-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, var(--warning), var(--danger));
            border-radius: 50%;
            position: relative;
            overflow: hidden;
        }
        
        .ritual-icon::after {
            content: "✧";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .ritual-close {
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            font-size: 16px;
        }
        
        .ritual-close:hover {
            opacity: 1;
            color: var(--danger);
        }
        
        .ritual-description {
            padding: 12px 15px;
            font-size: 12px;
            line-height: 1.4;
            color: var(--text-secondary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .ritual-list {
            max-height: 280px;
            overflow-y: auto;
            padding: 5px;
        }
        
        .ritual-list::-webkit-scrollbar {
            width: 5px;
        }
        
        .ritual-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }
        
        .ritual-list::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
        }
        
        .ritual-item {
            padding: 10px;
            margin: 5px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .ritual-item:hover {
            background: rgba(255, 255, 255, 0.07);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .ritual-item.active {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.1), rgba(255, 51, 102, 0.1));
            border-color: rgba(255, 170, 0, 0.3);
        }
        
        .ritual-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .ritual-item-title {
            font-weight: 600;
            font-size: 12px;
            color: var(--text-primary);
        }
        
        .ritual-item-duration {
            font-size: 10px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .ritual-item-description {
            font-size: 11px;
            color: var(--text-secondary);
            margin: 5px 0;
        }
        
        .ritual-item-effect {
            font-size: 10px;
            color: var(--success);
            margin-top: 5px;
        }
        
        .ritual-item-cost {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 10px;
            color: var(--warning);
        }
        
        .ritual-item-progress {
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .ritual-item-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--warning), var(--success));
            transition: width 0.5s ease;
        }
        
        .ritual-actions {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .ritual-btn {
            background: linear-gradient(135deg, var(--bg-tertiary), var(--border-color));
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            margin: 0 5px;
            text-align: center;
        }
        
        .ritual-btn:hover {
            background: linear-gradient(135deg, var(--border-color), var(--bg-tertiary));
            border-color: var(--text-secondary);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
        }
        
        .ritual-btn:active {
            transform: scale(0.98);
        }
        
        .ritual-btn.primary {
            background: linear-gradient(135deg, var(--warning), var(--danger));
            border-color: var(--warning);
        }
        
        .ritual-btn.primary:hover {
            background: linear-gradient(135deg, var(--danger), var(--warning));
        }
        
        .ritual-status {
            padding: 10px 15px;
            font-size: 11px;
            text-align: center;
            color: var(--text-secondary);
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0 0 8px 8px;
        }
        
        .ritual-active-label {
            position: absolute;
            top: -10px;
            right: -10px;
            background: var(--success);
            color: black;
            font-size: 8px;
            padding: 2px 5px;
            border-radius: 3px;
            transform: rotate(10deg);
            z-index: 1;
        }
        
        /* Ritüel animasyonları */
        @keyframes ritualActivate {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes ritualPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 170, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 170, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 170, 0, 0); }
        }
        
        .ritual-active {
            animation: ritualPulse 2s infinite;
        }
        
        .ritual-activate-effect {
            animation: ritualActivate 0.5s ease-in-out;
        }
        
        /* Ritüel efektleri - Grafik stillerine eklemeler */
        .ritual-effect-trend #live-chart {
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.5);
        }
        
        .ritual-effect-confluence #live-chart {
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }
        
        .ritual-effect-liquidity #live-chart {
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
        }
        
        .ritual-effect-orderflow #live-chart {
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.5);
        }
        
        .ritual-effect-protection #live-chart {
            box-shadow: 0 0 15px rgba(132, 0, 255, 0.5);
        }
        
        @media screen and (max-width: 768px) {
            .desktop-only { display: none !important; }
            .mobile-only { display: flex !important; align-items: center; }

            .container { 
                padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); 
                padding-bottom: var(--header-min-height); 
            }
            #signal-progress-bar-container { top: var(--ticker-height); }
            
            .header { 
                order: 2; 
                position: fixed;
                bottom: 0; 
                left: 0;
                right: 0;
                width: 100%; 
                z-index: 1000; 
                margin: 0; 
                border-radius: 0; 
                border: none; 
                border-top: 1px solid var(--border-color); 
            }
            /* DÜZELTME: Butonlar ve başlık için yeni ve daha basit düzen */
            .header-top-bar { 
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0 10px; 
                min-height: var(--header-min-height);
            }
            .header-center-title {
                cursor: pointer;
                flex-grow: 1;
                text-align: center;
            }
            .header-left-controls, .header-right-controls {
                display: flex;
                gap: 8px;
            }
            #mobile-toggle-controls-btn, .header-right-controls .btn {
                font-size: 16px;
                padding: 5px 10px;
            }
            /* Mobilde masaüstü başlığını gizle */
            .header-center-title .header-title-text {
                display: none;
            }

            .header-collapsible-content { padding: 0; }
            .header-collapsible-content .main-controls { flex-direction: column; align-items: center; padding: 0; width: 100%; }
            .form-control, .btn, .status { width: 100%; text-align: center; padding: 8px 10px; font-size: 11px; }
            .status { justify-content: center; }
            .price-display { grid-template-columns: repeat(2, 1fr); margin-top: 10px; }
            .price-item .price-value { font-size: 14px; } 
            
            .main-grid { 
                order: 1; 
                margin: 0;
                height: 100%;
                display: flex;
                flex-direction: column;
            }
            .center-panel { 
                order: 1; 
                flex-grow: 1;
                height: 100%;
                border: none;
                border-radius: 0; 
                background: transparent;
                box-shadow: none; 
                margin: 0; 
            }
            .center-panel > .panel-title { display: none; }
            .data-container { 
                flex-direction: column; 
                height: 100%; 
                padding: 5px;
            }
            .data-grid { 
                height: 100%;
                flex-grow: 1;
            }
            #live-chart { height: 100%; width: 100%; } 
            .heatmap-container { height: 150px; flex-shrink: 0; margin-top: 10px; border-top: 1px solid var(--border-color); padding-top: 10px; }
            .heatmap-container .panel-title { border-bottom: none; margin-bottom: 5px; }
            .settings-modal-content { width: 95%; margin: 10px; }
            .settings-modal-body { grid-template-columns: 1fr; gap: 15px; }
            .super-top-right-buttons { display: none; }
            .resize-handle { display: none; }
            #chart-countdown-overlay { font-size: 12px; padding: 3px 6px; }

            body.fullscreen-chart .main-grid { height: 100vh; }
            body.fullscreen-chart .center-panel { height: 100vh; }
        }

    </style>
</head>
<body class="header-collapsed" data-theme="dark">
    <!-- Super Top Ticker -->
    <div id="super-top-ticker">
        <div class="super-top-left">
            <span id="ticker-bar-symbol"></span>
            <span id="ticker-bar-price"></span>
        </div>
        <!-- MASAÜSTÜ BUTONLARI -->
        <div class="super-top-right-buttons desktop-only">
            <button id="main-controls-btn" class="btn btn-tiny" title="Komuta Merkezi">⚙️</button>
            <button id="chart-view-btn" class="btn btn-tiny" title="Grafik">📈</button>
            <button id="heatmap-view-btn" class="btn btn-tiny" title="Isı Haritası">🔥</button>
            <button id="fullscreen-chart-btn" class="btn btn-tiny" title="Tam Ekran Grafik">📺</button>
            <button id="honor-board-btn" class="btn btn-tiny" title="Şeref Tablosu">🏆</button>
            <button id="banned-board-btn" class="btn btn-tiny" title="Banlılar">🚫</button>
            <button id="open-settings-modal-btn" class="btn btn-tiny" title="Ayarlar">🔧</button>
        </div>
        <!-- YENİ MOBİL BUTONLARI -->
        <div class="super-top-right-buttons mobile-only">
            <button id="mobile-fullscreen-chart-btn" class="btn btn-tiny" title="Tam Ekran">📺</button>
            <button id="mobile-open-log-modal-btn" class="btn btn-tiny" title="Log">📜</button>
            <button id="mobile-open-settings-modal-btn" class="btn btn-tiny btn-success" title="Ayarlar">🔧</button>
        </div>
    </div>

    <!-- Yeni Sinyal Barı -->
    <div id="signal-progress-bar-container">
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">BUY SINYAL GÜCÜ</div>
            <div class="signal-bar">
                <div id="buy-signal-bar-fill" class="signal-bar-fill buy"></div>
            </div>
            <div id="buy-signal-score-text" class="signal-score-text">0.0</div>
        </div>
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">SELL SINYAL GÜCÜ</div>
            <div class="signal-bar">
                <div id="sell-signal-bar-fill" class="signal-bar-fill sell"></div>
            </div>
            <div id="sell-signal-score-text" class="signal-score-text">0.0</div>
        </div>
    </div>

    <div class="container">
        <header class="header">
            <div id="header-main-bar" class="header-top-bar">
                <div class="header-left-controls">
                    <button id="mobile-toggle-controls-btn" class="btn btn-tiny mobile-only" title="Kontrolleri Aç/Kapat">☰</button>
                </div>
                <div class="header-center-title" title="Paneli aç/kapatmak için çift tıkla">
                    <span class="header-title-text">KOMUTA MERKEZİ KONTROLLERİ</span>
                </div>
                <div class="header-right-controls">
                    <button id="mobile-chart-view-btn" class="btn btn-tiny mobile-only" title="Grafik">📈</button>
                    <button id="mobile-heatmap-view-btn" class="btn btn-tiny mobile-only" title="Isı Haritası">🔥</button>
                    <button id="mobile-honor-board-btn" class="btn btn-tiny mobile-only" title="Şeref Tablosu">🏆</button>
                    <button id="mobile-banned-board-btn" class="btn btn-tiny mobile-only" title="Banlılar">🚫</button>
                </div>
            </div>
            <div class="header-collapsible-content">
                <div class="main-controls">
                    <input type="text" id="symbol-input" class="form-control" placeholder="Örn: BTC, ETH, SOL">
                    <select id="timeframe-select" class="form-control">
                        <option value="1m">1m</option><option value="5m">5m</option><option value="15m" selected>15m</option><option value="1h">1h</option><option value="4h">4h</option>
                    </select>
                    <div class="status">
                        <div id="connection-status" class="status-dot"></div>
                        <span id="connection-text">BAĞLANTI YOK</span>
                    </div>
                    <button id="theme-toggle-btn" class="btn">Tema</button>
                    <button id="start-btn" class="btn btn-success">SİSTEMİ BAŞLAT</button>
                    <button id="stop-btn" class="btn btn-danger" disabled>DURDUR</button>
                    <button id="clear-markers-btn" class="btn">Grafik Sinyallerini Sil</button> 
                </div>
                <div class="price-display">
                    <div class="price-item"><div class="price-label">FİYAT</div><div class="price-value" id="current-price">-</div></div>
                    <div class="price-item"><div class="price-label">24s DEĞİŞİM</div><div class="price-value" id="price-change-24h">-</div></div>
                    <div class="price-item"><div class="price-label">24s HACİM</div><div class="price-value" id="volume-24h">-</div></div>
                    <div class="price-item"><div class="price-label">VOLATİLİTE (ATR)</div><div class="price-value" id="atr-value">-</div></div>
                    <div class="price-item countdown"><span id="candle-countdown">--:--</span></div>
                </div>
            </div>
        </header>

<main class="main-grid">
            <!-- Left Vertical Icon Panel -->
            <div class="vertical-icon-panel left-icons">
                <button id="notifications-btn" class="vertical-icon-btn" title="Bildirimler">📢</button>
                <button id="pantheon-toggle-btn" class="vertical-icon-btn" title="Panteon Sistemi">👑</button>
                <button id="energy-toggle-btn" class="vertical-icon-btn" title="Enerji Yönetimi">⚡</button>
                <button id="ritual-toggle-btn" class="vertical-icon-btn" title="Ritüel Sistemi">✨</button>
                <button id="quick-settings-btn" class="vertical-icon-btn" title="Hızlı Ayarlar">⚙️</button>
                <button id="vertical-stats-btn" class="vertical-icon-btn" title="İstatistikler">📊</button>
                <button id="vertical-log-btn" class="vertical-icon-btn" title="Log">📜</button>
            </div>

            <section class="center-panel panel">
                <div class="data-container">
                    <div class="data-grid" id="chart-container-view">
                        <div id="live-chart"></div>
                        <div class="chart-zoom-controls"> 
                            <button id="chart-zoom-in" class="btn btn-tiny">+</button>
                            <button id="chart-zoom-out" class="btn btn-tiny">-</button>
                            <button id="chart-zoom-reset" class="btn btn-tiny">Sıfırla</button>
                        </div>
                        <button id="exit-fullscreen-btn" class="btn btn-tiny" title="Tam Ekrandan Çık">&times;</button>
                        <div id="chart-countdown-overlay" class="hidden-view">--:--</div>
                    </div>
                    <div class="heatmap-container" id="heatmap-container-view">
                        <div class="panel-title" style="border-top: 1px solid var(--border-color); border-bottom: none;">EMİR DEFTERİ ISI HARİTASI</div>
                        <canvas id="orderbook-heatmap"></canvas>
                    </div>
                </div>
                <div class="resize-handle"></div>
            </section>

            <!-- Right Vertical Icon Panel -->
            <div class="vertical-icon-panel right-icons">
                <button id="kehanet-toggle-btn" class="vertical-icon-btn" title="Kehanet Paneli">🔮</button>
                <button id="osiris-toggle-btn" class="vertical-icon-btn" title="OSIRIS Sentinel">🛡️</button>
            </div>
        </main>
    </div>
    
    <!-- Panteon Paneli -->
    <aside id="panteon-panel" class="side-panel left-panel" aria-label="Panteon Paneli">
        <div class="pp-title panel-header">
            <span>⚡ Panteon</span>
            <span id="pp-env">v3.5</span>
            <button class="pp-expand-btn" id="pp-expand-btn" title="Paneli Kapat">✖</button>
        </div>
        <div class="pp-body panel-body">
            <div class="panteon-stats">
                <div class="regime-indicator">
                    <span>Rejim:</span>
                    <span class="current-regime">NORMAL</span>
                </div>
                <div class="state-indicator">
                    <span>Kolektif:</span>
                    <span class="collective-state">Dengeli</span>
                </div>
            </div>
            
            <div class="panteon-panel">
                <!-- Metatron - Bilgelik Elçisi -->
                <div class="ambassador" data-name="metatron" data-mode="İNANÇLI" data-role="wisdom">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Metatron</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">✓</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">Bilgelik, Analiz</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">İNANÇLI</span>
                            <span class="reputation">İtibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>Güven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>Güç</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="SupportResistanceStrategy">Destek/Direnç</button>
                        <button data-strategy="MeanReversionStrategy">Ort. Geri Dönüş</button>
                        <button data-strategy="OrderBookImbalanceStrategy">Emir Defteri</button>
                    </div>
                </div>
                
                <!-- Uriel - Cesaret Elçisi -->
                <div class="ambassador" data-name="uriel" data-mode="İNANÇLI" data-role="courage">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Uriel</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">✓</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">Cesaret, Hız</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">İNANÇLI</span>
                            <span class="reputation">İtibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>Güven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>Güç</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="BreakoutPatternStrategy">Kırılma</button>
                        <button data-strategy="MomentumStrategy">Momentum</button>
                        <button data-strategy="TrendFollowingStrategy">Trend Takip</button>
                    </div>
                </div>
                
                <!-- Raphael - Şifa Elçisi -->
                <div class="ambassador" data-name="raphael" data-mode="İNANÇLI" data-role="healing">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Raphael</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">✓</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">Şifa, Denge</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">İNANÇLI</span>
                            <span class="reputation">İtibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>Güven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>Güç</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="StatArbitrageStrategy">İstatistik Arb.</button>
                        <button data-strategy="LiquidityGapStrategy">Likidite Boşl.</button>
                        <button data-strategy="OverboughtOversoldStrategy">Aşırı Al/Sat</button>
                    </div>
                </div>
                
                <!-- Gabriel - İletişim Elçisi -->
                <div class="ambassador" data-name="gabriel" data-mode="İNANÇLI" data-role="communication">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Gabriel</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">✓</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">İletişim, Bilgi</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">İNANÇLI</span>
                            <span class="reputation">İtibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>Güven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>Güç</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="SmartMoneyStrategy">Akıllı Para</button>
                        <button data-strategy="VolumeProfileStrategy">Hacim Profili</button>
                        <button data-strategy="SentimentAnalysisStrategy">Duygu Analizi</button>
                    </div>
                </div>
                
                <!-- Michael - Savaş Elçisi -->
                <div class="ambassador" data-name="michael" data-mode="İNANÇLI" data-role="warfare">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Michael</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">✓</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">Savaş, Güç</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">İNANÇLI</span>
                            <span class="reputation">İtibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>Güven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>Güç</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="AggressiveCandleStrategy">Agresif Mum</button>
                        <button data-strategy="LiquidationCascadeStrategy">Likid. Kaskad</button>
                        <button data-strategy="VolatilityBreakoutStrategy">Volatilite</button>
                    </div>
                </div>
                
                <!-- Yetenek Düğmeleri -->
                <div class="pantheon-abilities">
                    <div class="pantheon-ability ready" id="ability-revelation" data-ability="revelation">
                        <div class="ability-icon">🔍</div>
                        <div class="ability-name">Vahiy</div>
                        <div class="ability-status">Ready</div>
                        <div class="ability-cooldown"></div>
                    </div>
                    <div class="pantheon-ability ready" id="ability-valor" data-ability="valor">
                        <div class="ability-icon">🛡️</div>
                        <div class="ability-name">Cesaret</div>
                        <div class="ability-status">Ready</div>
                        <div class="ability-cooldown"></div>
                    </div>
                    <div class="pantheon-ability ready" id="ability-restoration" data-ability="restoration">
                        <div class="ability-icon">💫</div>
                        <div class="ability-name">Şifa</div>
                        <div class="ability-status">Ready</div>
                        <div class="ability-cooldown"></div>
                    </div>
                </div>
            </div>
            <div class="pp-footer" style="padding: 10px; border-top: 1px solid var(--border-color);">
                <div class="pp-collective-state">
                    <span class="pp-state-label">Kolektif Durum:</span>
                    <span class="pp-state-value" id="pp-collective-state">Dengeli</span>
                </div>
                <div class="pp-actions">
                    <button class="pp-action-btn" id="pp-action-council" title="Meclis Toplantısı">🏛️</button>
                    <button class="pp-action-btn" id="pp-action-reset" title="İtibarları Sıfırla">🔄</button>
                </div>
            </div>
        </div>
    </aside>
    
    <!-- Kehanet Paneli -->
    <aside id="kehanet-panel" class="side-panel right-panel" aria-label="Kehanet Paneli">
        <div class="kp-title panel-header">
            <span>🔮 Kehanet</span>
            <span id="kp-session">—</span>
            <button class="kp-expand-btn" id="kp-expand-btn" title="Paneli Kapat">✖</button>
        </div>
        <div class="kp-body panel-body">
            <div class="kp-row">
                <span class="kp-key">🛡️ Koruma</span>
                <span class="kp-val" id="kp-guardian">Aktif</span>
            </div>
            <div class="kp-row">
                <span class="kp-key">⚖️ Rejim</span>
                <span class="kp-val" id="kp-regime">—</span>
            </div>
            <div class="kp-row">
                <span class="kp-key">⚔️ Nabız</span>
                <span class="kp-val" id="kp-pulse">—</span>
            </div>
            <div class="kp-row">
                <span class="kp-key">🎯 Eğilim</span>
                <span class="kp-val" id="kp-trend">—</span>
            </div>
            <div class="kp-divider"></div>
            <div class="kp-advanced" id="kp-advanced">
                <div class="kp-row">
                    <span class="kp-key">🧠 Tahmin</span>
                    <span class="kp-val" id="kp-prediction">—</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">🔮 Olasılık</span>
                    <span class="kp-val" id="kp-probability">—</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">⏱️ Zaman Hedefi</span>
                    <span class="kp-val" id="kp-timeframe">—</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">🌊 Likidite</span>
                    <span class="kp-val" id="kp-liquidity">—</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">💧 Baskı</span>
                    <span class="kp-val" id="kp-pressure">—</span>
                </div>
                <div class="kp-chart-container">
                    <div id="kp-mini-chart" class="kp-mini-chart"></div>
                </div>
            </div>
        </div>
        <div class="kp-footer">
            <div class="kp-confidence-bar">
                <div class="kp-confidence-fill" id="kp-confidence-fill"></div>
                <div class="kp-confidence-label" id="kp-confidence-label">Güven: %75</div>
            </div>
            <button class="kp-refresh-btn" id="kp-refresh-btn" title="Tahminleri Yenile">⟳</button>
        </div>
    </aside>

    <!-- OSIRIS Sentinel System Panel -->
    <aside id="osiris-panel" class="side-panel right-panel" aria-label="OSIRIS Sentinel Panel">
        <div class="panel-header" onclick="toggleOSIRISPanel()">
            🛡️ OSIRIS SENTINEL
            <div style="flex:1;height:1px;background:linear-gradient(90deg,#3b82f6,transparent);"></div>
            <span id="osiris-toggle" style="font-size:14px;">−</span>
        </div>
        <div id="osiris-content" class="panel-body">
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;">
                <div>Risk: <span id="osiris-risk-level" class="risk-level low">LOW</span></div>
                <div>Threats: <span id="osiris-threat-count">0</span></div>
                <div>Cyber Bees: <span id="osiris-bee-status">0/0</span></div>
                <div>Status: <span style="color:#10b981;">ACTIVE</span></div>
            </div>
            <div style="font-size:10px;opacity:0.7;text-align:center;margin-top:10px;">
                Real-time threat detection & anomaly analysis
            </div>
            <div id="osiris-alerts-list" style="margin-top: 15px; max-height: 200px; overflow-y: auto;">
                <!-- Alerts will be dynamically added here -->
            </div>
        </div>
    </aside>
    
    <!-- Kozmik Efektler Katmanı -->
    <div id="cosmic-effects-layer"></div>
    <!-- Canvas for visual effects -->
    <canvas id="effects-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;"></canvas> 
    
    <!-- Ultra Kompakt Panteon Sistemi UI -->
    <!-- This panel is now replaced by the main #panteon-panel -->
    
    <!-- Enerji Kutusu -->
    <div id="energy-box" class="side-panel left-panel energy-box">
        <div class="energy-box-header panel-header">
            <div class="energy-box-title">Sistem Enerjisi</div>
            <button class="pp-expand-btn" onclick="window.app.energyManager.toggleEnergyBox(false)">✖</button>
        </div>
        <div class="panel-body">
            <div class="energy-meter">
                <div id="energy-fill" class="energy-fill" style="width: 80%;"></div>
            </div>
            <div class="energy-info">
                <span id="energy-level">80%</span>
                <span id="energy-time">12:05:21</span>
            </div>
            <div class="energy-status" id="energy-status">Normal işleyiş sürüyor</div>
            <div class="energy-actions">
                <div class="energy-action-btn" onclick="window.app.energyManager.boostEnergy()">Güçlendir</div>
                <div class="energy-action-btn" onclick="window.app.energyManager.optimizeEnergy()">Optimize Et</div>
                <div class="energy-action-btn" onclick="window.app.energyManager.recycleEnergy()">Geri Dönüştür</div>
            </div>
        </div>
    </div>
    
    <!-- Ritüel Sistemi -->
    <div id="ritual-container" class="side-panel left-panel ritual-container hidden">
        <div class="ritual-header panel-header">
            <div class="ritual-title">
                <div class="ritual-icon"></div>
                Ritüel Sistemi
            </div>
            <button class="pp-expand-btn" onclick="window.app.ritualManager.toggleRitualContainer(false)">✖</button>
        </div>
        
        <div class="ritual-description">
            Ritüeller, piyasa gücünüzü artıran özel eylemlerdir. Her ritüel farklı etkilere ve sürelere sahiptir. Ritüeller enerji gerektirir ve aktifleştirmek için hazırlık süreci gerekir.
        </div>
        
        <div class="ritual-list" id="ritual-list">
            <!-- Ritüeller JavaScript tarafından dinamik olarak eklenecek -->
        </div>
        
        <div class="ritual-actions">
            <div class="ritual-btn" onclick="window.app.ritualManager.prepareSelectedRitual()">Hazırla</div>
            <div class="ritual-btn primary" onclick="window.app.ritualManager.activateSelectedRitual()">Aktifleştir</div>
        </div>
        
        <div class="ritual-status" id="ritual-status">
            Aktif ritüel yok. Bir ritüel seçip hazırlayın.
        </div>
    </div>

    <!-- AYARLAR MODAL -->
    <div id="settings-modal-overlay">
        <div class="settings-modal-content">
            <div class="settings-modal-header">
                <span>AYARLAR & OPTİMİZASYON</span>
                <button class="close-btn" id="close-settings-modal-btn">&times;</button>
            </div>
            <div class="settings-modal-body">
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Temel Parametreler</div>
                    <div class="form-group"><label class="form-label">Min. Uyum Skoru (1-10)</label><input type="range" id="modal-confluence-threshold" class="form-control" min="1" max="10" value="3" step="1"></div>
                    <div class="form-group"><label class="form-label">RSI Periyodu</label><input type="number" id="modal-param-rsi-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">ATR Periyodu</label><input type="number" id="modal-param-atr-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">Duvar Tespiti (BTC Miktarı)</label><input type="number" id="modal-param-wall-btc" class="form-control" value="20"></div>
                    <div class="form-group"><label class="form-label">Risk/Ödül Oranı (R/R)</label><input type="number" id="modal-param-rr-ratio" class="form-control" value="1.5" step="0.1"></div>
                </div>
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Cooldown Ayarları</div>
                    <div class="form-group"><label class="form-label">Genel Sinyal Cooldown (ms)</label><input type="number" id="modal-signal-cooldown-ms" class="form-control" value="15000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Aynı Yön Sinyal Cooldown (ms)</label><input type="number" id="modal-same-direction-cooldown-ms" class="form-control" value="30000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Yön Cooldown (ms)</label><input type="number" id="modal-opposite-direction-cooldown-ms" class="form-control" value="20000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Yön Histerezis (+Puan)</label><input type="number" id="modal-reverse-hysteresis-points" class="form-control" value="2" min="0" step="1"></div>
                    <div class="form-group"><label class="form-label">Proposal Timeout (ms)</label><input type="number" id="modal-proposal-timeout-ms" class="form-control" value="3000" min="500" step="100"></div>
                    <div class="form-group"><label class="form-label">Strateji Teklifi Cooldown (ms)</label><input type="number" id="modal-strategy-proposal-cooldown-ms" class="form-control" value="10000" min="0" step="100"></div>
                </div>
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Gelişmiş Özellikler</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-spoof-detection" class="feature-toggle" checked> Spoof Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-cusum-drift" class="feature-toggle" checked> CUSUM Sapma Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-risk-guardian" class="feature-toggle" checked> Risk Koruyucu (Kill Switch)</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-optimize" class="feature-toggle" checked> Oto-Optimizasyon</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-toggle-strat" class="feature-toggle" checked> Stratejileri Oto-Ayarla</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-breakeven-trail" class="feature-toggle" checked> Maliyete Çek/Takip Eden SL</label></div>
                    <div class="form-group"><label class="form-label">BE R Oranı</label><input type="number" id="modal-be-at-r" class="form-control" value="0.8" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing Başlangıç R Oranı</label><input type="number" id="modal-trail-after-r" class="form-control" value="1.5" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing Kârı R Oranı</label><input type="number" id="modal-trail-to-r" class="form-control" value="0.5" step="0.1"></div>
                </div>

                <!-- YENİ EKLENEN BÖLÜM BAŞLANGICI -->
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Sinyal Teyit & Gelişmiş Filtreleme</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-candle-confirm" class="feature-toggle" checked> Sinyal için Mum Kapanışını Bekle</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-mtf-confirm" class="feature-toggle" checked> Üst Zaman Dilimi Trend Teyidi</label></div>
                    <div class="form-group">
                        <label class="form-label">MTF Zaman Dilimi</label>
                        <select id="modal-mtf-timeframe" class="form-control">
                            <option value="5m">5m</option>
                            <option value="15m" selected>15m</option>
                            <option value="1h">1h</option>
                            <option value="4h">4h</option>
                        </select>
                    </div>
                     <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-dynamic-sizing" class="feature-toggle" checked> Sinyal Gücüne Göre Dinamik Boyutlandırma</label></div>
                    <hr style="border-color: var(--border-color); margin: 10px 0;">
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-tts" class="feature-toggle" checked> Sesli Bildirimler</label></div>
                    <div class="form-group">
                        <label class="form-label">Ses Seçimi</label>
                        <select id="modal-tts-voice-select" class="form-control"></select>
                    </div>
                </div>
                <!-- YENİ EKLENEN BÖLÜM SONU -->

                <div class="settings-group" style="grid-column: 1 / -1;">
                     <div class="panel-title" style="margin-bottom: 10px;">Aktif Stratejiler</div>
                    <div id="modal-strategy-toggles" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 5px;"></div>
                </div>
                <div class="settings-group" style="grid-column: 1 / -1;">
                    <div class="panel-title" style="margin-bottom: 10px;">Sinyal Geçmişi ve Analiz</div>
                    <div class="data-table-container" style="max-height: 300px;">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Zaman</th>
                                    <th>Sembol</th>
                                    <th>Tip</th>
                                    <th>Fiyat</th>
                                    <th>TP</th>
                                    <th>SL</th>
                                    <th>Skor</th>
                                    <th>Katkı</th>
                                    <th>Boyut</th>
                                    <th>Durum</th>
                                    <th>Not</th>
                                </tr>
                            </thead>
                            <tbody id="modal-signals-body"></tbody>
                        </table>
                    </div>
                    <button id="modal-clear-signals-btn" class="btn btn-danger btn-sm" style="margin-top: 10px;">Tüm Sinyalleri Sil</button>
                    <div id="modal-stats-container" style="margin-top: 15px;"></div>
                </div>
            </div>
            <div class="settings-modal-footer">
                <button id="reset-all-settings-btn" class="btn btn-danger">AYARLARI SIFIRLA</button>
                <button id="save-settings-btn" class="btn btn-success">AYARLARI KAYDET</button>
            </div>
        </div>
    </div>
    <!-- YENİ LOG PANELİ (MODAL) -->
    <div id="log-modal-overlay">
        <div class="log-modal-content">
            <div class="log-modal-header">
                <span>SİSTEM LOGLARI & GÜNLÜK</span>
                <div>
                    <button id="export-logs-btn" class="btn btn-sm btn-success">Logları Dışa Aktar</button>
                    <button class="close-btn" id="close-log-modal-btn">&times;</button>
                </div>
            </div>
            <div class="log-modal-body">
                <pre id="log-output"></pre>
            </div>
        </div>
    </div>

   

    <!-- ŞEREF TABLOSU MODAL -->
    <div id="honor-modal-overlay" style="position:fixed; inset:0; background:rgba(0,0,0,0.7); display:none; z-index:2600; align-items:center; justify-content:center;">
      <div style="background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; width:90%; max-width:900px; max-height:90%; overflow:auto;">
        <div style="padding:10px; border-bottom:1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700; color:var(--primary)">Şeref Tablosu</div>
          <button id="close-honor-modal" class="btn btn-tiny">Kapat</button>
        </div>
        <div id="honor-modal-body" style="padding:12px;"></div>
      </div>
    </div>

<script>
    // Sinyal sesleri
    function playSignal(type) {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            if (type === 'buy') {
                oscillator.type = 'triangle'; oscillator.frequency.value = 1000;
            } else if (type === 'sell') {
                oscillator.type = 'square'; oscillator.frequency.value = 400;
            } else if (type === 'combat') {
                oscillator.type = 'sawtooth'; oscillator.frequency.value = 800; 
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);
                oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 1);
                return;
            }
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5);
        } catch (error) { console.log('Ses çalınamadı:', error); }
    }
    
    // Ses sentez motoruyla gelişmiş sesli bildirim fonksiyonu
    function playSoundAlert(type, priority = 1) {
        try {
            if (!window.audioContext) {
                window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const audioContext = window.audioContext;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();
            
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Bildirim türüne göre ses ayarları
            switch (type) {
                case 'success':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(880, audioContext.currentTime + 0.1);
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 1500;
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
                    
                case 'warning':
                case 'alert':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(330, audioContext.currentTime + 0.15);
                    filterNode.type = 'bandpass';
                    filterNode.frequency.value = 500;
                    filterNode.Q.value = 3;
                    gainNode.gain.setValueAtTime(0.25 * Math.min(priority/2, 1), audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'error':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(196, audioContext.currentTime + 0.2);
                    filterNode.type = 'highpass';
                    filterNode.frequency.value = 150;
                    gainNode.gain.setValueAtTime(0.3 * Math.min(priority/2, 1), audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.6);
                    break;
                    
                case 'notification':
                default:
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 523.25; // C5
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 800;
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
            }
            
            // Yüksek öncelikli bildirimlerde ikincil ses
            if (priority >= 4) {
                setTimeout(() => {
                    const osc2 = audioContext.createOscillator();
                    const gain2 = audioContext.createGain();
                    osc2.connect(gain2);
                    gain2.connect(audioContext.destination);
                    
                    osc2.type = 'sine';
                    osc2.frequency.value = 880;
                    gain2.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    
                    osc2.start(audioContext.currentTime);
                    osc2.stop(audioContext.currentTime + 0.15);
                }, 300);
            }
            
        } catch (error) {
            console.error('Ses sentezleme hatası:', error);
        }
    }

    /* =========================
       GÖRSELLEŞTİRME YÖNETİCİLERİ
       ========================= */
        class AdvancedNotificationCenter {
        constructor(app) {
            this.app = app;
            this.container = document.getElementById('notifications-container');
            this.notifications = [];
            this.maxHistory = 50; // Maximum number of notifications to keep in history
            this.maxVisibleNotifications = 10; // How many notifications to show at once
            this.groupSimilarTimeWindow = 5000; // Group similar notifications within 5 seconds
            
            // Load history from localStorage if available
            this.loadHistory();
            
            // Create notification categories
            this.categories = {
                system: { icon: '🔧', sound: false, color: 'var(--text-secondary)' },
                trade: { icon: '📊', sound: true, color: 'var(--primary)' },
                alert: { icon: '⚠️', sound: true, color: 'var(--neutral)' },
                success: { icon: '✅', sound: true, color: 'var(--positive)' },
                error: { icon: '❌', sound: true, color: 'var(--negative)' }
            };
            
            this.soundEnabled = true;
            this.priorityThreshold = 2; // Priority level for playing sounds (1-5)
            
            // Initialize UI
            this.initStyles();
            this.initNotificationPanel();
        }
        
        initStyles() {
            // Add custom styles for notifications if not already added
            if (!document.getElementById('notification-center-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-center-styles';
                style.textContent = `
                    /* Advanced Notification Center Styles */
                    #notifications-container { 
                        top: var(--ticker-height); /* Below the ticker */
                        left: 60px; /* Positioned to the right of the vertical icon panel */
                        width: 320px; 
                        max-height: calc(100vh - var(--ticker-height) - var(--header-min-height) - 10px);
                        overflow-y: auto;
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                        padding: 10px;
                        transition: all 0.3s ease-in-out;
                        transform: translateX(-100%); /* Initially off-screen */
                        opacity: 0;
                        visibility: hidden;
                        z-index: 2000;
                        background: rgba(22, 27, 34, 0.95);
                        backdrop-filter: blur(6px);
                        border: 1px solid var(--border-color);
                        border-radius: 8px;
                        font-family: 'Roboto Mono', monospace;
                        color: var(--text-main);
                        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
                    }
                    #notifications-container.active {
                        transform: translateX(0); /* Slide in */
                        opacity: 1;
                        visibility: visible;
                    }

                    .notification { 
                        background: rgba(22, 27, 34, 0.95);
                        backdrop-filter: blur(5px);
                        border: 1px solid var(--border-color); 
                        border-left-width: 4px; 
                        border-radius: 6px; 
                        padding: 10px 12px;
                        font-size: 12px;
                        box-shadow: 0 3px 10px rgba(0,0,0,0.3); 
                        animation: slide-in 0.3s ease-out;
                        transition: opacity 0.3s ease, transform 0.3s ease;
                        overflow: hidden;
                    }

                    .notification-control-panel {
                        background: var(--panel-bg);
                        border: 1px solid var(--border-color);
                        border-radius: 4px;
                        padding: 5px 8px;
                        margin-bottom: 8px;
                    }

                    .notification-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 5px;
                        font-size: 11px;
                        font-weight: bold;
                        color: var(--text-secondary);
                    }

                    .notification-header div {
                        display: flex;
                        gap: 5px;
                    }

                    .notification-icon {
                        font-size: 14px;
                        margin-right: 8px;
                        flex-shrink: 0;
                    }

                    .notification-priority {
                        font-size: 9px;
                        color: var(--primary);
                        letter-spacing: 1px;
                    }

                    .notification-close {
                        cursor: pointer;
                        font-size: 16px;
                        line-height: 1;
                        opacity: 0.7;
                        transition: opacity 0.2s;
                    }

                    .notification-close:hover {
                        opacity: 1;
                    }

                    .notification-content {
                        flex-grow: 1;
                        line-height: 1.4;
                        word-break: break-word;
                        position: relative;
                    }

                    .notification-time {
                        font-size: 9px;
                        color: var(--text-secondary);
                        margin-top: 2px;
                    }

                    .notification-count {
                        position: absolute;
                        top: -8px;
                        right: -5px;
                        background: var(--primary);
                        color: #000;
                        border-radius: 10px;
                        padding: 1px 6px;
                        font-size: 10px;
                        font-weight: bold;
                    }

                    /* Category-specific styles */
                    .notification.system { border-left-color: var(--text-secondary); }
                    .notification.trade { border-left-color: var(--primary); }
                    .notification.alert { border-left-color: var(--neutral); }
                    .notification.success { border-left-color: var(--positive); }
                    .notification.error { border-left-color: var(--negative); }
                    
                    .high-priority {
                        border-left-width: 6px !important;
                        animation: pulse-highlight 2s infinite;
                    }

                    /* Animation keyframes */
                    @keyframes slide-in {
                        from { transform: translateX(-100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    
                    @keyframes pulse-highlight {
                        0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
                        70% { box-shadow: 0 0 0 8px rgba(255, 255, 255, 0); }
                        100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
                    }
                    
                    /* Notification history modal */
                    #notification-history-modal .modal-body {
                        max-height: 400px;
                        overflow-y: auto;
                    }
                    
                    .notification-filters {
                        display: flex;
                        gap: 5px;
                        margin-bottom: 10px;
                        flex-wrap: wrap;
                    }
                    
                    .notification-filters .filter {
                        padding: 3px 8px;
                        border-radius: 12px;
                        background: var(--panel-bg);
                        border: 1px solid var(--border-color);
                        font-size: 11px;
                        cursor: pointer;
                    }
                    
                    .notification-filters .filter.active {
                        background: var(--primary);
                        color: #000;
                    }
                    
                    #notification-history-list {
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                    }
                    
                    /* Responsive adjustments */
                    @media screen and (max-width: 768px) {
                        .notifications {
                            width: 85%;
                            max-width: 320px;
                        }
                        
                        .notification {
                            padding: 8px 10px;
                            font-size: 11px;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        initNotificationPanel() {
            // Create container if it doesn't exist
            if (!this.container) {
                this.container = document.createElement('div');
                this.container.id = 'notifications-container';
                this.container.className = 'notifications';
                document.body.appendChild(this.container);
            }
            
            // Create history modal but don't attach to DOM yet
            this.createHistoryModal();
            
            // Not adding notification control panel here anymore
            // It's now handled in the initApp() function with the vertical icon panel
        }
        
        /**
         * Create the notification history modal
         */
        createHistoryModal() {
            // Remove existing modal if any
            const existingModal = document.getElementById('notification-history-modal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'notification-history-modal';
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Bildirim Geçmişi</h3>
                        <span class="close-modal">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="notification-filters">
                            <button class="filter active" data-filter="all">Tümü</button>
                            <button class="filter" data-filter="trade">İşlem</button>
                            <button class="filter" data-filter="alert">Uyarı</button>
                            <button class="filter" data-filter="success">Başarılı</button>
                            <button class="filter" data-filter="error">Hata</button>
                            <button class="filter" data-filter="system">Sistem</button>
                        </div>
                        <div id="notification-history-list"></div>
                    </div>
                    <div class="modal-footer">
                        <button id="clear-notifications-history" class="btn btn-danger">Geçmişi Temizle</button>
                    </div>
                </div>
            `;
            
            // Append to body but keep it hidden
            document.body.appendChild(modal);
            
            // Add event listeners
            const closeBtn = modal.querySelector('.close-modal');
            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });
            
            const filters = modal.querySelectorAll('.filter');
            filters.forEach(filter => {
                filter.addEventListener('click', (e) => {
                    filters.forEach(f => f.classList.remove('active'));
                    e.target.classList.add('active');
                    this.filterHistory(e.target.getAttribute('data-filter'));
                });
            });
            
            document.getElementById('clear-notifications-history').addEventListener('click', () => {
                this.clearHistory();
                this.notify('Bildirim geçmişi temizlendi', 'system', 1);
                modal.style.display = 'none';
            });
        }
        
        /**
         * Display a new notification
         * @param {string} message - The notification message
         * @param {string} category - Notification category (system, trade, alert, success, error)
         * @param {number} priority - Priority level (1-5)
         * @param {number} timeout - How long to display (ms)
         */
        notify(message, category = 'system', priority = 2, timeout = 5000) {
            if (!this.container) return;
            
            // Default category if invalid
            if (!this.categories[category]) category = 'system';
            
            // Check for similar recent notifications to avoid spam
            if (this.shouldGroupWithSimilar(message, category)) {
                return;
            }
            
            // Generate unique ID
            const notificationId = 'notify-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);
            const timestamp = new Date();
            
            // Create notification element
            const notification = document.createElement('div');
            notification.id = notificationId;
            notification.className = `notification ${category}`;
            notification.setAttribute('data-id', notificationId);
            if (priority >= 4) notification.classList.add('high-priority');
            
            // Build notification content
            const catInfo = this.categories[category];
            notification.innerHTML = `
                <div class="notification-header">
                    <span class="notification-icon">${catInfo.icon}</span>
                    <span class="notification-priority">${'•'.repeat(priority)}</span>
                    <span class="notification-close">&times;</span>
                </div>
                <div class="notification-content">
                    ${message}
                    <div class="notification-time">${timestamp.toLocaleTimeString()}</div>
                </div>
            `;
            
            // Add to DOM
            this.container.prepend(notification); // Prepend to show newest at top
            
            // Add to history
            this.addToHistory({
                id: notificationId,
                message,
                category,
                priority,
                timestamp: timestamp.getTime()
            });
            
            // Play sound for high priority notifications
            if (this.soundEnabled && priority >= this.priorityThreshold) {
                this.playNotificationSound(category, priority);
            }
            
            // Add close event
            const closeBtn = notification.querySelector('.notification-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    notification.remove();
                });
            }
            
            // Clean up old notifications
            this.cleanupOldNotifications();
            
            // Auto-remove after timeout
            setTimeout(() => {
                if (notification.parentNode) {
                    // Add fade-out animation
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(-100%)';
                    setTimeout(() => notification.remove(), 300);
                }
            }, timeout);
            
            return notification;
        }
        
        /**
         * Determine if a similar notification was recently shown
         */
        shouldGroupWithSimilar(message, category) {
            const now = Date.now();
            const similar = this.notifications.find(n => 
                n.category === category && 
                this.isSimilarMessage(n.message, message) && 
                (now - n.timestamp < this.groupSimilarTimeWindow)
            );
            
            if (similar) {
                // Update the existing notification instead of creating a new one
                const existingNotification = document.querySelector(`.notification.${category}[data-id="${similar.id}"]`);
                if (existingNotification) {
                    const countBadge = existingNotification.querySelector('.notification-count');
                    if (countBadge) {
                        countBadge.textContent = (parseInt(countBadge.textContent) || 1) + 1;
                    } else {
                        const contentDiv = existingNotification.querySelector('.notification-content');
                        if (contentDiv) {
                            contentDiv.innerHTML += `<span class="notification-count">2</span>`;
                        }
                    }
                    // Reset the timestamp for this notification
                    similar.timestamp = now;
                    return true;
                }
            }
            
            return false;
        }
        
        /**
         * Compare messages for similarity
         */
        isSimilarMessage(msg1, msg2) {
            // Basic similarity check - can be enhanced with more sophisticated comparison
            if (msg1 === msg2) return true;
            
            // Check for pattern-based similarities (e.g., only numbers differ)
            const normalized1 = msg1.replace(/\d+(\.\d+)?%?/g, 'X');
            const normalized2 = msg2.replace(/\d+(\.\d+)?%?/g, 'X');
            
            return normalized1 === normalized2;
        }
        
        /**
         * Add notification to history and save
         */
        addToHistory(notification) {
            // Add to history array
            this.notifications.unshift(notification);
            
            // Trim history if needed
            if (this.notifications.length > this.maxHistory) {
                this.notifications = this.notifications.slice(0, this.maxHistory);
            }
            
            // Save to localStorage
            this.saveHistory();
        }
        
        /**
         * Play sound notification
         */
        playNotificationSound(category, priority) {
            try {
                // Try to use app's built-in sound if available
                if (this.app.settings?.features?.enableTts && priority >= 3 && this.categories[category].sound) {
                    if (typeof this.app.playSignal === 'function') {
                        // Use existing signal player if available
                        if (category === 'error' || category === 'alert') {
                            this.app.playSignal('alert');
                        } else if (category === 'success' || category === 'trade') {
                            this.app.playSignal('combat');
                        }
                        return;
                    }
                }
                
                // Fallback to Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Different sounds for different categories
                switch(category) {
                    case 'success':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(1320, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'alert':
                    case 'error':
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(330, audioContext.currentTime + 0.15);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                    case 'trade':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(priority >= 4 ? 880 : 440, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    default:
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 440;
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.1);
                }
            } catch (error) {
                console.error('Bildirim sesi çalınamadı:', error);
            }
        }
        
        /**
         * Remove old notifications to maintain visibility limit
         */
        cleanupOldNotifications() {
            // Get all current notification elements (excluding control panel)
            const notifElements = Array.from(this.container.querySelectorAll('.notification')).filter(
                el => !el.classList.contains('notification-control-panel')
            );
            
            // If we're over the limit, remove oldest ones
            if (notifElements.length > this.maxVisibleNotifications) {
                const toRemove = notifElements.slice(this.maxVisibleNotifications);
                toRemove.forEach(el => el.remove());
            }
        }
        
        /**
         * Clear all visible notifications
         */
        clearAll() {
            const notifications = this.container.querySelectorAll('.notification');
            notifications.forEach(notification => {
                // Don't remove the control panel
                if (!notification.classList.contains('notification-control-panel')) {
                    notification.remove();
                }
            });
        }
        
        /**
         * Clear notification history and save
         */
        clearHistory() {
            this.notifications = [];
            this.saveHistory();
        }
        
        /**
         * Save notification history to localStorage
         */
        saveHistory() {
            try {
                localStorage.setItem('utc_notifications', JSON.stringify(this.notifications));
            } catch (e) {
                console.error('Failed to save notification history', e);
            }
        }
        
        /**
         * Load notification history from localStorage
         */
        loadHistory() {
            try {
                const saved = localStorage.getItem('utc_notifications');
                if (saved) {
                    this.notifications = JSON.parse(saved);
                    
                    // Convert date strings back to Date objects
                    this.notifications.forEach(n => {
                        if (typeof n.timestamp === 'string') {
                            n.timestamp = new Date(n.timestamp).getTime();
                        }
                    });
                }
            } catch (e) {
                console.error('Failed to load notification history', e);
                this.notifications = [];
            }
        }
        
        /**
         * Show notification history in a modal
         */
        showHistory() {
            const modal = document.getElementById('notification-history-modal');
            if (!modal) return;
            
            // Update the history list
            this.filterHistory('all');
            
            // Show the modal
            modal.style.display = 'block';
        }
        
        /**
         * Filter history by category
         */
        filterHistory(filter = 'all') {
            const historyList = document.getElementById('notification-history-list');
            if (!historyList) return;
            
            // Clear current list
            historyList.innerHTML = '';
            
            // Filter notifications
            const filtered = filter === 'all' 
                ? [...this.notifications]
                : this.notifications.filter(n => n.category === filter);
            
            if (filtered.length === 0) {
                historyList.innerHTML = '<div class="empty-state">Bu kategoride bildirim bulunmuyor.</div>';
                return;
            }
            
            // Add notifications to history list
            filtered.forEach(n => {
                const item = document.createElement('div');
                item.className = `notification ${n.category}`;
                
                const catInfo = this.categories[n.category] || this.categories.system;
                const date = new Date(n.timestamp);
                const dateStr = date.toLocaleString();
                
                item.innerHTML = `
                    <div class="notification-header">
                        <span class="notification-icon">${catInfo.icon}</span>
                        <span class="notification-priority">${'•'.repeat(n.priority || 1)}</span>
                    </div>
                    <div class="notification-content">
                        ${n.message}
                        <div class="notification-time">${dateStr}</div>
                    </div>
                `;
                
                historyList.appendChild(item);
            });
        }
    }

    class ChartManager {
        constructor(chartContainerId) {
            this.chartContainer = document.getElementById(chartContainerId);
            if (!this.chartContainer) throw new Error("Chart container bulunamadı!");
            this.chart = null; this.series = {}; this.signalMarkers = [];
            this.bbandsSeries = null;
            this._initChart();
            this.trendVisualizationEnhanced = false; // Ritual effect
        }
        _initChart() {
            this.chart = LightweightCharts.createChart(this.chartContainer, this._getChartOptions());
            this.series.candles = this.chart.addCandlestickSeries(this._getCandlestickOptions());
            this.series.volume = this.chart.addHistogramSeries(this._getVolumeOptions());
            
            const lineStyle = { color: 'rgba(255, 255, 0, 0.6)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted };
            this.series.bbUpper = this.chart.addLineSeries(lineStyle);
            this.series.bbMiddle = this.chart.addLineSeries(lineStyle);
            this.series.bbLower = this.chart.addLineSeries(lineStyle);

            window.addEventListener('resize', () => { 
                if (this.chart && this.chartContainer.clientWidth > 0 && this.chartContainer.clientHeight > 0) {
                    this.chart.resize(this.chartContainer.clientWidth, this.chartContainer.clientHeight);
                }
            });

            // --- YENİ: Grafik görünümünü kaydetmek için olay dinleyici ---
            this.chart.timeScale().subscribeVisibleLogicalRangeChange(logicalRange => {
                if (logicalRange) {
                    localStorage.setItem('utc_chart_view', JSON.stringify(logicalRange));
                }
            });
        }

        // --- YENİ: Kaydedilmiş görünümü geri yükleme fonksiyonu ---
        restoreView() {
            const savedView = localStorage.getItem('utc_chart_view');
            if (savedView) {
                try {
                    const logicalRange = JSON.parse(savedView);
                    this.chart.timeScale().setVisibleLogicalRange(logicalRange);
                } catch (e) {
                    console.error("Kaydedilmiş grafik görünümü yüklenemedi:", e);
                    this.chart.timeScale().fitContent();
                }
            } else {
                this.chart.timeScale().fitContent();
            }
        }

        updateTheme() {
            if(!this.chart) return;
            this.chart.applyOptions(this._getChartOptions());
            this.series.candles.applyOptions(this._getCandlestickOptions());
            this.series.volume.applyOptions(this._getVolumeOptions());
            const lineStyle = { color: 'rgba(255, 255, 0, 0.6)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted };
            this.series.bbUpper.applyOptions(lineStyle);
            this.series.bbMiddle.applyOptions(lineStyle);
            this.series.bbLower.applyOptions(lineStyle);
        }
        setData(candles) {
            if (!this.series.candles) return;
            const candleData = candles.map(c => ({ time: c.time / 1000, open: c.open, high: c.high, low: c.low, close: c.close }));
            const volumeData = candles.map(c => ({ time: c.time / 1000, value: c.volume, color: c.close >= c.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' }));
            this.series.candles.setData(candleData);
            this.series.volume.setData(volumeData);
            
            // --- DÜZELTME: Veri yüklendikten sonra kaydedilmiş görünümü uygula ---
            this.restoreView();
        }

        drawBollingerBands(bbandsData) {
            if (!this.series.bbUpper || !bbandsData) return;
            const mapToChartTime = (d) => ({ time: d.time / 1000, value: d.value });
            this.series.bbUpper.setData(bbandsData.upper.map(mapToChartTime));
            this.series.bbMiddle.setData(bbandsData.middle.map(mapToChartTime));
            this.series.bbLower.setData(bbandsData.lower.map(mapToChartTime));
        }

        updateRealtime(kline) {
             if (!this.series.candles) return;
             const candle = { time: kline.t / 1000, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c) };
             const volume = { time: kline.t / 1000, value: parseFloat(kline.v), color: candle.close >= candle.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' };
             this.series.candles.update(candle);
             this.series.volume.update(volume);
        }
        addSignalMarker(signal) {
            if (!this.series.candles) return;
            const styles = getComputedStyle(document.body);
            const isMobile = window.innerWidth <= 768;
            let text = '';

            if (isMobile) {
                text = `S:${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score}`;
            } else {
                text = `Skor: ${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score} @ ${this._formatMarkerPrice(signal.price)}`;
                if (signal.recommendedSize) {
                    text += ` | ${signal.recommendedSize}`;
                }
            }

            const marker = {
                id: signal.id,
                time: signal.timestamp / 1000,
                position: signal.direction === 'buy' ? 'belowBar' : 'aboveBar',
                color: signal.direction === 'buy' ? styles.getPropertyValue('--positive').trim() : styles.getPropertyValue('--negative').trim(),
                shape: signal.direction === 'buy' ? 'arrowUp' : 'arrowDown',
                text: text
            };
            if (signal.status === 'pending') {
                marker.color = styles.getPropertyValue('--neutral').trim();
                marker.shape = 'circle';
            }
            
            this.signalMarkers = this.signalMarkers.filter(m => m.id !== signal.id);
            this.signalMarkers.push(marker);
            this.series.candles.setMarkers(this.signalMarkers);
        }
        clearMarkers() { if (!this.series.candles) return; this.signalMarkers = []; this.series.candles.setMarkers([]); }
        zoom(factor) {
            if (!this.chart) return;
            const timeScale = this.chart.timeScale();
            const currentLogicalRange = timeScale.getVisibleLogicalRange();
            if (!currentLogicalRange) return;
            const newLogicalRange = { from: currentLogicalRange.from * factor, to: currentLogicalRange.to * factor };
            timeScale.setVisibleLogicalRange(newLogicalRange);
        }
        zoomIn() { this.zoom(0.9); }
        zoomOut() { this.zoom(1.1); }
        resetZoom() { 
            if (this.chart) {
                this.chart.timeScale().fitContent(); 
                // --- YENİ: Sıfırlama sonrası hafızayı da temizle ---
                localStorage.removeItem('utc_chart_view');
            }
        }
        
        getPriceCoordinateForTimestamp(timestamp) {
            if (!this.chart || !this.series.candles) return null;
            const timeScale = this.chart.timeScale();
            const priceScale = this.series.candles.priceScale();

            const logicalPoint = timeScale.timeToLogical(timestamp / 1000);
            if (logicalPoint === null) return null;

            const coordinate = timeScale.logicalToCoordinate(logicalPoint);
            const price = this.series.candles.data().find(d => d.time === timestamp / 1000)?.close;
            if (price === undefined) return null;

            const priceCoordinate = priceScale.priceToCoordinate(price);

            return { x: coordinate, y: priceCoordinate };
        }

        _getDecimalPlacesBasedOnPrice(price) { if(!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _formatMarkerPrice(price) { const d = this._getDecimalPlacesBasedOnPrice(price); return price.toFixed(d); }
        _getChartOptions() {
            const styles = getComputedStyle(document.body);
            return {
                width: this.chartContainer.clientWidth, height: this.chartContainer.clientHeight,
                layout: { backgroundColor: 'transparent', textColor: styles.getPropertyValue('--text-main').trim(), fontFamily: "'Roboto Mono', monospace" },
                grid: { vertLines: { color: styles.getPropertyValue('--border-color').trim() }, horzLines: { color: styles.getPropertyValue('--border-color').trim() } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { borderColor: styles.getPropertyValue('--border-color').trim(), timeVisible: true, secondsVisible: false, rightOffset: 10 }
            };
        }
        _getCandlestickOptions() {
             const styles = getComputedStyle(document.body);
             return { 
                upColor: styles.getPropertyValue('--positive').trim(), downColor: styles.getPropertyValue('--negative').trim(),
                borderVisible: false, wickUpColor: styles.getPropertyValue('--positive').trim(), wickDownColor: styles.getPropertyValue('--negative').trim(),
                priceFormat: { type: 'price', precision: 6, minMove: 0.000001 }
             };
        }
        _getVolumeOptions() { return { priceFormat: { type: 'volume' }, priceScaleId: '', scaleMargins: { top: 0.8, bottom: 0 } }; }
    }


    class HeatmapManager {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            if (!this.canvas) throw new Error("Heatmap canvas bulunamadı!");
            this.ctx = this.canvas.getContext('2d');
            this._resizeCanvas();
            window.addEventListener('resize', () => this._resizeCanvas());
            this.liquiditySensitivity = 1.0; // Ritual effect
        }
        draw(orderBook, symbolPrice) {
            if (!orderBook.bids || !Array.isArray(orderBook.bids) || orderBook.bids.length === 0 || !orderBook.asks || !Array.isArray(orderBook.asks) || orderBook.asks.length === 0) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                return;
            }
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            const asks = orderBook.asks.slice().reverse(); const bids = orderBook.bids;
            const allLevels = [...bids, ...asks]; const maxQty = Math.max(...allLevels.map(l => l[1]));
            this._drawSection(asks, 'asks', maxQty, symbolPrice); this._drawSection(bids, 'bids', maxQty, symbolPrice);
        }
        updateTheme() { this._resizeCanvas(); }
        _drawSection(levels, type, maxQty, symbolPrice) {
            const styles = getComputedStyle(document.body);
            const baseColor = type === 'asks' ? styles.getPropertyValue('--negative').trim() : styles.getPropertyValue('--positive').trim();
            if (levels.length === 0) return;
            const heightPerLevel = (this.canvas.height / 2) / levels.length;
            const priceDecimals = this._getDecimalPlaces(symbolPrice);
            const labelSkipInterval = heightPerLevel < 12 ? Math.ceil(12 / heightPerLevel) : 1;
            levels.forEach((level, index) => {
                const [price, qty] = level;
                const intensity = Math.min(Math.sqrt(qty / maxQty), 1.0) * this.liquiditySensitivity; // Apply sensitivity
                this.ctx.fillStyle = this._hexToRgba(baseColor, intensity * 0.6 + 0.1);
                const y = type === 'asks' ? index * heightPerLevel : (this.canvas.height / 2) + (index * heightPerLevel);
                const barWidth = this.canvas.width * intensity;
                this.ctx.fillRect(0, y, barWidth, heightPerLevel);
                if (index % labelSkipInterval === 0) {
                    this.ctx.fillStyle = intensity > 0.5 ? '#FFFFFF' : styles.getPropertyValue('--text-secondary').trim();
                    this.ctx.font = '10px "Roboto Mono"'; this.ctx.textAlign = 'left';
                    this.ctx.fillText(`${(qty).toFixed(2)} @ ${price.toFixed(priceDecimals)}`, 10, y + heightPerLevel - 3);
                }
            });
        }
        _getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _hexToRgba(hex, alpha) {
            if(!hex.startsWith('#')) return `rgba(120,120,120,${alpha})`;
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        _resizeCanvas() { 
            if(this.canvas.parentElement) {
                this.canvas.width = this.canvas.parentElement.clientWidth; 
                this.canvas.height = this.canvas.parentElement.clientHeight; 
            }
        }
    }

    /* =========================
       GELİŞMİŞ ÖZELLİK YÖNETİCİLERİ
       ========================= */

    // Çoklu Zaman Dilimi Yöneticisi (Multi-Timeframe Manager) - Gelişmiş
    class LegacyMultiTimeframeManager {
        constructor(bot) {
            this.bot = bot;
            this.data = {}; // { '1h': { candles: [], ema20: null }, '15m': { ... } }
            this.intervals = {};
            this.isInitialized = false;
        }

        async initialize(symbol, timeframes = []) {
            if (this.isInitialized) this.cleanup();
            this.isInitialized = true;
            this.bot.logToJournal(`MTF Manager başlatılıyor: ${timeframes.join(', ')}`);
            for (const tf of timeframes) {
                this.data[tf] = { candles: [], ema20: null };
                await this.fetchHistoricalData(symbol, tf);
                this.intervals[tf] = setInterval(() => this.fetchRealtimeData(symbol, tf), this._timeframeToMs(tf));
            }
        }

        async fetchHistoricalData(symbol, timeframe) {
            try {
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${timeframe}&limit=100`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`API Hatası: ${response.statusText}`);
                const data = await response.json();
                this.data[timeframe].candles = data.map(d => ({ time: d[0], close: parseFloat(d[4]) }));
                this.calculateIndicators(timeframe);
                this.bot.logToJournal(`${timeframe} için ${this.data[timeframe].candles.length} mum yüklendi.`);
            } catch (error) {
                console.error(`MTF geçmiş veri hatası (${timeframe}):`, error);
            }
        }

        async fetchRealtimeData(symbol, timeframe) {
            try {
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${timeframe}&limit=2`;
                const response = await fetch(url);
                if (!response.ok) return;
                const data = await response.json();
                const newCandle = { time: data[0][0], close: parseFloat(data[0][4]) };
                const lastCandle = this.data[timeframe].candles[this.data[timeframe].candles.length - 1];
                if (lastCandle && lastCandle.time === newCandle.time) {
                    this.data[timeframe].candles[this.data[timeframe].candles.length - 1] = newCandle;
                } else {
                    this.data[timeframe].candles.push(newCandle);
                    if(this.data[timeframe].candles.length > 101) this.data[timeframe].candles.shift();
                }
                this.calculateIndicators(timeframe);
            } catch (error) {
                 console.error(`MTF anlık veri hatası (${timeframe}):`, error);
            }
        }
        
        calculateIndicators(timeframe) {
            const candles = this.data[timeframe]?.candles;
            if (!candles || candles.length < 20) return;
            const closes = candles.map(c => c.close);
            this.data[timeframe].ema20 = this._calculateEMA(closes, 20);
        }

        _calculateEMA(prices, period) {
            const k = 2 / (period + 1);
            let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < prices.length; i++) {
                ema = (prices[i] * k) + (ema * (1 - k));
            }
            return ema;
        }

        getTrend(timeframe) {
            const tfData = this.data[timeframe];
            if (!tfData || !tfData.ema20) return 'neutral';
            
            const price = this.bot.marketData.price;
            const ema = tfData.ema20;
            if (!price || !ema) return 'neutral';

            const diff = Math.abs(price - ema) / ema;
            
            // Belirsizlik durumu için eşik değer (%0.1)
            if (diff < 0.001) return 'neutral';
            
            return price > ema ? 'up' : 'down';
        }
        
        _timeframeToMs(tf) {
            const unit = tf.slice(-1);
            const val = parseInt(tf.slice(0, -1));
            if (unit === 'm') return val * 60 * 1000;
            if (unit === 'h') return val * 60 * 60 * 1000;
            return 60000;
        }

        cleanup() {
            this.isInitialized = false;
            Object.values(this.intervals).forEach(clearInterval);
            this.data = {};
            this.intervals = {};
            this.bot.logToJournal("MTF Manager durduruldu ve temizlendi.");
        }
    }

    // Sahte Emir Tespiti (Spoof Detector)
        class SpoofDetector {
        constructor(bot) {
            this.bot = bot;
            // --- YENİ OPTİMİZASYON DEĞİŞKENLERİ ---
            this.largeOrderThreshold = 10; // BTC cinsinden BAŞLANGIÇ eşiği
            this.pendingChecks = []; // Onay bekleyen tespitler
            this.confirmationStats = { confirmed: 0, rejected: 0 }; // İstatistikler
            // --- BİTTİ ---
            this.trackedOrders = new Map();
            this.NOTIFICATION_COOLDOWN_MS = 30000;
            this.lastNotificationTime = 0;
            this.PRICE_PROXIMITY_PERCENT = 0.0005;
            this.threshold = 20; // Ritual effect for spoofing
        }

        trackOrderBook(orderBook) {
            const now = Date.now();
            const currentBids = new Map(orderBook.bids.map(([p, q]) => [p, q]));
            const currentAsks = new Map(orderBook.asks.map(([p, q]) => [p, q]));
            this._detectSpoofing(now, currentBids, currentAsks);
            this._trackNewLargeOrders(now, orderBook);
        }

        _detectSpoofing(now, currentBids, currentAsks) {
            const ordersToDelete = [];
            for (const [price, order] of this.trackedOrders.entries()) {
                if (now - order.timestamp > 15000) {
                    ordersToDelete.push(price);
                    continue;
                }
                const book = order.type === 'bid' ? currentBids : currentAsks;
                const priceTolerance = price * this.PRICE_PROXIMITY_PERCENT;
                let stillExists = false;
                for (const [currentPrice, currentQty] of book.entries()) {
                    if (Math.abs(currentPrice - price) <= priceTolerance) {
                        if (currentQty >= order.qty * 0.8) {
                            stillExists = true;
                            break;
                        }
                    }
                }
                if (!stillExists) {
                    if (now - this.lastNotificationTime > this.NOTIFICATION_COOLDOWN_MS) {
                        let notificationText = '';
                        let ttsKey = '';
                        let expectedDirection = '';

                        if (order.type === 'bid') {
                            notificationText = `Sahte Alış Emri Çekildi! Düşüş gelebilir. Dikkat et hacı abi.`;
                            ttsKey = 'spoofBidRemoved';
                            expectedDirection = 'down';
                        } else {
                            notificationText = `Sahte Satış Emri Çekildi! Alım gelebilir. Dikkat et komutanım.`;
                            ttsKey = 'spoofAskRemoved';
                            expectedDirection = 'up';
                        }

                        this.bot.showNotification(notificationText, 'warning');
                        this.bot.speak(this.bot.getRandomMessage(ttsKey));
                        
                        // --- YENİ: TESPİTİ ONAY İÇİN KAYDET ---
                        this.pendingChecks.push({
                            timestamp: now,
                            priceAtDetection: this.bot.marketData.price,
                            expectedDirection: expectedDirection,
                            checkAfterCandles: 5 // 5 mum sonra kontrol et
                        });
                        // --- BİTTİ ---

                        this.lastNotificationTime = now;
                    }
                    ordersToDelete.push(price);
                }
            }
            ordersToDelete.forEach(price => this.trackedOrders.delete(price));
        }

        _trackNewLargeOrders(now, orderBook) {
            const processBook = (book, type) => {
                for (const [price, qty] of book) {
                    const btcValue = (this.bot.currentSymbol === 'BTCUSDT') ?
                        qty :
                        (qty * price) / (this.bot.marketData.btcPrice || 70000);
                    if (btcValue > this.largeOrderThreshold) { // Değişken eşiği kullan
                        if (!this.trackedOrders.has(price)) {
                            this.trackedOrders.set(price, { qty, timestamp: now, type });
                        }
                    }
                }
            };
            processBook(orderBook.bids, 'bid');
            processBook(orderBook.asks, 'ask');
        }

        // --- YENİ OPTİMİZASYON FONKSİYONLARI ---
        checkConfirmations() {
            const candleCount = this.bot.candles.length;
            if (candleCount < 10) return;

            this.pendingChecks = this.pendingChecks.filter(check => {
                const candlesSince = candleCount - this.bot.candles.findIndex(c => c.time >= check.timestamp);
                if (candlesSince < check.checkAfterCandles) {
                    return true; // Henüz kontrol zamanı gelmedi, listede kalsın
                }

                const priceNow = this.bot.candles[candleCount - 1].close;
                const priceChange = (priceNow - check.priceAtDetection) / check.priceAtDetection;
                
                let confirmed = false;
                if (check.expectedDirection === 'up' && priceChange > 0.001) { // %0.1'den fazla yükseldiyse
                    confirmed = true;
                } else if (check.expectedDirection === 'down' && priceChange < -0.001) { // %0.1'den fazla düştüyse
                    confirmed = true;
                }

                if (confirmed) {
                    this.confirmationStats.confirmed++;
                } else {
                    this.confirmationStats.rejected++;
                }
                return false; // Kontrol edildi, listeden kaldır
            });
        }

        autoOptimizeThreshold() {
            const totalChecks = this.confirmationStats.confirmed + this.confirmationStats.rejected;
            if (totalChecks < 10) return; // Yeterli veri birikene kadar bekle

            const rejectionRate = this.confirmationStats.rejected / totalChecks;

            if (rejectionRate > 0.6) { // Reddedilme oranı %60'tan fazlaysa (çok hassas)
                this.largeOrderThreshold *= 1.10; // Eşiği %10 artır (daha az hassas yap)
                this.bot.logToJournal(`Spoof Detector optimizasyonu: Eşik ${this.largeOrderThreshold.toFixed(2)} BTC'ye yükseltildi.`);
            } else if (rejectionRate < 0.3) { // Reddedilme oranı %30'dan azsa (çok kaba olabilir)
                this.largeOrderThreshold *= 0.95; // Eşiği %5 düşür (daha hassas yap)
                this.bot.logToJournal(`Spoof Detector optimizasyonu: Eşik ${this.largeOrderThreshold.toFixed(2)} BTC'ye düşürüldü.`);
            }

            // Eşiğin mantıklı sınırlar içinde kalmasını sağla
            this.largeOrderThreshold = Math.max(5, Math.min(50, this.largeOrderThreshold));

            // İstatistikleri sıfırla ki yeni eşikle tekrar ölçüm yapılsın
            this.confirmationStats = { confirmed: 0, rejected: 0 };
        }
        // --- BİTTİ ---
    }



    // CUSUM Sapma Tespiti (CUSUM Drift Detector)
    class CUSUMDriftDetector {
        constructor() {
            this.K = 0.5;
            this.H = 3;
            this.Cp = 0;
            this.Cn = 0;
            this.dataPoints = 0; 
        }
        update(isWin) {
            this.dataPoints++;
            const Xn = isWin ? 1 : 0;
            this.Cp = Math.max(0, this.Cp + (Xn - this.K));
            this.Cn = Math.max(0, this.Cn + ((1 - Xn) - this.K));
            let driftDetected = false;
            if (this.Cp > this.H) { driftDetected = false; this.reset(); }
            if (this.Cn > this.H) { driftDetected = true; this.reset(); }
            return driftDetected;
        }
        reset() { this.Cp = 0; this.Cn = 0; this.dataPoints = 0; }
    }

    // Piyasa Seans Profilleri (Session Profiler)
    class SessionProfiler {
        constructor(bot) { // bot instance'ını alması için constructor'a eklendi
            this.bot = bot;
            this.sessions = {
                'asia': { start: 0, end: 8, name: 'Asya' },
                'europe': { start: 8, end: 13, name: 'Avrupa' },
                'america': { start: 13, end: 22, name: 'Amerika' },
                'overlap': { start: 13, end: 16, name: 'Avr-Ame Çakışması' },
                'transition': { start: 22, end: 24, name: 'Geçiş' }
            };
        }
        getCurrentSession() {
            const now = new Date();
            const utcHour = now.getUTCHours();
            if (utcHour >= this.sessions.overlap.start && utcHour < this.sessions.overlap.end) return this.sessions.overlap.name;
            else if (utcHour >= this.sessions.america.start && utcHour < this.sessions.america.end) return this.sessions.america.name;
            else if (utcHour >= this.sessions.europe.start && utcHour < this.sessions.europe.end) return this.sessions.europe.name;
            else if (utcHour >= this.sessions.asia.start && utcHour < this.sessions.asia.end) return this.sessions.asia.name;
            else return this.sessions.transition.name;
        }
    }

    // Risk Koruyucu (Risk Guardian - Kill Switch)
    class RiskGuardian {
        constructor(bot) {
            this.bot = bot;
            this.killSwitchActivated = false;
        }
        checkKillSwitch() {
            // DÜZELTME: Kill switch aktifse, yeni teklifleri anında temizle
            if (this.killSwitchActivated) {
                if (this.bot.confluenceEngine.proposals.length > 0) {
                    this.bot.confluenceEngine.proposals = [];
                }
                return true; // Aktifse başka kontrol yapma
            }

            if (!this.bot.settings.features.enableRiskGuardian) {
                this.killSwitchActivated = false; return false;
            }
            const totalSignals = this.bot.stats.total;
            const tpSignals = this.bot.stats.tp;
            const winRate = totalSignals > 0 ? (tpSignals / totalSignals) * 100 : 100; // Başlangıçta 100 kabul et
            
            // Güvenlik kontrolü - riskGuardian ayarları yoksa veya killSwitchWinRate tanımlı değilse varsayılan değeri kullan
            const riskSettings = this.bot.settings.riskGuardian || {};
            const drawdownWinRateThreshold = riskSettings.killSwitchWinRate || 35.0; // Default threshold
            
            if (totalSignals >= 10 && winRate < drawdownWinRateThreshold && !this.killSwitchActivated) {
                this.killSwitchActivated = true;
                this.bot.showNotification(`!!! ACİL DURDURMA !!! Kazanma oranı ${winRate.toFixed(1)}% (${drawdownWinRateThreshold}% altı). Sistem durduruldu.`, 'danger');
                this.bot.speak(`Uyarı! Acil durdurma Protokolü aktif edildi. Kazanma oranı eşiğin altında. Sistemi acilen kontrol edin.`);
                this.bot.stop();
                return true;
            }
            return false;
        }
    }

    /* =========================
       STRATEJİLER (YENİ VE MEVCUT)
       ========================= */
    class Strategy {
        constructor(bot, name) { 
            this.bot = bot; this.name = name; this.displayName = this._getDisplayName(name); 
            this.lastProposalTime = {};
            this.DEFAULT_PROPOSAL_COOLDOWN_MS = 10000;
            this._isLive = false;
        }
        setIsLive(status) { this._isLive = status; }
        propose(symbol, direction, reason, score) {
            try {
                if (!this.bot.strategyStats[this.name] || !this.bot.strategyStats[this.name].overall) {
                    const baseStat = { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0, shadowWins: 0, shadowLosses: 0, shadowProposals: 0, lastUpdate: Date.now() };
                    this.bot.strategyStats[this.name] = {
                        overall: { ...baseStat },
                        trend: { ...baseStat },
                        range: { ...baseStat },
                        transition: { ...baseStat }
                    };
                }
                const stratStats = this.bot.strategyStats[this.name];

                stratStats.overall.proposals = (stratStats.overall.proposals || 0) + 1;
                stratStats.overall.lastUpdate = Date.now();
                this.bot.saveStrategyStats();

                if (!this._isLive) {
                    this.bot.recordShadowProposal(this.name, direction, reason, score);
                    return;
                }
                if (this.bot.settings.features.enableRiskGuardian && this.bot.riskGuardian.killSwitchActivated) return;

                const now = Date.now();
                const key = `${symbol}-${direction}`;
                const cooldown = (this.DEFAULT_PROPOSAL_COOLDOWN_MS ?? 10000);
                if (now - (this.lastProposalTime[key] || 0) < cooldown) return;
                this.bot.confluenceEngine.propose(this.name, direction, reason, score);
                this.lastProposalTime[key] = now;
            } catch (error) {
                console.error(`[${this.name}] Propose Error:`, error);
            }
        }

        _getDisplayName(name) { return name.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()); }
        analyzeOrderBook(orderBook) {}
        processTrade(trade) {}
        periodicAnalyze() {}
    }

    class WallBounceStrategy extends Strategy {
        constructor(bot) { super(bot, 'wallBounce'); this.DISTANCE_THRESHOLD_PERCENT = 0.05 / 100; }
        analyzeOrderBook(orderBook) {
            const currentPrice = this.bot.marketData.price; if (!currentPrice) return;
            const btcPrice = this.bot.marketData.btcPrice || 70000;
            const wallQuantityThreshold = (this.bot.settings.params.wallBtc * btcPrice) / currentPrice;
            for (const [price, qty] of orderBook.asks) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (price - currentPrice) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'sell', `Satış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
            for (const [price, qty] of orderBook.bids) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (currentPrice - price) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'buy', `Alış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
        }
    }
    class VelocityScalpingStrategy extends Strategy {
        constructor(bot) { super(bot, 'velocityScalping'); this.pricePoints = []; this.VELOCITY_WINDOW_MS = 2000; this.MIN_POINTS = 20; this.VELOCITY_THRESHOLD_PERCENT = 0.10 / 100; }
        processTrade(trade) {
            const now = Date.now(); 
            this.pricePoints.push({ time: now, price: trade.price }); 
            this.pricePoints = this.pricePoints.filter(p => now - p.time < this.VELOCITY_WINDOW_MS); 
            if (this.pricePoints.length < this.MIN_POINTS) return;
            const firstPoint = this.pricePoints[0]; const lastPoint = this.pricePoints[this.pricePoints.length - 1]; 
            const priceChange = (lastPoint.price - firstPoint.price) / firstPoint.price;
            if (priceChange > this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'buy', `Fiyat Hızı: +${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            } else if (priceChange < -this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'sell', `Fiyat Hızı: ${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            }
        }
    }
    class RsiDivergenceStrategy extends Strategy {
        constructor(bot) { super(bot, 'rsiDivergence'); }
        periodicAnalyze() {
            const candles = this.bot.candles; const rsiValues = this.bot.indicators.rsi; const lookback = this.bot.settings.params.rsiPeriod;
            if (!rsiValues || rsiValues.length < lookback || !candles || candles.length < lookback) return;
            const recentRsi = rsiValues.slice(-lookback);
            const lastCandle = candles[candles.length - 1]; 
            const prevCandle = candles[candles.length - lookback]; 
            const lastRsi = recentRsi[recentRsi.length - 1]; 
            const prevRsi = recentRsi[0];
            if (!lastCandle || !prevCandle || !isFinite(lastRsi) || !isFinite(prevRsi)) return;
            if (lastCandle.high > prevCandle.high && lastRsi < prevRsi) { 
                this.propose(this.bot.currentSymbol, 'sell', 'RSI Ayı Uyuşmazlığı', 5); 
            }
            if (lastCandle.low < prevCandle.low && lastRsi > prevRsi) { 
                this.propose(this.bot.currentSymbol, 'buy', 'RSI Boğa Uyuşmazlığı', 5); 
            }
        }
    }
    class OrderFlowMomentumStrategy extends Strategy {
        constructor(bot) { super(bot, 'orderFlowMomentum'); this.trades = []; this.WINDOW_MS = 5000; }
        processTrade(trade) {
            const now = Date.now(); 
            this.trades.push(trade); 
            this.trades = this.trades.filter(t => now - t.timestamp < this.WINDOW_MS); 
            if (this.trades.length < 50) return;
            const buys = this.trades.filter(t => !t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0); 
            const sells = this.trades.filter(t => t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0);
            const total = buys + sells; if (total === 0) return; 
            if (buys / total > 0.7) { this.propose(this.bot.currentSymbol, 'buy', `Alıcı Akışı: %${(buys / total * 100).toFixed(0)}`, 4); this.trades = []; }
            else if (sells / total > 0.7) { this.propose(this.bot.currentSymbol, 'sell', `Satıcı Akışı: %${(sells / total * 100).toFixed(0)}`, 4); this.trades = []; }
        }
    }
    class LiquidityGapsStrategy extends Strategy {
        constructor(bot) { super(bot, 'liquidityGaps'); this.GAP_THRESHOLD_PERCENT = 0.1 / 100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.asks || orderBook.asks.length === 0 || !orderBook.bids || orderBook.bids.length === 0) return;
            for (let i = 0; i < orderBook.asks.length - 1; i++) { 
                const gap = orderBook.asks[i + 1][0] - orderBook.asks[i][0]; 
                if ((gap / orderBook.asks[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'buy', `Likidite Boşluğu ${orderBook.asks[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.asks[i][0]))}`, 3); return; 
                } 
            }
            for (let i = 0; i < orderBook.bids.length - 1; i++) { 
                const gap = orderBook.bids[i][0] - orderBook.bids[i + 1][0]; 
                if ((gap / orderBook.bids[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'sell', `Likidite Boşluğu ${orderBook.bids[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.bids[i][0]))}`, 3); return; 
                } 
            }
        }
    }
    class BreakoutPatternStrategy extends Strategy {
        constructor(bot) { super(bot, 'breakoutPattern'); this.LOOKBACK = 30; this.VOL_SPIKE = 1.4; this.BREAK_PCT = 0.03/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK + 1) return;
            const recent = c.slice(-this.LOOKBACK-1);
            const highs = recent.map(x=>x.high), lows = recent.map(x=>x.low), vols = recent.map(x=>x.volume);
            const last = recent[recent.length-1]; 
            const maxH = Math.max(...highs.slice(0, -1)); const minL = Math.min(...lows.slice(0, -1));
            const volSma = vols.reduce((a,b)=>a+b,0) / (vols.length-1);
            if (last.close > maxH * (1 + this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'buy', 'Aralık Üstü Hacimli Kırılım', 4);
            } else if (last.close < minL * (1 - this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'sell', 'Aralık Altı Hacimli Kırılım', 4);
            }
        }
    }
    class SupportResistanceStrategy extends Strategy {
        constructor(bot) { super(bot, 'supportResistance'); this.LOOKBACK = 60; this.THRESH = 0.15/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            const last = slice[slice.length-1];
            const maxH = Math.max(...slice.map(x=>x.high)); const minL = Math.min(...slice.map(x=>x.low));
            const distTop = (maxH - last.close)/last.close; const distBot = (last.close - minL)/last.close;
            if (distTop >= 0 && distTop < this.THRESH && last.close < last.open) {
                this.propose(this.bot.currentSymbol, 'sell', 'Direnç Bölgesi Reddi', 3);
            }
            if (distBot >= 0 && distBot < this.THRESH && last.close > last.open) {
                this.propose(this.bot.currentSymbol, 'buy', 'Destek Bölgesi Tepkisi', 3);
            }
        }
    }
    class FibonacciRetracementStrategy extends Strategy {
        constructor(bot) { super(bot, 'fibonacciRetracement'); this.LOOKBACK = 120; this.TOL = 0.2/100; this.levels = [0.382, 0.5, 0.618]; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            let high = -Infinity, low = Infinity, hT=0, lT=0;
            slice.forEach(k => { if(k.high > high){high=k.high; hT=k.time;} if(k.low < low){low=k.low; lT=k.time;} });
            if (!isFinite(high) || !isFinite(low) || high===low) return;
            const last = slice[slice.length-1];
            if (hT > lT) {
                const retr = (high - last.close) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'buy', `Fibo ${Math.round(L*100)}% Bölgesi`, 3); break; }
                }
            } else {
                const retr = (last.close - low) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'sell', `Fibo ${Math.round(L*100)}% Bölgesi`, 3); break; }
                }
            }
        }
    }
    class VolumeProfileStrategy extends Strategy {
        constructor(bot) { super(bot, 'volumeProfile'); this.PERIOD = 20; this.SPIKE = 2.0; this.CLOSE_POS = 0.7; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.PERIOD + 1) return;
            const last = c[c.length-1];
            const vols = c.slice(-this.PERIOD-1, -1).map(x=>x.volume);
            const volSma = vols.reduce((a,b)=>a+b,0)/vols.length;
            if (last.volume > volSma * this.SPIKE && (last.close - last.low) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'buy', 'Hacim Spike - Üst Kapanış', 3);
            } else if (last.volume > volSma * this.SPIKE && (last.high - last.close) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'sell', 'Hacim Spike - Alt Kapanış', 3);
            }
        }
    }
    class SmartMoneyConceptsStrategy extends Strategy {
        constructor(bot) { super(bot, 'smartMoneyConcepts'); this.GAP_MIN_PCT = 0.05/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 3) return;
            const a = c[c.length-3], b = c[c.length-2], d = c[c.length-1];
            if ((d.low - b.high > 0) && (b.low - a.high > 0) && ((d.low - a.high)/Math.max(1e-8, d.low) > this.GAP_MIN_PCT)) {
                 this.propose(this.bot.currentSymbol, 'buy', 'Bullish FVG (IMB)', 4);
            }
            if ((a.low - b.high > 0) && (b.low - d.high > 0) && ((a.low - d.high)/Math.max(1e-8, d.high) > this.GAP_MIN_PCT)) {
                this.propose(this.bot.currentSymbol, 'sell', 'Bearish FVG (IMB)', 4);
            }
        }
    }
    class DivergenceDetectionStrategy extends Strategy {
        constructor(bot) { super(bot, 'divergenceDetection'); this.LOOKBACK = 40; this.SWING_PERIOD = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; const rsi = this.bot.indicators.rsi; 
            if (!rsi || c.length < this.LOOKBACK || rsi.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK), r = rsi.slice(-this.LOOKBACK);
            const pivLows = []; const pivHighs = [];
            for (let i = this.SWING_PERIOD; i < slice.length - this.SWING_PERIOD; i++) {
                const isPivotLow = slice[i].low < Math.min(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.low)) && 
                                   slice[i].low < Math.min(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.low));
                const isPivotHigh = slice[i].high > Math.max(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.high)) && 
                                    slice[i].high > Math.max(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.high));
                if (isPivotLow) pivLows.push(i);
                if (isPivotHigh) pivHighs.push(i);
            }
            if (pivLows.length >= 2) {
                const i1 = pivLows[pivLows.length-2], i2 = pivLows[pivLows.length-1];
                if (slice[i2].low < slice[i1].low && r[i2] > r[i1]) {
                    this.propose(this.bot.currentSymbol, 'buy', 'Boğa Sapması (RSI)', 5);
                }
            }
            if (pivHighs.length >= 2) {
                const i1 = pivHighs[pivHighs.length-2], i2 = pivHighs[pivHighs.length-1];
                if (slice[i2].high > slice[i1].high && r[i2] < r[i1]) {
                    this.propose(this.bot.currentSymbol, 'sell', 'Ayı Sapması (RSI)', 5);
                }
            }
        }
    }
    class MarketStructureStrategy extends Strategy {
        constructor(bot) { super(bot, 'marketStructure'); this.SWING = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 2*this.SWING+5) return;
            const pivotHighs = [], pivotLows = [];
            for (let i = this.SWING; i < c.length - this.SWING; i++) {
                if (c[i].high > Math.max(...c.slice(i-this.SWING, i).map(x=>x.high)) && c[i].high > Math.max(...c.slice(i+1, i+1+this.SWING).map(x=>x.high))) pivotHighs.push(i);
                if (c[i].low < Math.min(...c.slice(i-this.SWING, i).map(x=>x.low)) && c[i].low < Math.min(...c.slice(i+1, i+1+this.SWING).map(x=>x.low))) pivotLows.push(i);
            }
            const last = c[c.length-1];
            if (pivotHighs.length) {
                const ph = c[pivotHighs[pivotHighs.length-1]].high;
                if (last.close > ph) this.propose(this.bot.currentSymbol, 'buy', 'Yapı Kırılımı (BOS Up)', 4);
            }
            if (pivotLows.length) {
                const pl = c[pivotLows[pivotLows.length-1]].low;
                if (last.close < pl) this.propose(this.bot.currentSymbol, 'sell', 'Yapı Kırılımı (BOS Down)', 4);
            }
        }
    }
    class InstitutionalOrderFlowStrategy extends Strategy {
        constructor(bot) { super(bot, 'institutionalOrderFlow'); this.TOP_N = 5; this.IMB_THRESHOLD = 2.0; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) return;
            const topB = orderBook.bids.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            const topA = orderBook.asks.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            if (topB / Math.max(1e-8, topA) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'buy', 'Orderbook İmbalansı (Bid Ağırlık)', 3);
            } else if (topA / Math.max(1e-8, topB) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'sell', 'Orderbook İmbalansı (Ask Ağırlık)', 3);
            }
        }
    }
    class MicroSpreadArbitrageStrategy extends Strategy {
        constructor(bot) { super(bot, 'microSpreadArbitrage'); this.SPREAD_PCT = 0.08/100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) return;
            const bestBid = orderBook.bids[0][0], bestAsk = orderBook.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            if (spreadPct > this.SPREAD_PCT) {
                const current = this.bot.marketData.price || mid;
                if (current < mid) this.propose(this.bot.currentSymbol, 'buy', 'Geniş Spread - Mean Reversion', 2);
                else this.propose(this.bot.currentSymbol, 'sell', 'Geniş Spread - Mean Reversion', 2);
            }
        }
    }
    class VWAPReversionStrategy extends Strategy {
        constructor(bot) { super(bot, 'vwapReversion'); this.MULT = 1.0; }
        periodicAnalyze() {
            const price = this.bot.marketData.price, vwap = this.bot.indicators.vwap, atr = this.bot.indicators.atr;
            if (!price || !vwap || !atr) return;
            const dev = atr / price; 
            const diffPct = (price - vwap) / vwap;
            if (diffPct > this.MULT * dev) this.propose(this.bot.currentSymbol, 'sell', 'VWAP Üstü Aşırı Sapma', 3);
            if (diffPct < -this.MULT * dev) { this.propose(this.bot.currentSymbol, 'buy', 'VWAP Altı Aşırı Sapma', 3); }
        }
    }
    class SuperTrendStrategy extends Strategy {
        constructor(bot) { super(bot, 'superTrend'); this.MULT = 3.0; this.PERIOD = 14; }
        periodicAnalyze() {
            const c = this.bot.candles; const atr = this.bot.indicators.atr;
            if (!atr || c.length < 2) return;
            const last = c[c.length-1];
            const m = (last.high + last.low) / 2;
            const upper = m + this.MULT * atr, lower = m - this.MULT * atr;
            if (last.close > upper) this.propose(this.bot.currentSymbol, 'buy', 'ATR Kanal Üstü Kırılım (SuperTrend)', 4);
            else if (last.close < lower) { this.propose(this.bot.currentSymbol, 'sell', 'ATR Kanal Altı Kırılım (SuperTrend)', 4); }
        }
    }

    // YENİ STRATEJİLER
    class VolatilityBreakoutStrategy extends Strategy {
        constructor(bot) { 
            super(bot, 'volatilityBreakout'); 
            this.SQUEEZE_LOOKBACK = 20;
            this.SQUEEZE_MULT = 1.0; // ATR'ye göre sıkışma tespiti için çarpan
            this.BREAKOUT_VOL_MULT = 1.5; // Kırılım anındaki hacim artışı
        }
        periodicAnalyze() {
            const { bbands, atr, volSma20 } = this.bot.indicators;
            const c = this.bot.candles;
            if (!bbands || !atr || !volSma20 || c.length < this.SQUEEZE_LOOKBACK || !bbands.upper || bbands.upper.length === 0) return;

            const lastBandUpper = bbands.upper[bbands.upper.length-1];
            const lastBandMiddle = bbands.middle[bbands.middle.length-1];
            const lastBandLower = bbands.lower[bbands.lower.length-1];

            if (!lastBandUpper || !lastBandMiddle || !lastBandLower || lastBandMiddle.value === 0) return;

            const bandwidth = (lastBandUpper.value - lastBandLower.value) / lastBandMiddle.value;
            
            const isSqueeze = bandwidth < (atr * this.SQUEEZE_MULT / (c[c.length-1]?.close || 1));
            if(!isSqueeze) return;

            const lastCandle = c[c.length-1];
            if (!lastCandle) return;

            if (lastCandle.close > lastBandUpper.value && lastCandle.volume > volSma20 * this.BREAKOUT_VOL_MULT) {
                this.propose(this.bot.currentSymbol, 'buy', 'Volatilite Sıkışma Kırılımı (Yukarı)', 5);
            } else if (lastCandle.close < lastBandLower.value && lastCandle.volume > volSma20 * this.BREAKOUT_VOL_MULT) {
                this.propose(this.bot.currentSymbol, 'sell', 'Volatilite Sıkışma Kırılımı (Aşağı)', 5);
            }
        }
    }

    class CandleCharacterStrategy extends Strategy {
        constructor(bot) {
            super(bot, 'candleCharacter');
            this.MIN_BODY_TO_WICK_RATIO = 0.6; // Gövde / Toplam Mum Boyu oranı
            this.ANALYSIS_WINDOW_PERCENT = 0.2; // Mumun son %20'sinde çalışır
        }
        periodicAnalyze() {
            if (this.bot.candles.length < 1) return;
            const candle = this.bot.candles[this.bot.candles.length-1];
            const timeframeMs = this.bot._timeframeToMs(this.bot.currentTimeframe);
            const candleAge = Date.now() - candle.time;
            
            // Sadece mumun sonlarına doğru çalış
            if (candleAge < timeframeMs * (1 - this.ANALYSIS_WINDOW_PERCENT)) return;

            const { open, high, low, close } = candle;
            const bodySize = Math.abs(close - open);
            const totalSize = high - low;
            if (totalSize === 0) return; // Doji veya veri hatası

            const bodyRatio = bodySize / totalSize;
            if(bodyRatio < this.MIN_BODY_TO_WICK_RATIO) return; // Güçsüz gövde, kararsızlık

            if (close > open) { // Yeşil mum
                const upperWick = high - close;
                // Eğer üst fitil toplam mum boyutunun %20'sinden azsa, gövde güçlüdür
                if (upperWick / totalSize < 0.2) { 
                    this.propose(this.bot.currentSymbol, 'buy', 'Güçlü Alıcı Mumu', 4);
                }
            } else { // Kırmızı mum
                const lowerWick = close - low;
                // Eğer alt fitil toplam mum boyutunu %20'sinden azsa, gövde güçlüdür
                if(lowerWick / totalSize < 0.2) { 
                    this.propose(this.bot.currentSymbol, 'sell', 'Güçlü Satıcı Mumu', 4);
                }
            }
        }
    }

     class FundingRateReversalStrategy extends Strategy {
        constructor(bot) {
            super(bot, 'fundingRateReversal');
            this.fundingRate = 0;
            this.openInterest = 0;
            this.lastFetchTime = 0;
            this.FETCH_INTERVAL_MS = 60 * 1000; // 1 dakikada bir veri çek
            this.EXTREME_FUNDING_THRESHOLD = 0.001; // %0.1 fonlama oranı eşiği
        }

        async periodicAnalyze() {
            const now = Date.now();
            if (now - this.lastFetchTime > this.FETCH_INTERVAL_MS) {
                this.lastFetchTime = now;
                try {
                    const response = await fetch(`https://fapi.binance.com/fapi/v1/premiumIndex?symbol=${this.bot.currentSymbol}`);
                    if (!response.ok) {
                        console.error(`Funding Rate/Open Interest API Hatası: ${response.statusText}`);
                        return;
                    }
                    const data = await response.json();
                    this.fundingRate = parseFloat(data.lastFundingRate);
                    this.openInterest = parseFloat(data.openInterest) || 0; 

                } catch (e) { 
                    console.error("Fonlama Oranı/Açık Faiz verisi çekilemedi:", e); 
                    return;
                }
            }

            const currentPrice = this.bot.marketData.price;
            if (!currentPrice || !isFinite(this.fundingRate) || this.fundingRate === 0 || this.bot.candles.length < 2) return;

            if (this.fundingRate > this.EXTREME_FUNDING_THRESHOLD) {
                if (currentPrice < this.bot.candles[this.bot.candles.length - 2]?.close) { 
                     this.propose(this.bot.currentSymbol, 'sell', `Aşırı Pozitif Fonlama & Fiyat Düşüşü (${(this.fundingRate*100).toFixed(3)}%)`, 4);
                }
            } else if (this.fundingRate < -this.EXTREME_FUNDING_THRESHOLD) {
                 if (currentPrice > this.bot.candles[this.bot.candles.length - 2]?.close) { 
                    this.propose(this.bot.currentSymbol, 'buy', `Aşırı Negatif Fonlama & Fiyat Yükselişi (${(this.fundingRate*100).toFixed(3)}%)`, 4);
                }
            }
        }
    }


    /* =========================
       UYUM MOTORU V2 (CONFLUENCE ENGINE V2)
       ========================= */
    class AdvancedConfluenceEngine {
        constructor(bot) { 
            this.bot = bot; 
            this.proposals = []; 
            this.lastSignalTime = 0; 
            this.lastSignalTimeByDirection = { buy: 0, sell: 0 };
            this.lastDirection = null;
            this.buyScore = 0;
            this.sellScore = 0;
        }
        propose(strategy, direction, reason, score) {
            const now = Date.now();
            this.proposals = this.proposals.filter(p => !(p.strategy === strategy && p.direction === direction));
            this.proposals.push({ strategy, direction, reason, score, timestamp: now });
            this.checkConfluence();
        }
        _computeDirectional(direction) {
            const now = Date.now();
            const decaySec = this.bot.settings.optimization.timeDecaySec || 3;
            const groupSums = { trending: 0, meanReversion: 0, neutral: 0 };
            const used = [];
            const groupsUsed = new Set();
            const activeProposals = this.proposals.filter(p => {
                const strategyInstance = this.bot.strategies[p.strategy];
                return strategyInstance && strategyInstance._isLive && p.direction === direction;
            });

            for (const p of activeProposals) {
                const w = this.bot.getStrategyWeight(p.strategy);
                const ageSec = (now - p.timestamp)/1000;
                const decay = Math.exp(-ageSec / decaySec);
                // DÜZELTME: NaN kontrolü eklendi
                const eff = isNaN(p.score * w * decay) ? 0 : p.score * w * decay;
                const grp = this.bot.getStrategyGroup(p.strategy);
                groupsUsed.add(grp);
                groupSums[grp] = (groupSums[grp] || 0) + eff;
                used.push({ strategy: p.strategy, baseScore: p.score, weight: w, decay, effScore: eff });
            }
            const score = Object.values(groupSums).reduce((sum, val) => sum + val, 0); 
            return { score, contributors: used, groupSums, groupsCount: groupsUsed.size, contributorsCount: used.length };
        }
       
        checkConfluence() {
            const now = Date.now();
            const settings = this.bot.settings;
            const cd = settings.cooldowns || {};
            const proposalTimeout = cd.proposalTimeoutMs ?? 3000;
            const signalCooldown = cd.signalMs ?? 15000;
            const sameDirCooldown = cd.sameDirectionMs ?? 30000;
            const oppCooldown = cd.oppositeDirectionMs ?? 20000;
            const reverseHys = cd.reverseHysteresisPoints ?? 2;
            const dirMargin = settings.optimization.dirMargin ?? 0.5;
            const minThreshold = this.bot.getEffectiveThreshold();

            if (now - this.lastSignalTime < signalCooldown) return;
            this.proposals = this.proposals.filter(p => now - p.timestamp < proposalTimeout);

            const buy = this._computeDirectional('buy');
            const sell = this._computeDirectional('sell');

            let buyScoreAdj = buy.score;
            let sellScoreAdj = sell.score;

            if (settings.features.enableMtfConfirm) {
                const mtfTrend = this.bot.multiTimeframeManager.getTrend(settings.features.mtfTimeframe);
                if (mtfTrend === 'down') buyScoreAdj *= 0.6;
                if (mtfTrend === 'up') sellScoreAdj *= 0.6;
            }

            const buyPenalty = settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('buy') : 0;
            const sellPenalty = settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('sell') : 0;
            buyScoreAdj -= buyPenalty;
            sellScoreAdj -= sellPenalty;

            const q = settings.optimization.signalQuality || { minContributors: 1, minGroups: 1 };
            const buyOk = (buy.contributorsCount >= q.minContributors) && (buy.groupsCount >= q.minGroups);
            const sellOk = (sell.contributorsCount >= q.minContributors) && (sell.groupsCount >= q.minGroups);

            buyScoreAdj = buyOk ? buyScoreAdj : -Infinity;
            sellScoreAdj = sellOk ? sellScoreAdj : -Infinity;

            this.buyScore = buyScoreAdj;
            this.sellScore = sellScoreAdj;

            if (buyScoreAdj >= minThreshold && (buyScoreAdj > sellScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.buy < sameDirCooldown) return;
                if (this.lastDirection === 'sell' && (now - this.lastSignalTime) < oppCooldown) {
                    if (buyScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('buy', buy.contributors, buyScoreAdj);
            } else if (sellScoreAdj >= minThreshold && (sellScoreAdj > buyScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.sell < sameDirCooldown) return;
                if (this.lastDirection === 'buy' && (now - this.lastSignalTime) < oppCooldown) {
                    if (sellScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('sell', sell.contributors, sellScoreAdj);
            }
        }

        generateFinalSignal(direction, contributors, finalScore) {
            const contributingStrats = contributors.map(c => this.bot.strategies[c.strategy]?.displayName || c.strategy).join(', ');
            const status = this.bot.settings.features.enableCandleConfirm ? 'pending' : 'active';
            
            const signal = { 
                id: `sig_${Date.now()}`, timestamp: Date.now(), symbol: this.bot.currentSymbol, 
                direction, price: this.bot.marketData.price, score: finalScore, 
                reason: contributingStrats, contributors, status: status, note: '',
                mfeR: 0, beDone: false, trailingStage: 0, entrySlDistance: 0, entryTpDistance: 0,
                recommendedSize: this.bot.getRecommendedPositionSize(finalScore)
            };

            this.bot.calculateDynamicTpSl(signal);

            if (status === 'pending') {
                this.bot.addPendingSignal(signal);
            } else {
                this.bot.activateSignal(signal);
            }
            
            this.proposals = [];
            const now = Date.now();
            this.lastSignalTime = now;
            this.lastSignalTimeByDirection[direction] = now;
            this.lastDirection = direction;
        }
    }

    /* =========================
       ANA UYGULAMA
       ========================= */
    class UltimateTradingCommandCenter {
        constructor() {
            this.allStrategiesMap = {
                'wallBounce': WallBounceStrategy, 'velocityScalping': VelocityScalpingStrategy, 'rsiDivergence': RsiDivergenceStrategy, 
                'orderFlowMomentum': OrderFlowMomentumStrategy, 'liquidityGaps': LiquidityGapsStrategy, 'fibonacciRetracement': FibonacciRetracementStrategy, 
                'volumeProfile': VolumeProfileStrategy, 'smartMoneyConcepts': SmartMoneyConceptsStrategy, 'divergenceDetection': DivergenceDetectionStrategy, 
                'breakoutPattern': BreakoutPatternStrategy, 'supportResistance': SupportResistanceStrategy, 'marketStructure': MarketStructureStrategy, 
                'institutionalOrderFlow': InstitutionalOrderFlowStrategy, 'microSpreadArbitrage': MicroSpreadArbitrageStrategy,
                'vwapReversion': VWAPReversionStrategy, 'superTrend': SuperTrendStrategy,
                'volatilityBreakout': VolatilityBreakoutStrategy,
                'candleCharacter': CandleCharacterStrategy,
                'fundingRateReversal': FundingRateReversalStrategy
            };
            this.allStrategyKeys = Object.keys(this.allStrategiesMap); 

            this.isRunning = false; 
            this.sockets = {}; 
            
            this.currentSymbol = this.loadData('utc_current_symbol') || 'BTCUSDT'; 
            this.currentTimeframe = this.loadData('utc_current_timeframe') || '15m';
            this.headerCollapsed = this.loadData('utc_header_collapsed') !== null ? (this.loadData('utc_header_collapsed') === 'true') : true; 
            this.currentMainView = this.loadData('utc_current_view') || 'chart';

            this.marketData = { price: 0, change24h: 0, volume24h: 0, symbol: this.currentSymbol, btcPrice: 70000, lastOrderBook: null }; // Added lastOrderBook
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 

            this.aggTrades = []; 
            this.candles = [];
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null, bbands: null }; 
            this.signals = this.loadData('utc_signals') || [];
            this.pendingSignals = [];
            this.stats = this.loadData('utc_stats') || { total: 0, tp: 0, sl: 0 };

            this.strategyStats = this.loadData('utc_strategy_stats') || this.initDefaultStrategyStats();
            this.marketRegime = 'unknown';
            this.riskState = 'neutral'; 
            this.sessionState = 'unknown';

            this.strategyGroups = {
                trending: ['breakoutPattern','orderFlowMomentum','marketStructure','volumeProfile','smartMoneyConcepts','superTrend', 'volatilityBreakout'],
                meanReversion: ['vwapReversion','wallBounce','liquidityGaps','fibonacciRetracement','supportResistance','microSpreadArbitrage','divergenceDetection','rsiDivergence','institutionalOrderFlow', 'fundingRateReversal'],
                neutral: ['candleCharacter']
            };
            
            this.settings = this.loadSettings();
            this.strategies = {}; 
            
            this.combatModeActive = false;
            this.manipulationDetector = null;
            this.reconnectAttempts = 0;
            this.reconnectDelay = 3000;

            this.shadowProposals = [];

            this.chartManager = new ChartManager('live-chart');
            this.heatmapManager = new HeatmapManager('orderbook-heatmap');
            this.confluenceEngine = new AdvancedConfluenceEngine(this); // Using AdvancedConfluenceEngine
            // MultiTimeframeManager oluştur - hangisi mevcutsa onu kullan
            if (typeof MultiTimeframeManager === 'function') {
                this.multiTimeframeManager = new MultiTimeframeManager(this); 
            } else if (typeof LegacyMultiTimeframeManager === 'function') {
                this.multiTimeframeManager = new LegacyMultiTimeframeManager(this);
            }
            this.spoofDetector = new SpoofDetector(this);               
            this.cusumDetector = new CUSUMDriftDetector();               
            this.sessionProfiler = new SessionProfiler(this);
            this.riskGuardian = new RiskGuardian(this);                   
            this.notificationCenter = new AdvancedNotificationCenter(this);
            this.marketStructureAnalyzer = { trendThreshold: 0.5 }; // Placeholder for ritual effect

            this.renderInterval = null; 
            this.analysisInterval = null;
            this.cooldownTuneInterval = null;
            this.thresholdTuneInterval = null;
            this.paramTuneInterval = null;
            this.sessionUpdateInterval = null;
            this.countdownInterval = null; 
            this.performanceMonitorInterval = null; // DÜZELTME: Performans izleyici için

            this.lastAutoToggleTs = 0;
            this.runtimeThresholdOffset = 0; 
            this.lastCalculatedCandle = null; // DÜZELTME: İndikatör optimizasyonu için
            this.renderTimeout = null; // DÜZELTME: Render debounce için

            this.synth = window.speechSynthesis || null;
            this.speechQueue = []; // DÜZELTME: Konuşma kuyruğu
            this.isSpeaking = false; // DÜZELTME: Konuşma durumu
            this.voices = [];
            
            // Enerji Yönetim Sistemi
            this.energyManager = null;
            
            // Ritüel Sistemi
            this.ritualManager = null;
            
            // Panteon and OSIRIS integration
            this.panteonManager = new PantheonSystem();
            this.oracle = new TheOracle(this);
            this.osiris = new OSIRISCore(this); // Initialize OSIRIS
            
            // DÜZELTME: Eksik TTS metinleri eklendi
                        this.speechTexts = {
                buy: [
                    "Harika bir fırsat! [Sembol] için alım sinyali geldi. Yeşil ışık yanıyor! Skor [Skor].",
                    "Piyasa nefes aldı, [Sembol] yükselişe geçiyor. Bu trene binmek ister misin? Skor [Skor].",
                    "Komutanım, hesaplamalar net: [Sembol] için güçlü bir alım. Devler uyanıyor! Skor [Skor].",
                    "Cüzdanlarınıza dikkat, [Sembol] için bir yükseliş trendi başlangıcı. Fırsat kapınızı çaldı! Skor [Skor].",
                    "Gözünü dört aç! [Sembol] için büyük bir potansiyel görüyorum. Roket kalkışa hazır! Skor [Skor].",
                    "Bugün şanslı günün olabilir! [Sembol] alım için çağırıyor. İç sesine kulak ver! Skor [Skor].",
                    "Duy sesimi Komutanım! [Sembol] için alım sinyali. Hadi, pazarın nabzını tutalım! Skor [Skor].",
                    "Piyasa dans etmeye başladı, [Sembol] yükselişle eşlik ediyor. Katılmak ister misin? Skor [Skor].",
                    "Bana güven, [Sembol] için enerji pozitif. Bu işlemi kaçırmak istemezsin. Skor [Skor].",
                    "Ulan [Sembol] için alım sinyali patladı, hala ne bekliyorsun lanet olası! Kalk ve parayı kap, yoksa pişmanlık seni yer bitirir! Skor [Skor]."
                ],
                sell: [
                    "Piyasa biraz yorulmuş gibi, [Sembol] için satış sinyali geldi. Karları garantiye alalım! Skor [Skor].",
                    "Komutanım, [Sembol] için aşağı yönlü bir hareketlilik bekliyorum. Tetikte ol! Skor [Skor].",
                    "Bazen geri çekilmek de kazanmaktır. [Sembol] için satış vakti. Parçaları topluyoruz! Skor [Skor].",
                    "Bir fırtına yaklaşıyor olabilir, [Sembol] için satış sinyali. Kendini güvende tut! Skor [Skor].",
                    "Akıllıca bir adım! [Sembol] için kazançları koruma zamanı. Hızlı ve isabetli olalım. Skor [Skor].",
                    "Piyasa nazikçe fısıldıyor: [Sembol] için biraz ara ver. Karını koru! Skor [Skor].",
                    "Riskleri minimize etmenin zamanı geldi. [Sembol] için satış önerisi. Gerekirse tekrar gireriz. Skor [Skor].",
                    "Satış sinyali geldi. Umarım boğalar çimlere basmamıştır! [Sembol] için. Skor [Skor].",
                    "Ulan [Sembol] düşüyor, hala mı tutuyorsun lanet olası aptal! Sat da kurtul, yoksa cebin boşalır sinirlenme bana! Skor [Skor].",
                    "Siktir et o umudunu, [Sembol] satış sinyali verdi! Sert ol, çık ve karı kap, motive ol lan yoksa kaybedersin! Skor [Skor]."
                ],
                combatModeActivate: [
                    "Kumandanım, Kırmızı Alarm! Savaş Modu aktive edildi! Piyasanın kalbi şimdi elimizde!",
                    "Sistem uyarısı: Ultra savaş modu devrede! Piyasa savaşı başlıyor! Her bir strateji tam kapasite!",
                    "Savaş Modu Başladı! İleri Komutanım! Tüm güçler hazır, her anı avantaja çevireceğiz!",
                    "Hazırlanın! Savaş Modu aktive edildi. Bu bir zihin oyunu ve biz kazanacağız! Odaklanma ve hız, anahtarımız!",
                    "Ulan savaş modu aktive! Piyasa seni ezmeye çalışıyor ama biz daha sertiz lan, kalk ayağa ve piyasayı sikert! Zafer bizim olacak!"
                ],
                combatModeDeactivate: [
                    "Savaş modu başarıyla sonlandırıldı. Piyasa koşulları normale dönüyor, normal operasyonlara geri dönüyoruz. İyi iş çıkardınız.",
                    "Operasyon sonu. Savaş modu kapatıldı. Şimdi piyasanın sakin sularında yüzme zamanı.",
                    "Savaş modu devre dışı. Riskler azaldı, piyasa sakinleşiyor. Sakin sularda bile fırsatlar vardır, unutmayın.",
                    "Kumandanım, savaş bitti. Kazanılmış bir zaferin ardından dinlenme vakti. Bir sonraki mücadeleye kadar hazırız.",
                    "Ulan savaş modu kapandı, hala mı sinirli duruyorsun lan? Rahatla Komutanım, zaferi kutla yoksa ben sinirlenirim sana da!"
                ],
                signalTP: [
                    "Hedef vuruldu! TP geldi, Komutanım! Bu başarı sizin stratejik dehanızın kanıtı!",
                    "Tebrikler! Kar realizasyonu gerçekleşti. Şimdi kahve içme zamanı, zafer sizin!",
                    "TP alarmı! Kazanç cebinizde, piyasa artık bizim kontrolümüzde. Harika iş!",
                    "Boom! TP hedefi tutturuldu. Strateji kusursuz, Komutanım lider!",
                    "Kar alındı! Zekânız ve disiplininizle piyasanın kalbini fethettiniz!",
                    "Ulan TP vuruldu, para cebinde lan! Sinirliydim piyasaya ama sen ezerdin, motive ol da kutla zaferi Komutanım!"
                ],
                signalSL: [
                    "SL tetiklendi! Savaş kaybedilmiş değil, ders alınmış! Komutanım, hazırlanın ve tekrar saldırın!",
                    "Stop Loss aktif. Kaybedilen bir savaş değil, bir sonraki zaferin başlangıcı!",
                    "SL geldi, ama moral bozulmasın. Bu sadece piyasanın egonuzu test etmesi!",
                    "Kaybı kabul et, ama pes etme. SL tetiklendi, stratejiyi yeniden şekillendiriyoruz!",
                    "SL alarmı! Hedefi kaybettik ama deneyim kazandık, Komutanım!",
                    "Ulan SL tetiklendi, para gitti lan! Sinirlim piyasaya ama sen pes etme, motive ol da tekrar saldır Komutanım!"
                ],
                cusumDriftDetected: [
                    "CUSUM drift tespit edildi! Komutanım, piyasa dalgalanıyor ama biz her zaman hazırız!",
                    "Sinyal değişimi geldi, dikkat! Bu bir fırsat ya da ders, sizin kararınız!",
                    "CUSUM alarmı! Strateji tetikte, piyasa bizi test ediyor ama biz kazanmaya odaklıyız!",
                    "Drift detected! Piyasa kıvılcımları uçuşuyor, Komutanım, kontrol sizde!",
                    "Ulan CUSUM drift patladı, piyasa dalgalanıyor lan! Sinirlim ulan, ama motive ol da hazır ol, fırsat mı ders mi sen karar ver!"
                ],
                autoToggleDeactivate: [
                    "Optimizasyon uyarısı: [Strateji Adı] stratejisi beklenen performansı göstermedi. Geçici olarak pasif edildi.",
                    "[Strateji Adı] stratejisi, performans testinden geçemedi. Geçici olarak emekli edildi. Dikkatli olalım.",
                    "Bir strateji daha devredışı. [Strateji Adı] şu an için dinlenmeye alındı. Daha iyi günler için bekliyoruz.",
                    "Ulan [Strateji Adı] performansı sıçtı, pasif edildi lan! Sinirlim ulan, ama motive ol da bekle, en iyisi bu!"
                ],
                autoToggleActivate: [
                    "Optimizasyon başarıyla tamamlandı: [Strateji Adı] stratejisi tekrar aktif edildi. Yeni veriler çok umut verici!",
                    "Müjde! [Strateji Adı] stratejisi tekrar göreve hazır! Performansı yükselişte. Hadi bakalım, piyasayı sallayalım!",
                    "Hoş geldin geri [Strateji Adı]! Kendini toparlamışsın. Tekrar aktif edildi. Şimdi bize neler göstereceksin merak ediyorum.",
                    "Ulan [Strateji Adı] geri döndü, aktif edildi lan! Sinirlim yokluğunda ama şimdi motive ol da sallayalım piyasayı, zafer yakın ulan!"
                ],
                cooldownOptimize: [
                    "Sistem, soğuma sürelerini başarıyla yeniden ayarladı. Piyasanın nabzına göre şimdiden optimize edildik Komutanım.",
                    "Cooldown ayarları güncellendi. Artık sinyaller arasında daha zeki bir denge kuruyoruz. Ben bu işi biliyorum!",
                    "Piyasa ritmini değiştirdi, biz de cooldown sürelerimizi. Tam senkronizasyon için her şey ayarlandı Komutanım.",
                    "Ulan cooldown süreleri ayarlandı lan! Sinirlim piyasanın ritmine ama optimize ettik, motive ol da dans pistinde ezeriz hepsini Komutanım!"
                ],
                systemStart: [
                    "Sistem başlatıldı. Canlı veri akışı başlıyor. Gözlerim ve kulaklarım piyasada Komutanım.",
                    "Başlatma tamamlandı. Piyasa analizine başlıyorum. Bana güvenebilirsin.",
                    "Uyanıyorum... Tüm sensörler aktif. Piyasa maceramız şimdi başlıyor!",
                    "Ulan sistem başladı lan! Sinirlim uykuda ama şimdi canlı veri akıyor, motive ol da piyasayı ezeriz Komutanım!"
                ],
                systemStop: [
                    "Sistem durduruldu. Operasyonlar askıya alındı. Bir mola verelim Komutanım.",
                    "Kapanış prosedürü aktif. Veri akışı durduruldu. Daha sonra görüşmek üzere!",
                    "Enerji tasarrufu modu. Sistem kapanıyor. İhtiyaç duyduğunuzda beni tekrar başlatabilirsiniz.",
                    "Ulan sistem durduruldu lan! Sinirlim piyasaya ama şimdi mola ver, motive ol da dinlen Komutanım yoksa ezerim seni yorgunlukla!"
                ],
                symbolChange: [
                    "Sembol [Sembol] olarak değiştirildi. Yeni bir maceraya hazırız.",
                    "Hedef [Sembol] olarak güncellendi. Adaptasyon tamamlandı. Şimdi bu sembole odaklanıyoruz.",
                    "Sembol değişimi: [Sembol]. Her zaman yeni bir meydan okumaya açığım.",
                    "Ulan sembol [Sembol] oldu lan! Sinirlim eskisine ama şimdi motive ol da yeni maceraya atıl, ezeriz piyasayı Komutanım!"
                ],
                timeframeChange: [
                    "Zaman aralığı [Timeframe] olarak değiştirildi. Daha büyük veya küçük resme odaklanıyoruz.",
                    "Mum çubuğu zaman dilimi [Timeframe] olarak ayarlandı. Bakış açımızı güncelledik.",
                    "[Timeframe] zaman dilimindeyiz. Piyasanın farklı bir yüzünü keşfediyoruz.",
                    "Ulan zaman aralığı [Timeframe] oldu lan! Sinirlim eskisine ama şimdi motive ol da büyük resme odaklan, ezeriz piyasayı Komutanım!"
                ],
                resetAll: [
                    "Tüm ayarlar sıfırlandı. Sistem yeniden başlatılmaya hazır. Temiz bir sayfa açtık Komutanım.",
                    "Ulan tüm ayarlar sıfırlandı lan! Sinirlim karmaşaya ama şimdi motive ol da temiz sayfaya atıl, ezeriz piyasayı Komutanım!"
                ],
                shadowBan: [
                    "[Strateji] gölgeye alındı. Uslan da gel!",
                    "Şşşt [Strateji], gölge moduna geç. Önce pistte kendini ispat et."
                ],
                shadowRehab: [
                    "Bravo! [Strateji] gölgede form tuttu, tekrar sahnede.",
                    "[Strateji] rehabilite edildi. Hadi bakalım, yüzümüzü kara çıkarma!"
                ],
                rogueOfDay: [
                    "Bugünün şerefsizi: [Strateji]! Kendine gel de adam gibi sinyal ver.",
                    "[Strateji], bugün gözüm üzerinde. Şerefsizlikte ısrar etme!"
                ],
                spoofBidRemoved: [
                    "Sahte emir tespit edildi, düşüş gelebilir. Dikkat et hacı abi.",
                    "Uyarı! Büyük bir alış desteği kayboldu. Piyasa aşağı sarkabilir, tetikte ol.",
                    "Balina desteğini çekti! Fiyat düşebilir, dikkatli ol komutanım."
                ],
                spoofAskRemoved: [
                    "Sahte emir tespit edildi, alım gelebilir. Dikkat et komutanım.",
                    "Uyarı! Büyük bir satış duvarı kayboldu. Fiyat yukarı hareketlenebilir, hazır ol.",
                    "Balina direnci kaldırdı! Fiyat yukarı doğru gidebilir , gözünü dört aç hacı abi."
                ]
            };


            this.init();
        }

        initDefaultStrategyStats() {
            const stats = {};
            (this.allStrategyKeys || []).forEach(k => {
                const baseStat = { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0, shadowWins: 0, shadowLosses: 0, shadowProposals: 0, lastUpdate: Date.now() };
                stats[k] = {
                    overall: { ...baseStat },
                    trend: { ...baseStat },
                    range: { ...baseStat },
                    transition: { ...baseStat }
                };
            });
            return stats;
        }
        saveStrategyStats() { this.saveData('utc_strategy_stats', this.strategyStats); }

        loadSettings() {
            const savedSettings = JSON.parse(localStorage.getItem('utc_settings') || '{}');
            const defaults = {
                confluenceThreshold: 3,
                params: { rsiPeriod: 14, atrPeriod: 14, wallBtc: 20, rrRatio: 1.5 },
                cooldowns: { signalMs: 15000, sameDirectionMs: 30000, oppositeDirectionMs: 20000, reverseHysteresisPoints: 2, proposalTimeoutMs: 3000, strategyProposalMs: 10000 },
                features: { 
                    enableSpoofDetection: true, enableCUSUMDrift: true, enableRiskGuardian: true, enableTTS: true, preferredVoiceName: null,
                    enableCandleConfirm: true,
                    enableMtfConfirm: true,
                    mtfTimeframe: '15m',
                    enableDynamicSizing: true
                },
                riskGuardian: {
                    killSwitchWinRate: 35.0,
                    autoRecover: false,
                    maxDrawdown: 5.0
                },
                optimization: {
                    enabled: true,
                    autoToggle: true,
                    timeDecaySec: 3,
                    dirMargin: 0.5,
                    minWeightToStay: 0.60,
                    minContribForToggle: 30,
                    gating: { enabled: true, spreadMaxPct: 0.001, minDepthUsd: 50000 },
                    signalQuality: { minContributors: 2, minGroups: 1 },
                    breakeven: { enabled: true, beAtR: 0.8, trailAfterR: 1.5, trailToR: 0.5 }
                },
                penalties: {
                    shadowEnabled: true,
                    minWeightToShadow: 0.60,
                    minContribForShadow: 30,
                    rehabWinRate: 0.58,
                    minShadowProposals: 20,
                    coolOffMs: 30 * 60 * 1000
                },
                statusMaps: {
                    shadowBanned: {},
                    hardBanned: {}
                },
                strategyParams: {
                    wallBounce: { DISTANCE_THRESHOLD_PERCENT: 0.0005 },
                    velocityScalping: { VELOCITY_WINDOW_MS: 2000, MIN_POINTS: 20, VELOCITY_THRESHOLD_PERCENT: 0.001 },
                    liquidityGaps: { GAP_THRESHOLD_PERCENT: 0.001 },
                    breakoutPattern: { LOOKBACK: 30, VOL_SPIKE: 1.4, BREAK_PCT: 0.0003 },
                    supportResistance: { LOOKBACK: 60, THRESH: 0.0015 },
                    fibonacciRetracement: { LOOKBACK: 120, TOL: 0.002 },
                    vwapReversion: { MULT: 1.0 },
                    superTrend: { MULT: 3.0, PERIOD: 14 },
                    marketStructure: { SWING: 3 },
                    institutionalOrderFlow: { TOP_N: 5, IMB_THRESHOLD: 2.0 },
                    microSpreadArbitrage: { SPREAD_PCT: 0.0008 },
                    volumeProfile: { PERIOD: 20, SPIKE: 2.0, CLOSE_POS: 0.7 },
                    divergenceDetection: { LOOKBACK: 40, SWING_PERIOD: 3 },
                    volatilityBreakout: { SQUEEZE_LOOKBACK: 20, SQUEEZE_MULT: 1.0, BREAKOUT_VOL_MULT: 1.5 },
                    candleCharacter: { MIN_BODY_TO_WICK_RATIO: 0.6, ANALYSIS_WINDOW_PERCENT: 0.2 },
                    fundingRateReversal: { FETCH_INTERVAL_MS: 60 * 1000, EXTREME_FUNDING_THRESHOLD: 0.001 }
                },
                activeStrategies: {} 
            };
            
            const mergeDeep = (target, source) => {
                for (const key in source) {
                    if (source[key] instanceof Object && key in target && !(source[key] instanceof Array)) {
                        Object.assign(target[key], mergeDeep(target[key], source[key]));
                    } else {
                        target[key] = source[key];
                    }
                }
                return target;
            };

            const currentSettings = mergeDeep(defaults, savedSettings);
            
            this.allStrategyKeys.forEach(key => {
                if (typeof currentSettings.activeStrategies[key] === 'undefined') {
                    currentSettings.activeStrategies[key] = true; 
                }
                if (currentSettings.statusMaps.hardBanned[key] || currentSettings.statusMaps.shadowBanned[key]) {
                    currentSettings.activeStrategies[key] = false;
                }
            });
            return currentSettings;
        }

        saveSettings() {
            localStorage.setItem('utc_settings', JSON.stringify(this.settings));
            this.applyStrategyParamOverrides();
            if (this.isRunning) {
                this.multiTimeframeManager.initialize(this.currentSymbol, [this.settings.features.mtfTimeframe]);
            }
        }
        loadData(key) { try { return JSON.parse(localStorage.getItem(key)); } catch { return null; } }
        saveData(key, data) { localStorage.setItem(key, JSON.stringify(data)); }
        
        getStrategyGroup(key) {
            if (this.strategyGroups.trending.includes(key)) return 'trending';
            if (this.strategyGroups.meanReversion.includes(key)) return 'meanReversion';
            return 'neutral';
        }
        
        getStrategyWeight(name) {
            const regime = this.marketRegime || 'overall';
            const regimeStats = this.strategyStats[name]?.[regime];
            const overallStats = this.strategyStats[name]?.overall;
            
            let s;
            if (regimeStats && (regimeStats.contrib || 0) > 10) {
                s = regimeStats;
            } else {
                s = overallStats || { alpha: 3, beta: 2 };
            }

            const mean = s.alpha / (s.alpha + s.beta);
            const totalObservations = s.alpha + s.beta;
            const uncertaintyPenalty = totalObservations < 10 ? 0.5 + (totalObservations / 20) : 1.0; 
            let w = (0.5 + mean) * uncertaintyPenalty; 
            w *= this.getGroupBoost(name);
            w = Math.max(0.3, Math.min(2.0, w)); 
            return w;
        }

        getGroupBoost(key) {
            const grp = this.getStrategyGroup(key);
            let boost = 1.0;
            if (this.marketRegime === 'trend' && grp === 'trending') boost *= 1.15;
            if (this.marketRegime === 'range' && grp === 'meanReversion') boost *= 1.15;
            const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0;
            if (atrPct < 0.005) { // Düşük volatilite
                if (grp === 'trending') boost *= 0.9; 
                if (grp === 'meanReversion') boost *= 1.05;
            } else if (atrPct > 0.02) { // Yüksek volatilite
                if (grp === 'trending') boost *= 1.05;
                if (grp === 'meanReversion') boost *= 0.95;
            }
            return boost;
        }
        init() {
            this.initStrategies(); 
            this.setupUI(); 
            this.setupEventListeners();
            this.debouncedRender();
            this.logToJournal('Sistem hazır. "SİSTEMİ BAŞLAT" butonuna tıklayın.');
            
            if (this.headerCollapsed) document.body.classList.add('header-collapsed'); else document.body.classList.remove('header-collapsed');
            this.switchMainView(this.currentMainView);
            this.sessionUpdateInterval = setInterval(() => this.updateSession(), 60000); 
            this.updateSession(); 

            this.countdownInterval = setInterval(() => this.updateCandleCountdown(), 1000);

            if (this.synth) {
                this.loadVoices();
                if(this.synth.onvoiceschanged !== undefined) {
                    this.synth.onvoiceschanged = () => this.loadVoices();
                }
            } else {
                console.warn('SpeechSynthesis API bu tarayıcı/cihazda desteklenmiyor.');
            }
            this.applyStrategyParamOverrides();
            this.startPerformanceMonitor(); // DÜZELTME: Performans izleyici için
            
            // Event sistemi başlatma
            this.eventListeners = {};
            
            // Gelişmiş özellikleri entegre et
            this.initAdvancedFeatures();
        }
        
        initAdvancedFeatures() {
            try {
                // Veritabanı yöneticisini başlat
                if (!this.dbManager.ready) {
                    this.dbManager.init().then(() => {
                        console.log("Veritabanı yöneticisi başlatıldı.");
                        this.loadDataFromDB();
                    });
                }
                
                // Efekt yöneticisini başlat
                if (!this.effectsManager._effectsEnabled) {
                    this.effectsManager.toggleEffects(true); // Enable effects by default
                }
                
                // Panteon yöneticisini başlat
                if (!this.panteonManager.system.initialized) {
                    this.panteonManager.init();
                }
                
                // TheOracle (Mahşerin Atlıları) sistemini başlat
                if (!this.oracle.isInitialized) {
                    this.oracle.init();
                }
                
                // MultiTimeframe yöneticisini başlat
                if (!this.multiTimeframeManager.isInitialized) {
                    this.multiTimeframeManager.init();
                }
                
                // OSIRIS sistemini başlat
                if (!this.osiris.isActive) {
                    this.osiris.activate();
                }

                console.log("Tüm gelişmiş özellikler başlatıldı.");
            } catch (error) {
                console.error("Gelişmiş özellikler başlatılırken hata:", error);
            }
        }
        
        async loadDataFromDB() {
            if (!this.dbManager || !this.dbManager.ready) return;
            
            try {
                // Sinyalleri yükle
                const dbSignals = await this.dbManager.getAll('signals');
                if (dbSignals && dbSignals.length > 0) {
                    // İki sinyali birleştir ve son 100 tanesini sakla
                    this.signals = [...this.signals, ...dbSignals]
                        .sort((a, b) => b.timestamp - a.timestamp)
                        .slice(0, 100);
                    
                    console.log(`${dbSignals.length} sinyal veritabanından yüklendi.`);
                }
                
                // İstatistikleri yükle
                const dbStats = await this.dbManager.get('stats', 'global');
                if (dbStats) {
                    this.stats = {...this.stats, ...dbStats.data};
                    console.log("İstatistikler veritabanından yüklendi.");
                }
                
                // Ayarları yükle
                const dbSettings = await this.dbManager.get('settings', 'global');
                if (dbSettings) {
                    this.settings = {...this.settings, ...dbSettings.data};
                    console.log("Ayarlar veritabanından yüklendi.");
                    this.applyStrategyParamOverrides();
                }
            } catch (error) {
                console.error("Veritabanından veri yüklenirken hata:", error);
            }
        }
        
        // Event emitter fonksiyonu
        emit(eventName, data) {
            if (!this.eventListeners[eventName]) return;
            
            this.eventListeners[eventName].forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Event handler (${eventName}) hatası:`, error);
                }
            });
        }
        
        // Event listener kayıt fonksiyonu
        on(eventName, callback) {
            if (!this.eventListeners[eventName]) {
                this.eventListeners[eventName] = [];
            }
            this.eventListeners[eventName].push(callback);
            
            // Geri dönüş fonksiyonu (listener'ı kaldırmak için)
            return () => {
                this.eventListeners[eventName] = this.eventListeners[eventName].filter(cb => cb !== callback);
            };
        }

        initStrategies() { 
            for (const key in this.allStrategiesMap) { this.strategies[key] = new this.allStrategiesMap[key](this); } 
            this.updateActiveStrategies(); 
        }
        updateActiveStrategies() { 
            for (const key in this.strategies) { 
                this.strategies[key].DEFAULT_PROPOSAL_COOLDOWN_MS = this.settings.cooldowns.strategyProposalMs; 
                const isActive = this.settings.activeStrategies[key] && 
                                 !this.settings.statusMaps.shadowBanned[key] && 
                                 !this.settings.statusMaps.hardBanned[key];
                this.strategies[key].setIsLive(isActive);
            } 
        }

        applyStrategyParamOverrides() {
            const p = this.settings.strategyParams || {};
            for (const key of Object.keys(this.strategies)) {
                if (!this.strategies[key]) continue;
                const inst = this.strategies[key];
                const ov = p[key] || {};
                for (const k of Object.keys(ov)) {
                    if (k in inst) inst[k] = ov[k];
                }
            }
        }

        setupUI() {
            document.getElementById('symbol-input').value = this.currentSymbol.replace('USDT', '');
            document.getElementById('timeframe-select').value = this.currentTimeframe;

            this.updateSettingsModalUI();
            const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme(); 
            this.heatmapManager.updateTheme();
            this.updateSuperTopTicker();
            
            // Gelişmiş özellikleri desteklemek için Ayarlar modalına yeni bir bölüm ekle
            this.setupAdvancedFeaturesUI();
        }
        
        setupAdvancedFeaturesUI() {
            // Modal içinde gelişmiş özellikleri içeren bölümü bul veya oluştur
            const settingsModalBody = document.querySelector('#settings-modal-overlay .settings-modal-body');
            if (!settingsModalBody) return;
            
            let advancedFeaturesSection = document.getElementById('advanced-features-section');
            if (!advancedFeaturesSection) {
                // Yoksa oluştur
                advancedFeaturesSection = document.createElement('div');
                advancedFeaturesSection.id = 'advanced-features-section';
                advancedFeaturesSection.className = 'settings-group';
                advancedFeaturesSection.innerHTML = `
                    <div class="panel-title" style="margin-bottom: 10px;">Gelişmiş Sistem Entegrasyonları</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="enable-panteon" class="feature-toggle" checked> Panteon Sistemi</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="enable-oracle" class="feature-toggle" checked> Mahşerin Atlıları</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="enable-effects" class="feature-toggle" checked> Görsel Efektler</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="enable-multi-timeframe" class="feature-toggle" checked> Çoklu Zaman Dilimi</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="enable-confluence" class="feature-toggle" checked> Confluence Motoru</label></div>
                    <div class="form-group"><label class="form-label">Min. Confluence Skoru:</label><input type="range" id="min-confluence-score" value="3" min="1" max="10" step="0.5" class="form-control"></div>
                    <button id="test-effects-btn" class="btn btn-sm btn-primary" style="margin-top: 10px;">Efektleri Test Et</button>
                `;
                
                settingsModalBody.appendChild(advancedFeaturesSection);
                
                // Event listener'lar ekle
                document.getElementById('enable-panteon')?.addEventListener('change', (e) => {
                    const isEnabled = e.target.checked;
                    this.panteonManager.system.initialized = isEnabled; // Directly control initialization state
                    document.getElementById('panteon-panel').style.display = isEnabled ? 'flex' : 'none';
                    this.showNotification(`Panteon sistemi ${isEnabled ? 'etkinleştirildi' : 'devre dışı bırakıldı'}`, 'info');
                });
                
                document.getElementById('enable-oracle')?.addEventListener('change', (e) => {
                    const isEnabled = e.target.checked;
                    this.oracle.isInitialized = isEnabled; // Directly control initialization state
                    document.getElementById('osiris-panel').style.display = isEnabled ? 'flex' : 'none'; // Re-use osiris panel for oracle for now
                    this.showNotification(`Mahşerin Atlıları ${isEnabled ? 'görünür' : 'gizli'}`, 'info');
                });
                
                document.getElementById('enable-effects')?.addEventListener('change', (e) => {
                    const isEnabled = e.target.checked;
                    this.effectsManager.toggleEffects(isEnabled);
                    
                    // Test efekti göster
                    if (isEnabled) {
                        setTimeout(() => {
                            this.effectsManager.createMatrixEffect();
                        }, 500);
                    }
                    
                    this.showNotification(`Görsel efektler ${isEnabled ? 'etkinleştirildi' : 'devre dışı bırakıldı'}`, 'info');
                });
                
                document.getElementById('test-effects-btn')?.addEventListener('click', () => {
                    if (this.effectsManager._effectsEnabled) {
                        this.effectsManager.createMatrixEffect();
                        this.effectsManager.createExplosionEffect(
                            window.innerWidth / 2, 
                            window.innerHeight / 2,
                            '#00ff00',
                            30
                        );
                        this.showNotification('Efekt testi çalıştırılıyor!', 'success');
                    } else {
                        this.showNotification('Efekt yöneticisi henüz başlatılmamış veya devre dışı!', 'error');
                    }
                });
                
                document.getElementById('enable-multi-timeframe')?.addEventListener('change', (e) => {
                    const isEnabled = e.target.checked;
                    this.multiTimeframeManager.isInitialized = isEnabled; // Directly control initialization state
                    const tabsContainer = document.querySelector('.tabs-container');
                    if (tabsContainer) tabsContainer.style.display = isEnabled ? 'flex' : 'none';
                    this.showNotification(`Çoklu zaman dilimi ${isEnabled ? 'etkinleştirildi' : 'devre dışı bırakıldı'}`, 'info');
                });
                
                document.getElementById('enable-confluence')?.addEventListener('change', (e) => {
                    const isEnabled = e.target.checked;
                    this.confluenceEngine.toggleConfluence(isEnabled);
                    this.showNotification(`Confluence motoru ${isEnabled ? 'etkinleştirildi' : 'devre dışı bırakıldı'}`, 'info');
                });
                
                document.getElementById('min-confluence-score')?.addEventListener('input', (e) => {
                    const score = parseFloat(e.target.value);
                    if (isNaN(score) || score < 1) {
                        e.target.value = '1';
                        this.confluenceEngine.setMinConfluenceScore(1);
                    } else if (score > 10) {
                        e.target.value = '10';
                        this.confluenceEngine.setMinConfluenceScore(10);
                    } else {
                        this.confluenceEngine.setMinConfluenceScore(score);
                    }
                    this.showNotification(`Minimum confluence skoru ${this.confluenceEngine.minConfluenceScore} olarak ayarlandı`, 'info');
                });
            }
        }
        updateSuperTopTicker() { document.getElementById('ticker-bar-symbol').textContent = this.currentSymbol.replace('USDT', '/USDT'); }

        updateSettingsModalUI() {
            const s = this.settings;
            document.getElementById('modal-confluence-threshold').value = s.confluenceThreshold;
            document.getElementById('modal-param-rsi-period').value = s.params.rsiPeriod;
            document.getElementById('modal-param-atr-period').value = s.params.atrPeriod;
            document.getElementById('modal-param-wall-btc').value = s.params.wallBtc;
            document.getElementById('modal-param-rr-ratio').value = s.params.rrRatio;
            document.getElementById('modal-signal-cooldown-ms').value = s.cooldowns.signalMs;
            document.getElementById('modal-same-direction-cooldown-ms').value = s.cooldowns.sameDirectionMs;
            document.getElementById('modal-opposite-direction-cooldown-ms').value = s.cooldowns.oppositeDirectionMs;
            document.getElementById('modal-reverse-hysteresis-points').value = s.cooldowns.reverseHysteresisPoints;
            document.getElementById('modal-proposal-timeout-ms').value = s.cooldowns.proposalTimeoutMs;
            document.getElementById('modal-strategy-proposal-cooldown-ms').value = s.cooldowns.strategyProposalMs;
            document.getElementById('modal-enable-spoof-detection').checked = s.features.enableSpoofDetection;
            document.getElementById('modal-enable-cusum-drift').checked = s.features.enableCUSUMDrift;
            document.getElementById('modal-enable-risk-guardian').checked = s.features.enableRiskGuardian;
            document.getElementById('modal-enable-auto-optimize').checked = s.optimization.enabled;
            document.getElementById('modal-enable-auto-toggle-strat').checked = s.optimization.autoToggle;
            document.getElementById('modal-enable-breakeven-trail').checked = s.optimization.breakeven.enabled;
            document.getElementById('modal-be-at-r').value = s.optimization.breakeven.beAtR;
            document.getElementById('modal-trail-after-r').value = s.optimization.breakeven.trailAfterR;
            document.getElementById('modal-trail-to-r').value = s.optimization.breakeven.trailToR;
            document.getElementById('modal-enable-tts').checked = s.features.enableTTS;
            
            const enableCandleConfirmEl = document.getElementById('modal-enable-candle-confirm');
            if(enableCandleConfirmEl) enableCandleConfirmEl.checked = s.features.enableCandleConfirm;
            
            const enableMtfConfirmEl = document.getElementById('modal-enable-mtf-confirm');
            if(enableMtfConfirmEl) enableMtfConfirmEl.checked = s.features.enableMtfConfirm;
            
            const mtfTimeframeEl = document.getElementById('modal-mtf-timeframe');
            if(mtfTimeframeEl) mtfTimeframeEl.value = s.features.mtfTimeframe;
            
            const enableDynamicSizingEl = document.getElementById('modal-enable-dynamic-sizing');
            if(enableDynamicSizingEl) enableDynamicSizingEl.checked = s.features.enableDynamicSizing;
            
            this.updateTTSVoiceSelectUI(); 

            const strategyModalContainer = document.getElementById('modal-strategy-toggles');
            strategyModalContainer.innerHTML = '';
            this.allStrategyKeys.forEach(key => { 
                const strategy = this.strategies[key];
                if (!strategy) return;
                const isChecked = s.activeStrategies[key];
                const isShadowBanned = s.statusMaps.shadowBanned[key];
                const isHardBanned = s.statusMaps.hardBanned[key];
                
                let statusText = '';
                if (isHardBanned) statusText = ' (HARDBAN)';
                else if (isShadowBanned) statusText = ' (GÖLGE)';

                const toggleHtml = `<div class="form-group"><label class="checkbox-label"><input type="checkbox" class="strategy-toggle" data-strategy-key="${key}" ${isChecked ? 'checked' : ''} ${isHardBanned || isShadowBanned ? 'disabled' : ''}> ${strategy.displayName}${statusText}</label></div>`;
                strategyModalContainer.innerHTML += toggleHtml;
            });
            this.debouncedRender();
        }

                                                setupEventListeners() {
            document.getElementById('start-btn').addEventListener('click', () => this.start());
            document.getElementById('stop-btn').addEventListener('click', () => this.stop());
            document.getElementById('theme-toggle-btn').addEventListener('click', () => this.toggleTheme());
            document.getElementById('symbol-input').addEventListener('change', async (e) => {
                let newSymbol = e.target.value.toUpperCase().trim();
                if (!newSymbol.endsWith('USDT')) newSymbol += 'USDT';
                await this.changeSymbol(newSymbol);
                this.saveData('utc_current_symbol', newSymbol);
            });
            document.getElementById('timeframe-select').addEventListener('change', async (e) => {
                this.changeTimeframe(e.target.value);
                this.saveData('utc_current_timeframe', e.target.value);
            });
            
            document.querySelector('.header-center-title').addEventListener('dblclick', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('mobile-toggle-controls-btn').addEventListener('click', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });

            document.getElementById('main-controls-btn').addEventListener('click', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
            document.getElementById('heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
            document.getElementById('fullscreen-chart-btn').addEventListener('click', () => this.enterFullscreenChart());
            document.getElementById('exit-fullscreen-btn').addEventListener('click', () => this.exitFullscreenChart());

            document.getElementById('open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
            document.getElementById('clear-markers-btn').addEventListener('click', () => this.clearChartMarkers()); 
            document.getElementById('chart-zoom-in').addEventListener('click', () => this.chartManager.zoomIn());
            document.getElementById('chart-zoom-out').addEventListener('click', () => this.chartManager.zoomOut());
            document.getElementById('chart-zoom-reset').addEventListener('click', () => this.chartManager.resetZoom());
            document.getElementById('close-settings-modal-btn').addEventListener('click', () => this.closeSettingsModal());
            document.getElementById('settings-modal-overlay').addEventListener('click', (e) => { if (e.target.id === 'settings-modal-overlay') this.closeSettingsModal(); });
            
            // DÜZELTME: Yeni grafik butonu için olay dinleyici eklendi
            document.getElementById('mobile-chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
            document.getElementById('mobile-heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
            document.getElementById('mobile-fullscreen-chart-btn').addEventListener('click', () => this.enterFullscreenChart());
            document.getElementById('mobile-open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
            document.getElementById('mobile-honor-board-btn').addEventListener('click', () => this.openHonorModal());
            document.getElementById('mobile-banned-board-btn').addEventListener('click', () => this.openHonorModal('banned'));
            // YENİ: Log Paneli butonları için olay dinleyicileri
            document.getElementById('mobile-open-log-modal-btn').addEventListener('click', () => {
                document.getElementById('log-modal-overlay').classList.add('visible');
            });
            document.getElementById('close-log-modal-btn').addEventListener('click', () => {
                document.getElementById('log-modal-overlay').classList.remove('visible');
            });
            document.getElementById('export-logs-btn').addEventListener('click', () => this.exportLogs());


            const s = this.settings;
            document.getElementById('modal-confluence-threshold').addEventListener('input', (e) => s.confluenceThreshold = parseInt(e.target.value));
            document.getElementById('modal-param-rsi-period').addEventListener('change', (e) => s.params.rsiPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-atr-period').addEventListener('change', (e) => s.params.atrPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-wall-btc').addEventListener('change', (e) => s.params.wallBtc = parseInt(e.target.value));
            document.getElementById('modal-param-rr-ratio').addEventListener('change', (e) => s.params.rrRatio = parseFloat(e.target.value));
            document.getElementById('modal-signal-cooldown-ms').addEventListener('change', (e) => s.cooldowns.signalMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-same-direction-cooldown-ms').addEventListener('change', (e) => s.cooldowns.sameDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-opposite-direction-cooldown-ms').addEventListener('change', (e) => s.cooldowns.oppositeDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-reverse-hysteresis-points').addEventListener('change', (e) => s.cooldowns.reverseHysteresisPoints = parseInt(e.target.value) || 0);
            document.getElementById('modal-proposal-timeout-ms').addEventListener('change', (e) => s.cooldowns.proposalTimeoutMs = parseInt(e.target.value) || 1000);
            document.getElementById('modal-strategy-proposal-cooldown-ms').addEventListener('change', (e) => s.cooldowns.strategyProposalMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-enable-spoof-detection').addEventListener('change', (e) => s.features.enableSpoofDetection = e.target.checked);
            document.getElementById('modal-enable-cusum-drift').addEventListener('change', (e) => s.features.enableCUSUMDrift = e.target.checked);
            document.getElementById('modal-enable-risk-guardian').addEventListener('change', (e) => s.features.enableRiskGuardian = e.target.checked);
            document.getElementById('modal-enable-auto-optimize').addEventListener('change', (e) => s.optimization.enabled = e.target.checked);
            document.getElementById('modal-enable-auto-toggle-strat').addEventListener('change', (e) => s.optimization.autoToggle = e.target.checked);
            document.getElementById('modal-enable-breakeven-trail').addEventListener('change', (e) => s.optimization.breakeven.enabled = e.target.checked);
            document.getElementById('modal-be-at-r').addEventListener('change', (e) => s.optimization.breakeven.beAtR = parseFloat(e.target.value));
            document.getElementById('modal-trail-after-r').addEventListener('change', (e) => s.optimization.breakeven.trailAfterR = parseFloat(e.target.value));
            document.getElementById('modal-trail-to-r').addEventListener('change', (e) => s.optimization.breakeven.trailToR = parseFloat(e.target.value));
            document.getElementById('modal-enable-tts').addEventListener('change', (e) => {
                s.features.enableTTS = e.target.checked;
                this.updateTTSVoiceSelectUI();
            });
            document.getElementById('modal-tts-voice-select').addEventListener('change', (e) => {
                s.features.preferredVoiceName = e.target.value === "" ? null : e.target.value;
                this.saveSettings();
                if (e.target.value !== "") this.speak("Ses başarıyla değiştirildi.", { lang: 'tr-TR', rate: 1.0 });
            });
            const enableCandleConfirmEl = document.getElementById('modal-enable-candle-confirm');
            if(enableCandleConfirmEl) enableCandleConfirmEl.addEventListener('change', (e) => s.features.enableCandleConfirm = e.target.checked);
            
            const enableMtfConfirmEl = document.getElementById('modal-enable-mtf-confirm');
            if(enableMtfConfirmEl) enableMtfConfirmEl.addEventListener('change', (e) => s.features.enableMtfConfirm = e.target.checked);
            
            const mtfTimeframeEl = document.getElementById('modal-mtf-timeframe');
            if(mtfTimeframeEl) mtfTimeframeEl.addEventListener('change', (e) => s.features.mtfTimeframe = e.target.value);
            
            const enableDynamicSizingEl = document.getElementById('modal-enable-dynamic-sizing');
            if(enableDynamicSizingEl) enableDynamicSizingEl.addEventListener('change', (e) => s.features.enableDynamicSizing = e.target.checked);


            document.getElementById('modal-strategy-toggles').addEventListener('change', (e) => {
                if (e.target.classList.contains('strategy-toggle')) {
                    const key = e.target.dataset.strategyKey;
                    if (s.statusMaps.hardBanned[key] || s.statusMaps.shadowBanned[key]) {
                        e.target.checked = !e.target.checked; 
                        return;
                    }
                    s.activeStrategies[key] = e.target.checked;
                    this.updateActiveStrategies();
                    this.showNotification(`${this.strategies[key].displayName} ${e.target.checked ? 'aktif' : 'pasif'}.`, 'info');
                    this.saveSettings();
                }
            });

            document.getElementById('modal-clear-signals-btn').addEventListener('click', () => this.clearAllSignals());
            document.getElementById('reset-all-settings-btn').addEventListener('click', () => this.resetAllSettings());
            document.getElementById('save-settings-btn').addEventListener('click', () => { this.saveSettings(); this.showNotification('Ayarlar kaydedildi!', 'success'); this.closeSettingsModal(); });

            document.getElementById('honor-board-btn').addEventListener('click', () => this.openHonorModal());
            document.getElementById('banned-board-btn').addEventListener('click', () => this.openHonorModal('banned'));
            document.getElementById('close-honor-modal').addEventListener('click', () => this.closeHonorModal());
            document.getElementById('honor-modal-overlay').addEventListener('click', (e)=>{ if (e.target.id === 'honor-modal-overlay') this.closeHonorModal(); });
            
            const centerPanel = document.querySelector('.center-panel');
            const resizeHandle = centerPanel.querySelector('.resize-handle');
            if (resizeHandle) {
                let isResizing = false;
                const onMouseMove = (e) => {
                    if (!isResizing) return;
                    const containerRect = centerPanel.parentElement.getBoundingClientRect();
                    let newHeight = e.clientY - containerRect.top;
                    newHeight = Math.max(200, Math.min(containerRect.height - 150, newHeight));
                    centerPanel.style.height = `${newHeight}px`;
                    window.dispatchEvent(new Event('resize')); 
                };
                const onMouseUp = () => {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    document.body.style.cursor = 'ns-resize';
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
            }
        }






        toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            let newTheme;
            
            if (currentTheme === 'dark') {
                newTheme = 'light';
            } else if (currentTheme === 'light') {
                newTheme = 'war';
                this.enterCombatMode();
            } else {
                newTheme = 'dark';
                this.exitCombatMode();
            }
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('utc_theme', newTheme);
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
        }
        
        enterCombatMode() {
            this.combatModeActive = true;
            this.speak(this.getRandomMessage('combatModeActivate'));
            
            // Görsel efektler
            const overlay = document.createElement('div');
            overlay.id = 'war-mode-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle at center, rgba(255,50,50,0.2), transparent 80%);
                z-index: 9999;
                pointer-events: none;
                animation: warPulse 3s infinite;
            `;
            
            const style = document.createElement('style');
            style.id = 'war-mode-animation';
            style.innerHTML = `
                @keyframes warPulse {
                    0% { opacity: 0.3; }
                    50% { opacity: 0.7; }
                    100% { opacity: 0.3; }
                }
                
                @keyframes war-pulse {
                    0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
                    70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
                    100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
                }
            `;
            
            document.head.appendChild(style);
            document.body.appendChild(overlay);
        }
        
        exitCombatMode() {
            this.combatModeActive = false;
            this.speak(this.getRandomMessage('combatModeDeactivate'));
            
            // Efektleri temizle
            const overlay = document.getElementById('war-mode-overlay');
            const style = document.getElementById('war-mode-animation');
            
            if (overlay) overlay.remove();
            if (style) style.remove();
        }
        toggleControlsPanel() {
            document.body.classList.toggle('header-collapsed');
            this.headerCollapsed = document.body.classList.contains('header-collapsed'); 
            setTimeout(() => { window.dispatchEvent(new Event('resize')); }, 360);
        }
        switchMainView(viewName) {
            this.currentMainView = viewName;
            const chartView = document.getElementById('chart-container-view');
            const heatmapView = document.getElementById('heatmap-container-view');
            const chartCountdownOverlay = document.getElementById('chart-countdown-overlay');

            if (viewName === 'chart') {
                chartView.classList.remove('hidden-view');
                heatmapView.classList.add('hidden-view');
                chartCountdownOverlay.classList.remove('hidden-view');
            } else {
                chartView.classList.add('hidden-view');
                heatmapView.classList.remove('hidden-view');
                chartCountdownOverlay.classList.add('hidden-view');
            }
            setTimeout(() => window.dispatchEvent(new Event('resize')), 50);
        }
        enterFullscreenChart() {
            document.body.classList.add('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.remove('hidden-view');
            document.getElementById('chart-countdown-overlay').classList.remove('hidden-view');
            window.dispatchEvent(new Event('resize'));
        }
        exitFullscreenChart() {
            document.body.classList.remove('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.add('hidden-view');
            if (this.currentMainView !== 'chart') {
                document.getElementById('chart-countdown-overlay').classList.add('hidden-view');
            }
            window.dispatchEvent(new Event('resize'));
        }

        openSettingsModal() { this.updateSettingsModalUI(); document.getElementById('settings-modal-overlay').classList.add('visible'); }
        closeSettingsModal() { document.getElementById('settings-modal-overlay').classList.remove('visible'); this.updateActiveStrategies(); this.calculateAllIndicators(); window.dispatchEvent(new Event('resize')); }

        resetAllSettings() {
            if (confirm('Tüm ayarları ve sinyal geçmişini sıfırlamak istediğinizden emin misiniz? Bu işlem geri alınamaz.')) {
                localStorage.clear();
                window.location.reload();
            }
        }

        async start() {
            if (this.isRunning) return;
            this.isRunning = true; 
            document.getElementById('start-btn').disabled = true; 
            document.getElementById('stop-btn').disabled = false;
            
            // MultiTimeframeManager'ı güvenli bir şekilde başlat
            if (this.settings.features.enableMtfConfirm && this.multiTimeframeManager) {
                try {
                    // Önce multiTimeframeManager'ın hazır olduğundan emin ol
                    if (typeof this.multiTimeframeManager.initialize === 'function') {
                        await this.multiTimeframeManager.initialize(this.currentSymbol, [this.settings.features.mtfTimeframe]);
                    } else if (typeof this.multiTimeframeManager.init === 'function') {
                        // initialize metodu yoksa init metodunu dene
                        await this.multiTimeframeManager.init();
                    }
                } catch (error) {
                    console.warn('MultiTimeframeManager başlatılırken hata:', error);
                    // Hata olsa bile sistem çalışmaya devam etsin
                }
            }
            
            this.showNotification('Sistem Başlatıldı: Canlı veri akışı başlatılıyor...', 'success');
            this.speak(this.getRandomMessage('systemStart'));
            await this.fetchInitialData(); 
            this.connectWebSockets();
            
            this.renderInterval = setInterval(() => this.render(), 250);
            this.analysisInterval = setInterval(() => this.runPeriodicAnalysis(), 5000);
            
            // Piyasa manipülasyonu tespiti her 30 saniyede bir çalıştır
            this.manipulationDetectInterval = setInterval(() => this.detectMarketManipulation(), 30000);
            
            // Enerji Yönetim Sistemini başlat
            if (!this.energyManager) {
                this.energyManager = new EnergyManager(this);
            }
            
            // Ritüel Sistemini başlat
            if (!this.ritualManager) {
                this.ritualManager = new RitualManager(this);
            }
            
            if (this.settings.optimization.enabled) {
                this.cooldownTuneInterval = setInterval(() => this.autoTuneCooldowns(), 30000); 
                this.thresholdTuneInterval = setInterval(() => this.autoTuneThresholds(), 30000); 
                this.paramTuneInterval = setInterval(() => this.autoTuneStrategyParams(), 5 * 60 * 1000);
                this.autoToggleStrategiesInterval = setInterval(() => this.autoToggleStrategies(), 5 * 60 * 1000);
            }
        }

        stop() {
            if (!this.isRunning) return;
            this.isRunning = false; 
            document.getElementById('start-btn').disabled = false; 
            document.getElementById('stop-btn').disabled = true; 
            this.disconnectWebSockets();
            if (this.renderInterval) clearInterval(this.renderInterval); 
            if (this.analysisInterval) clearInterval(this.analysisInterval);
            if (this.manipulationDetectInterval) clearInterval(this.manipulationDetectInterval);
            if (this.cooldownTuneInterval) clearInterval(this.cooldownTuneInterval);
            if (this.thresholdTuneInterval) clearInterval(this.thresholdTuneInterval);
            if (this.paramTuneInterval) clearInterval(this.paramTuneInterval);
            if (this.autoToggleStrategiesInterval) clearInterval(this.autoToggleStrategiesInterval);
            
            this.multiTimeframeManager.cleanup();
            this.updateConnectionStatus(false, "BAĞLANTI KESİLDİ"); 
            if (this.combatModeActive) this.deactivateCombatMode();
            this.showNotification('Sistem Durduruldu.', 'danger');
            this.speak(this.getRandomMessage('systemStop'));
        }
        
        detectMarketManipulation() {
            if (!this.manipulationDetector) {
                this.manipulationDetector = new MarketManipulationDetector(this);
            }
            
            const detection = this.manipulationDetector.detect();
            
            if (detection) {
                // Manipülasyon tespiti!
                this.showNotification(`PİYASA MANİPÜLASYONU TESPİT EDİLDİ: ${detection.message}`, 'warning');
                
                // Savaş modunu etkinleştir
                if (!this.combatModeActive) {
                    this.activateCombatMode();
                }
                
                // TTS ile sesli uyarı
                this.speak(`Dikkat! Piyasa manipülasyonu tespit edildi. ${detection.message} Koruyucu önlemler alınıyor.`);
                
                // Düşük skora sahip önerileri temizle ve yüksek risk içeren işlemleri filtrele
                this.confluenceEngine.proposals = this.confluenceEngine.proposals.filter(p => p.score >= 7);
                
                // Olay günlüğüne kaydet
                console.warn(`[Manipülasyon Tespiti ${new Date().toLocaleTimeString()}] ${detection.message}`);
                
                return detection;
            }
            
            return false;
        }

        async changeSymbol(newSymbol) {
            if (this.currentSymbol === newSymbol) return;
            this.currentSymbol = newSymbol; 
            this.showNotification(`${this.currentSymbol.replace('USDT', '/USDT')} sembolüne geçildi.`, 'info');
            this.speak(this.getRandomMessage('symbolChange', { 'Sembol': this.currentSymbol.replace('USDT', '') }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); }
            this.updateSuperTopTicker(); 
        }
        async changeTimeframe(newTimeframe) {
            this.currentTimeframe = newTimeframe; 
            this.showNotification(`Zaman aralığı ${this.currentTimeframe} olarak değiştirildi.`, 'info');
            this.speak(this.getRandomMessage('timeframeChange', { 'Timeframe': this.currentTimeframe }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); }
        }
                resetDataForNewSymbol() {
            // --- YENİ: Grafik hafızasını temizle ---
            localStorage.removeItem('utc_chart_view');

            this.candles = []; this.aggTrades = []; this.marketData.price = 0; 
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null, bbands: null };
            this.pendingSignals = [];
            this.chartManager.setData([]); this.chartManager.clearMarkers(); this.render();
            this.heatmapManager.draw({bids:[], asks:[]}, 0);
        }


        async fetchInitialData() {
            try {
                this.logToJournal(`${this.currentSymbol} için geçmiş mum verileri çekiliyor...`);
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=${this.currentTimeframe}&limit=500`;
                const response = await fetch(url); if (!response.ok) throw new Error(`API Hatası: ${response.statusText}`);
                const data = await response.json();
                this.candles = data.map(d => ({ time: d[0], open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]), }));
                this.chartManager.setData(this.candles); this.logToJournal(`${this.candles.length} adet mum yüklendi.`);
                this.calculateAllIndicators();
            } catch (error) { this.showNotification(`Geçmiş veri alınamadı: ${error.message}`, 'danger'); console.error("Geçmiş veri hatası:", error); }
        }

        connectWebSockets() {
            this.disconnectWebSockets(); 
            this.reconnectAttempts = 0;
            const symbolLower = this.currentSymbol.toLowerCase();
            const streams = [`${symbolLower}@ticker`, `${symbolLower}@depth20@100ms`, `${symbolLower}@aggTrade`, `${symbolLower}@kline_${this.currentTimeframe}`];
            const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams.join('/')}`); 
            this.sockets['main'] = ws;
            
            ws.onopen = () => { this.updateConnectionStatus(true); this.reconnectAttempts = 0; this.logToJournal("WebSocket bağlantısı başarıyla kuruldu."); };
            ws.onmessage = (event) => { const message = JSON.parse(event.data); this.handleMarketData(message.stream, message.data); };
            ws.onerror = (error) => console.error('WebSocket Hatası:', error);
            ws.onclose = () => { 
                if (this.isRunning) { 
                    this.reconnectAttempts++;
                    this.reconnectDelay = Math.min(30000, 3000 * Math.pow(2, this.reconnectAttempts - 1));
                    const message = `YENİDEN BAĞLANILIYOR... (${this.reconnectDelay / 1000}s)`;
                    this.updateConnectionStatus(false, message); 
                    this.logToJournal(`Bağlantı kapandı. ${this.reconnectDelay/1000} saniye sonra yeniden denenecek. (Deneme: ${this.reconnectAttempts})`);
                    setTimeout(() => this.connectWebSockets(), this.reconnectDelay); 
                } 
            };
        }
        disconnectWebSockets() { 
            if (this.sockets['main']) { 
                this.sockets['main'].onclose = null;
                this.sockets['main'].close(1000, "İstemci tarafından kapatıldı"); 
                delete this.sockets['main'];
            }
        }

        handleMarketData(stream, data) {
            const streamType = stream.split('@')[1];
            if (streamType === 'ticker') {
                this.marketData.price = parseFloat(data.c);
                this.marketData.change24h = parseFloat(data.P);
                this.marketData.volume24h = parseFloat(data.q);
                this.marketData.symbol = data.s;
                if (data.s === 'BTCUSDT') this.marketData.btcPrice = parseFloat(data.c);
                this.manageOpenPositions();
                this.checkAutoCloseSignals();
            } 
            else if (streamType.startsWith('depth')) {
                this.orderBook = { 
                    bids: data.b.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    asks: data.a.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    lastUpdateId: data.u 
                };
                this.marketData.lastOrderBook = this.orderBook; // Store for OSIRIS and other features
                this.heatmapManager.draw(this.orderBook, this.marketData.price);
                if(this.settings.features.enableSpoofDetection) this.spoofDetector.trackOrderBook(this.orderBook);
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].analyzeOrderBook === 'function') {
                        this.strategies[key].analyzeOrderBook(this.orderBook);
                    }
                }
            } else if (streamType.startsWith('kline')) {
                if (this.candles.length > 0) {
                    const kline = data.k;
                    const lastCandleInArray = this.candles[this.candles.length - 1];
                    const currentCandleData = { time: kline.t, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c), volume: parseFloat(kline.v) };
                    
                    if (lastCandleInArray && lastCandleInArray.time === currentCandleData.time) {
                        this.candles[this.candles.length - 1] = currentCandleData;
                    } else {
                         this.candles.push(currentCandleData);
                    }

                    this.chartManager.updateRealtime(kline);

                    if (kline.x) { // Mum kapandı
                        if (this.candles[this.candles.length -1].time !== currentCandleData.time) {
                            this.candles.push(currentCandleData);
                        }
                        if (this.candles.length > 501) this.candles.shift(); 
                        
                        this.checkPendingSignals(currentCandleData);
                        this.calculateAllIndicators(); 
                    }
                    this.manageOpenPositions();
                    this.checkAutoCloseSignals();
                }
            } else if (streamType === 'aggTrade') {
                const trade = { price: parseFloat(data.p), quantity: parseFloat(data.q), isBuyerMaker: data.m, timestamp: data.T };
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].processTrade === 'function') {
                        this.strategies[key].processTrade(trade);
                    }
                }
            }
        }
        
                runPeriodicAnalysis() { 
            if (!this.isRunning) return; 
            try {
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].periodicAnalyze === 'function') {
                        this.strategies[key].periodicAnalyze(); 
                    }
                }
                if (this.settings.features.enableRiskGuardian) this.riskGuardian.checkKillSwitch();

                // --- YENİ: SPOOF DETECTOR OPTİMİZASYONUNU ÇAĞIR ---
                if (this.settings.features.enableSpoofDetection) {
                    this.spoofDetector.checkConfirmations();
                    this.spoofDetector.autoOptimizeThreshold();
                }
                // --- BİTTİ ---

            } catch (error) {
                console.error('Periodic analysis error:', error);
                this.showNotification('Analiz hatası! Loglara bakın.', 'danger');
            }
        }

        
                calculateAllIndicators() {
            if (this.candles.length === 0) return;
            const rsiPeriod = this.settings.params.rsiPeriod;
            const atrPeriod = this.settings.params.atrPeriod;
            const bbandsPeriod = 20;

            const closes = this.candles.map(c => c.close);
            const highs = this.candles.map(c => c.high);
            const lows = this.candles.map(c => c.low);
            const volumes = this.candles.map(c => c.volume);
            const candleTimes = this.candles.map(c => c.time);

            // RSI
            if (closes.length >= rsiPeriod) {
                this.indicators.rsi = this.calculateRSI(closes, rsiPeriod);
            } else { this.indicators.rsi = []; } 

            // ATR
            if (this.candles.length >= atrPeriod) {
                this.indicators.atr = this.calculateATR(this.candles, atrPeriod);
            } else { this.indicators.atr = null; }

            // Bollinger Bands (ORİJİNAL HALİNE DÖNDÜRÜLDÜ)
            if (closes.length >= bbandsPeriod) {
                this.indicators.bbands = this.calculateBB(closes, candleTimes, bbandsPeriod, 2);
                this.chartManager.drawBollingerBands(this.indicators.bbands);
            } else { this.indicators.bbands = null; }

            const sma = (arr, n) => arr.length < n ? null : arr.slice(-n).reduce((a,b)=>a+b,0)/n;
            this.indicators.sma20 = sma(closes, 20);
            this.indicators.sma50 = sma(closes, 50);
            this.indicators.volSma20 = sma(volumes, 20);

            let cumPV = 0, cumV = 0;
            for (const k of this.candles) { const tp = (k.high + k.low + k.close)/3; cumPV += tp * k.volume; cumV += k.volume; }
            this.indicators.vwap = cumV ? (cumPV / cumV) : null;

            this.indicators.adx = this.calcADX(this.candles, atrPeriod);
            const adx = this.indicators.adx;
            if (adx) {
                if (adx.adx > 25) this.marketRegime = 'trend';
                else if (adx.adx < 20) this.marketRegime = 'range';
                else this.marketRegime = 'transition';
            } else { this.marketRegime = 'unknown'; }
        }


        calculateRSI(prices, period) {
            let gains = 0; let losses = 0;
            const rsi = [];
            let prevAvgGain = 0;
            let prevAvgLoss = 0;

            if (prices.length < period + 1) return [];

            for (let i = 1; i <= period; i++) {
                const diff = prices[i] - prices[i - 1];
                if (diff > 0) gains += diff; else losses -= diff;
            }
            prevAvgGain = gains / period;
            prevAvgLoss = losses / period;
            const initialRs = prevAvgLoss === 0 ? Infinity : prevAvgGain / prevAvgLoss;
            rsi.push(100 - (100 / (1 + initialRs))); 

            for (let i = period + 1; i < prices.length; i++) {
                const diff = prices[i] - prices[i - 1];
                const gain = diff > 0 ? diff : 0;
                const loss = diff < 0 ? -diff : 0;
                
                prevAvgGain = (prevAvgGain * (period - 1) + gain) / period;
                prevAvgLoss = (prevAvgLoss * (period - 1) + loss) / period;
                
                const rs = prevAvgLoss === 0 ? Infinity : prevAvgGain / prevAvgLoss;
                const rsiValue = 100 - (100 / (1 + rs));
                rsi.push(rsiValue);
            }
            return rsi;
        }

        calculateATR(candles, period) {
            if (candles.length < period + 1) return null;
            let trs = [];
            for (let i = 1; i < candles.length; i++) {
                const c = candles[i], p = candles[i - 1];
                trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
            }
            if (trs.length < period) return null;
            
            let atr = trs.slice(0, period).reduce((a, b) => a + b, 0) / period;

            for (let i = period; i < trs.length; i++) {
                atr = (atr * (period - 1) + trs[i]) / period;
            }
            return atr;
        }

              calculateBB(prices, times, period, stdDev) {
            const result = { upper: [], middle: [], lower: [] };
            if (prices.length < period) return null;

            for (let i = period - 1; i < prices.length; i++) {
                const slice = prices.slice(i - period + 1, i + 1);
                const sma = slice.reduce((a, b) => a + b, 0) / period;
                const std = Math.sqrt(
                    slice.map(p => Math.pow(p - sma, 2)).reduce((a, b) => a + b, 0) / period
                );
                result.middle.push({ time: times[i], value: sma });
                result.upper.push({ time: times[i], value: sma + (std * stdDev) });
                result.lower.push({ time: times[i], value: sma - (std * stdDev) });
            }
            return result;
        }



        calcADX(candles, period = 14) {
            if (!candles || candles.length < period * 2) return null; 
            const trs = [], plusDMs = [], minusDMs = [];
            for (let i = 1; i < candles.length; i++) {
                const c = candles[i], p = candles[i-1];
                trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
                const upMove = c.high - p.high;
                const downMove = p.low - c.low;
                plusDMs.push((upMove > downMove && upMove > 0) ? upMove : 0);
                minusDMs.push((downMove > upMove && downMove > 0) ? downMove : 0);
            }
            const smooth = (arr) => {
                const smoothed = [arr.slice(0, period).reduce((a, b) => a + b, 0) / period];
                for (let i = period; i < arr.length; i++) {
                    smoothed.push((smoothed[smoothed.length - 1] * (period - 1) + arr[i]) / period);
                }
                return smoothed;
            };
            const sTR = smooth(trs);
            const sPlusDM = smooth(plusDMs);
            const sMinusDM = smooth(minusDMs);

            if (sTR.length === 0 || sPlusDM.length === 0 || sMinusDM.length === 0) return null;

            const plusDIs = sPlusDM.map((val, idx) => 100 * (val / (sTR[idx] || 1e-8)));
            const minusDIs = sMinusDM.map((val, idx) => 100 * (val / (sTR[idx] || 1e-8)));
            
            const dxs = plusDIs.map((pdi, idx) => 100 * Math.abs(pdi - minusDIs[idx]) / ((pdi + minusDIs[idx]) || 1e-8));
            
            if (dxs.length < period) return null;

            const adxValues = smooth(dxs.slice(period - 1));
            
            if (!adxValues || adxValues.length === 0) return null;
            return {
                adx: adxValues[adxValues.length-1],
                pdi: plusDIs[plusDIs.length-1],
                mdi: minusDIs[minusDIs.length-1]
            };
        }

        getOrderBookSnapshotInfo() {
            const ob = this.orderBook;
            if (!ob || !ob.bids || ob.bids.length === 0 || !ob.asks || ob.asks.length === 0) return null;
            const bestBid = ob.bids[0][0], bestAsk = ob.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            const topN = this.settings.optimization.gating.topN || 5;
            const sumUsd = (levels) => levels.slice(0, topN).reduce((s,[p,q])=> s + (p*q), 0);
            const topBidUsd = sumUsd(ob.bids);
            const topAskUsd = sumUsd(ob.asks);
            const minTopUsd = Math.min(topBidUsd, topAskUsd);
            return { spreadPct, minTopUsd };
        }
        marketGatingPenalty(direction) {
            const info = this.getOrderBookSnapshotInfo();
            if (!info || !this.settings.optimization.gating.enabled) return 0;
            const g = this.settings.optimization.gating;
            let penalty = 0;
            if (info.spreadPct > g.spreadMaxPct) penalty += 1.5; 
            if (info.minTopUsd < g.minDepthUsd) penalty += 1.5; 
            return penalty;
        }

        getEffectiveThreshold() { return (this.settings.confluenceThreshold || 3) + (this.runtimeThresholdOffset || 0); }

        calculateDynamicTpSl(signal) {
            const atr = this.indicators.atr;
            let rrRatioBase = this.settings.params.rrRatio;
            const minTh = this.getEffectiveThreshold();
            const over = Math.max(0, (signal.score - minTh));
            rrRatioBase *= (1 + Math.min(0.3, over / 10)); 

            if (this.marketRegime === 'trend') rrRatioBase *= 1.1;
            if (this.marketRegime === 'range') rrRatioBase *= 0.95;

            if (!atr || atr === 0) { 
                signal.tp = signal.direction === 'buy' ? signal.price * (1 + 0.005) : signal.price * (1 - 0.005);
                signal.sl = signal.direction === 'buy' ? signal.price * (1 - 0.005 / rrRatioBase) : signal.price * (1 + 0.005 / rrRatioBase);
            } else {
                const atrMultiplier = 1.5 - (Math.min(10, Math.max(0, signal.score)) / 20);
                const slDistance = atr * atrMultiplier;
                const tpDistance = slDistance * rrRatioBase;
                if (signal.direction === 'buy') { signal.sl = signal.price - slDistance; signal.tp = signal.price + tpDistance; }
                else { signal.sl = signal.price + slDistance; signal.tp = signal.price - tpDistance; }
                signal.entrySlDistance = slDistance;
                signal.entryTpDistance = tpDistance;
            }
        }

        manageOpenPositions() {
            if (!this.isRunning || !this.marketData.price || !this.settings.optimization.breakeven.enabled) return;
            const price = this.marketData.price;
            const atr = this.indicators.atr;
            if (!atr) return; 

            let changed = false;
            const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
            for (const s of activeSignals) {
                if (!s.entrySlDistance || s.entrySlDistance <= 0) continue; 
                const rNow = s.direction === 'buy' ? (price - s.price) / s.entrySlDistance : (s.price - price) / s.entrySlDistance;
                s.mfeR = Math.max(s.mfeR || 0, rNow); 
                const settings = this.settings.optimization.breakeven;

                if (!s.beDone && s.mfeR >= (settings.beAtR || 0.8)) {
                    s.sl = s.price; 
                    s.beDone = true;
                    s.note = (s.note ? s.note + ' | ' : '') + 'SL->BE';
                    changed = true;
                    this.showNotification(`Sinyal ${s.id.substring(4,10)} için SL maliyete çekildi.`, 'info');
                }
                if (s.mfeR >= (settings.trailAfterR || 1.5) && (s.trailingStage || 0) < 1) {
                    let newSl;
                    if (s.direction === 'buy') {
                        newSl = price - (atr * settings.trailToR); 
                        s.sl = Math.min(s.tp, Math.max(s.sl, newSl)); 
                    } else { 
                        newSl = price + (atr * settings.trailToR); 
                        s.sl = Math.max(s.tp, Math.min(s.sl, newSl)); 
                    }
                    s.trailingStage = 1;
                    s.note = (s.note ? s.note + ' | ' : '') + 'Trail1';
                    changed = true;
                    this.showNotification(`Sinyal ${s.id.substring(4,10)} için SL güncellendi (Trailing).`, 'info');
                }
            }
            if (changed) { this.saveData('utc_signals', this.signals); this.debouncedRender(); }
        }

        checkAutoCloseSignals() {
            if (!this.isRunning || !this.marketData.price) return;
            const price = this.marketData.price;
            const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
            for (const s of activeSignals) {
                if (s.direction === 'buy') {
                    if (price >= s.tp) { this.updateSignalResult(s.id, 'tp'); }
                    else if (price <= s.sl) { this.updateSignalResult(s.id, 'sl'); }
                } else if (s.direction === 'sell') {
                    if (price <= s.tp) { this.updateSignalResult(s.id, 'tp'); }
                    else if (price >= s.sl) { this.updateSignalResult(s.id, 'sl'); }
                }
            }
        }

        render() { 
            this.renderPriceDisplay(); 
            this.updateSignalProgressBar(); 
        }
        renderPriceDisplay() {
            const priceEl = document.getElementById('current-price');
            const tickerPriceEl = document.getElementById('ticker-bar-price');
            const oldPriceText = tickerPriceEl ? tickerPriceEl.textContent.replace(/,/g, '') : '0';
            const oldPrice = parseFloat(oldPriceText);
            
            if (this.marketData.price) {
                const formattedPrice = this.formatPrice(this.marketData.price);
                if (priceEl) priceEl.textContent = formattedPrice;
                if(tickerPriceEl) tickerPriceEl.textContent = formattedPrice;

                if (!isNaN(oldPrice) && oldPrice !== 0) { 
                    const color = this.marketData.price > oldPrice ? 'var(--positive)' : (this.marketData.price < oldPrice ? 'var(--negative)' : '');
                    if (tickerPriceEl) {
                        tickerPriceEl.style.transition = 'none';
                        tickerPriceEl.style.color = color;
                        setTimeout(() => {
                           tickerPriceEl.style.transition = 'color 0.5s ease';
                           tickerPriceEl.style.color = '';
                        }, 100);
                    }
                }
            }
            const change = this.marketData.change24h || 0;
            const changeEl = document.getElementById('price-change-24h');
            if (changeEl) { changeEl.textContent = `${change.toFixed(2)}%`; changeEl.style.color = change >= 0 ? 'var(--positive)' : 'var(--negative)'; }
            const volumeEl = document.getElementById('volume-24h'); if(volumeEl) volumeEl.textContent = this.formatVolume(this.marketData.volume24h);
            const atrEl = document.getElementById('atr-value'); if(atrEl) atrEl.textContent = this.indicators.atr ? this.indicators.atr.toFixed(this.getDecimalPlaces(this.indicators.atr)) : '-';
        }

        updateCandleCountdown() {
            const headerCountdownEl = document.getElementById('candle-countdown');
            const chartCountdownEl = document.getElementById('chart-countdown-overlay');

            if (!this.isRunning || this.candles.length === 0) {
                headerCountdownEl.textContent = '--:--';
                chartCountdownEl.textContent = '--:--';
                return;
            }
            const now = Date.now();
            const lastCandleOpenTime = this.candles[this.candles.length - 1].time; 
            const timeframeMs = this._timeframeToMs(this.currentTimeframe);
            
            const nextCandleOpenTime = lastCandleOpenTime + timeframeMs;
            let remainingTime = nextCandleOpenTime - now;
            
            if (remainingTime < 0 || remainingTime > timeframeMs) {
                 remainingTime = timeframeMs - (now % timeframeMs);
            }

            remainingTime = Math.max(0, remainingTime); 
            const minutes = Math.floor(remainingTime / 60000);
            const seconds = Math.floor((remainingTime % 60000) / 1000);
            const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            headerCountdownEl.textContent = formattedTime;
            if (this.currentMainView === 'chart' || document.body.classList.contains('fullscreen-chart')) {
                chartCountdownEl.textContent = formattedTime;
                chartCountdownEl.classList.remove('hidden-view');
            } else {
                chartCountdownEl.classList.add('hidden-view');
            }
        }
         _timeframeToMs(tf) {
            const unit = tf.slice(-1);
            const val = parseInt(tf.slice(0, -1));
            if (unit === 'm') return val * 60 * 1000;
            if (unit === 'h') return val * 60 * 60 * 1000;
            if (unit === 'd') return val * 24 * 60 * 60 * 1000;
            return 60000;
        }

        updateSignalProgressBar() {
            const buyFill = document.getElementById('buy-signal-bar-fill');
            const sellFill = document.getElementById('sell-signal-bar-fill');
            const buyScoreText = document.getElementById('buy-signal-score-text');
            const sellScoreText = document.getElementById('sell-signal-score-text');
            if (!buyFill || !sellFill || !buyScoreText || !sellScoreText) return;

            const maxScoreForDisplay = 10; 
            const buyScore = this.confluenceEngine.buyScore || 0;
            const sellScore = this.confluenceEngine.sellScore || 0;

            const buyPercent = Math.min(100, Math.max(0, (buyScore / maxScoreForDisplay) * 100));
            const sellPercent = Math.min(100, Math.max(0, (sellScore / maxScoreForDisplay) * 100));

            buyFill.style.width = `${buyPercent}%`;
            sellFill.style.width = `${sellPercent}%`;

            buyScoreText.textContent = isFinite(buyScore) ? buyScore.toFixed(1) : '0.0';
            sellScoreText.textContent = isFinite(sellScore) ? sellScore.toFixed(1) : '0.0';
        }

        addPendingSignal(signal) {
            this.pendingSignals.push(signal);
            this.chartManager.addSignalMarker(signal);
            this.showNotification(`ADAY SİNYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '/USDT')} | Skor: ${signal.score.toFixed(1)}. Mum kapanışı bekleniyor.`, 'warning', 4000);
        }

        checkPendingSignals(closedCandle) {
            const signalsToActivate = [];
            this.pendingSignals = this.pendingSignals.filter(signal => {
                if (signal.timestamp < closedCandle.time) {
                    let isValid = false;
                    if (signal.direction === 'buy' && closedCandle.close > closedCandle.open) {
                        isValid = true;
                    } else if (signal.direction === 'sell' && closedCandle.close < closedCandle.open) {
                        isValid = true;
                    }
                    
                    if (isValid) {
                        signalsToActivate.push(signal);
                    } else {
                        this.showNotification(`İPTAL: ${signal.direction.toUpperCase()} sinyali mum kapanışında onaylanmadı.`, 'danger', 3000);
                    }
                    return false;
                }
                return true;
            });
            signalsToActivate.forEach(signal => this.activateSignal(signal));
        }

        activateSignal(signal) {
            // Confluence Engine'den sinyali doğrula
            if (this.confluenceEngine && !this.confluenceEngine.validateSignal(signal)) {
                this.showNotification(`SİNYAL REDDEDİLDİ: Confluence puanı yetersiz`, 'warning', 3000);
                return;
            }
            
            signal.status = 'active';
            this.signals.unshift(signal); 
            if (this.signals.length > 200) this.signals.pop();
            
            // Verileri kaydet
            this.saveData('utc_signals', this.signals);
            
            // Veritabanına sinyali kaydet
            if (this.dbManager && this.dbManager.ready) {
                this.dbManager.put('signals', {
                    ...signal,
                    savedAt: Date.now()
                });
            }
            
            // UI'yi güncelle
            this.debouncedRender();
            this.chartManager.addSignalMarker(signal);
            
            // Bildirim göster
            let sizeText = signal.recommendedSize ? ` | Boyut: ${signal.recommendedSize}` : '';
            this.showNotification(`AKTİF SİNYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '/USDT')} | Skor: ${signal.score.toFixed(1)}${sizeText}`, signal.direction === 'buy' ? 'success' : 'danger');
            
            // Ses efektleri
            playSignal(signal.direction); 
            const messageKey = signal.direction === 'buy' ? 'buy' : 'sell';
            const message = this.getRandomMessage(messageKey, { 
                Sembol: signal.symbol.replace('USDT', ''), 
                Skor: signal.score.toFixed(1) 
            });
            this.speak(message);
            
            // Yüksek skorlu sinyal için savaş modunu aktifleştir
            if (signal.score >= 8 && !this.combatModeActive) { 
                this.activateCombatMode(); 
            }
            
            // Görsel efektler
            if (this.effectsManager) {
                const pricePos = this.chartManager?.getPriceCoordinateForTimestamp(signal.timestamp) || {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2
                };
                
                this.effectsManager.createExplosionEffect(
                    pricePos.x, 
                    pricePos.y, 
                    signal.direction === 'buy' ? '#00ff00' : '#ff0000',
                    signal.score * 3 // Skor ne kadar yüksekse, o kadar büyük patlama efekti
                );
            }
            
            // Panteon sistemine güç ekle
            if (this.panteonManager) {
                // Stratejiye göre farklı elçilere güç ekle
                this.panteonManager.awardPowerForSignal(signal);
            }
            
            // Event'i emit et
            this.emit('signal', signal);
            
            // Oracle ile entegrasyon - Mahşerin Atlıları aktifse ek bildirim göster
            if (this.oracle && this.oracle.isAnyHorsemanActive()) {
                const activeHorsemen = this.oracle.getActiveHorsemen();
                const horsemanNames = activeHorsemen.map(key => this.oracle.getHorsemanName(key)).join(", ");
                
                setTimeout(() => {
                    this.showNotification(`DİKKAT: Mahşerin ${activeHorsemen.length > 1 ? 'Atlıları' : 'Atlısı'} (${horsemanNames}) aktif! Risk yüksek olabilir.`, 'warning', 5000);
                }, 1000);
            }
        }

        getRecommendedPositionSize(score) {
            if(!this.settings.features.enableDynamicSizing) return null;
            if (score >= 7.5) return "2.0x Yüksek";
            if (score >= 6.0) return "1.5x Orta-Yüksek";
            if (score >= 4.5) return "1.0x Standart";
            return "0.5x Düşük";
        }

        updateSignalResult(signalId, result) {
            const signalIndex = this.signals.findIndex(s => s.id === signalId);
            if(signalIndex !== -1 && this.signals[signalIndex].status === 'active') {
                const signal = this.signals[signalIndex];
                signal.status = result;
                signal.completedAt = Date.now();
                this.stats.total++;
                this.stats[result]++;
                
                // İstatistikleri güncelle
                this.updateStrategyStats(signal);
                this.updateStrategyShadowStats(signal);
                this.evaluateShadowRehab();
                
                // Veritabanında güncelle
                if (this.dbManager && this.dbManager.ready) {
                    // Sinyali güncelle
                    this.dbManager.put('signals', {
                        ...signal,
                        updatedAt: Date.now()
                    });
                    
                    // İstatistikleri güncelle
                    this.dbManager.put('stats', {
                        id: 'global',
                        data: this.stats,
                        updatedAt: Date.now()
                    });
                }
                
                // Event'i emit et
                this.emit('signalResult', { signal, result });
                
                // Panteon sistemine sonuç bildir
                if (this.panteonManager) {
                    if (result === 'tp') {
                        // Başarılı sinyal için daha fazla güç
                        this.panteonManager.increasePower('metatron', 10);
                        
                        // Başarılı bir sinyal için efekt
                        if (this.effectsManager) {
                            this.effectsManager.createMatrixEffect();
                        }
                    } else if (result === 'sl') {
                        // Kaybedilen sinyal için şifacıya güç
                        this.panteonManager.increasePower('raphael', 5);
                    }
                }

                if (this.settings.features.enableCUSUMDrift) {
                    const driftDetected = this.cusumDetector.update(result === 'tp');
                    if (driftDetected) {
                        this.showNotification('PERFORMANS SAPMASI!', 'Sinyal kazanma oranında sapma tespit edildi. Ayarlar optimize ediliyor...', 'warning');
                        this.speak(this.getRandomMessage('cusumDriftDetected'));
                    }
                }

                this.saveData('utc_signals', this.signals);
                this.saveData('utc_stats', this.stats);
                this.debouncedRender();
                this.showNotification(`Sinyal ${signal.id.substring(4,10)} - ${result.toUpperCase()} olarak sonuçlandı.`, 'info');
                const messageKey = result === 'tp' ? 'signalTP' : 'signalSL';
                this.speak(this.getRandomMessage(messageKey));
            }
        }

        updateStrategyStats(signal) {
            const isWin = signal.status === 'tp';
            const contributors = signal.contributors || [];
            if(contributors.length === 0) return;
            const totalEff = contributors.reduce((s, c) => s + (c.effScore || (c.baseScore * (c.weight||1))), 0) || 1;
            const decay = 0.995; 

            for (const c of contributors) {
                let stratStats = this.strategyStats[c.strategy];
                if (!stratStats) {
                    stratStats = this.initDefaultStrategyStats()[c.strategy];
                    this.strategyStats[c.strategy] = stratStats;
                }
                
                const updateStat = (statObj) => {
                    statObj.alpha = (statObj.alpha || 3) * decay; 
                    statObj.beta = (statObj.beta || 2) * decay;   
                    const credit = (c.effScore || (c.baseScore * (c.weight || 1))) / totalEff; 
                    statObj.contrib = (statObj.contrib || 0) + 1;
                    if (isWin) { statObj.wins = (statObj.wins || 0) + credit; statObj.alpha += credit; }
                    else { statObj.losses = (statObj.losses || 0) + credit; statObj.beta += credit; }
                    statObj.lastUpdate = Date.now();
                };

                updateStat(stratStats.overall);
                const currentRegimeStats = stratStats[this.marketRegime];
                if (currentRegimeStats) {
                    updateStat(currentRegimeStats);
                }
            }
            this.saveStrategyStats();
        }

        recordShadowProposal(strategy, direction, reason, score) {
            const now = Date.now();
            this.shadowProposals.push({ strategy, direction, reason, score, timestamp: now });
            if (this.shadowProposals.length > 2000) this.shadowProposals.splice(1500); 
        }

        updateStrategyShadowStats(signal) {
            const windowMs = (this.settings.cooldowns?.proposalTimeoutMs || 3000) * 2;
            const start = signal.timestamp - windowMs;
            const end = signal.timestamp;
            const creditBase = 0.5;

            const byStrat = {};
            for (const p of this.shadowProposals) {
                if (p.timestamp >= start && p.timestamp <= end && p.direction === signal.direction) {
                    byStrat[p.strategy] = p;
                }
            }
            for (const strat of Object.keys(byStrat)) {
                let stratStats = this.strategyStats[strat];
                if (!stratStats) {
                    stratStats = this.initDefaultStrategyStats()[strat];
                    this.strategyStats[strat] = stratStats;
                }
                
                const updateStat = (statObj) => {
                    statObj.shadowProposals = (statObj.shadowProposals || 0) + 1;
                    if (signal.status === 'tp') {
                        statObj.shadowWins = (statObj.shadowWins || 0) + 1;
                        statObj.alpha = (statObj.alpha || 3) + creditBase;
                    } else if (signal.status === 'sl') {
                        statObj.shadowLosses = (statObj.shadowLosses || 0) + 1;
                        statObj.beta = (statObj.beta || 2) + creditBase;
                    }
                    statObj.lastUpdate = Date.now();
                };
                
                updateStat(stratStats.overall);
                const currentRegimeStats = stratStats[this.marketRegime];
                if (currentRegimeStats) {
                    updateStat(currentRegimeStats);
                }
            }
            const keepAfter = Date.now() - 10 * 60 * 1000;
            this.shadowProposals = this.shadowProposals.filter(p => p.timestamp >= keepAfter);
            this.saveStrategyStats();
        }

                evaluateShadowRehab() {
            const pen = this.settings.penalties || {};
            if (!pen.shadowEnabled) return;

            for (const key of this.allStrategyKeys) {
                if (!this.settings.statusMaps.shadowBanned[key] || this.settings.statusMaps.hardBanned[key]) continue;

                const st = this.strategyStats[key]?.overall || {};
                const sw = st.shadowWins || 0,
                    sl = st.shadowLosses || 0,
                    sp = st.shadowProposals || 0;
                const total = sw + sl;
                const winRate = total > 0 ? sw / total : 0;

                if (sp >= (pen.minShadowProposals || 20) && winRate >= (pen.rehabWinRate || 0.58)) {
                    this.settings.activeStrategies[key] = true;
                    this.settings.statusMaps.shadowBanned[key] = false;
                    this.updateActiveStrategies();
                    this.saveSettings();
                    this.showNotification(`Rehabilite: ${this.strategies[key].displayName} tekrar canlı! (gölge WR=${(winRate*100).toFixed(0)}%)`, 'success');
                    
                    // --- EKSİK OLAN SATIR BURAYA EKLENDİ ---
                    this.speak(this.getRandomMessage('shadowRehab', { 'Strateji': this.strategies[key].displayName }));
                }
            }
        }


                autoToggleStrategies() {
            if (!this.settings.optimization.enabled || !this.settings.optimization.autoToggle) return;
            const now = Date.now();
            if (now - this.lastAutoToggleTs < 5 * 60 * 1000) return;
            this.lastAutoToggleTs = now;
            const minW = this.settings.optimization.minWeightToStay || 0.6;
            const minContrib = this.settings.optimization.minContribForToggle || 30;

            let changed = false;
            for (const key of this.allStrategyKeys) {
                const w = this.getStrategyWeight(key);
                const stat = this.strategyStats[key]?.overall || {};
                const active = !!this.settings.activeStrategies[key];

                if (active && !this.settings.statusMaps.hardBanned[key] && w < minW && (stat.contrib || 0) >= minContrib) {
                    this.settings.activeStrategies[key] = false;
                    this.settings.statusMaps.shadowBanned[key] = true;
                    this.showNotification(`Oto-optimizasyon: ${this.strategies[key].displayName} gölgeye alındı (w=${w.toFixed(2)}).`, 'warning');
                    
                    // --- EKSİK OLAN SATIR BURAYA EKLENDİ ---
                    this.speak(this.getRandomMessage('shadowBan', { 'Strateji': this.strategies[key].displayName }));
                    
                    changed = true;
                }
            }
            if (changed) {
                this.updateActiveStrategies();
                this.saveSettings();
                this.updateSettingsModalUI();
            }
        }


        autoTuneCooldowns() {
            if (!this.isRunning || !this.settings.optimization.enabled) return;
            const now = Date.now();
            const WINDOW_MS = 5 * 60 * 1000; 
            const recentSignals = this.signals.filter(s => s.status !== 'active' && s.symbol === this.currentSymbol && now - s.timestamp <= WINDOW_MS).slice(0, 50).sort((a,b)=> a.timestamp - b.timestamp);
            let quickFlips = 0, totalPairs = 0;
            if (recentSignals.length >= 2) {
                for (let i = 1; i < recentSignals.length; i++) {
                    totalPairs++;
                    const dt = recentSignals[i].timestamp - recentSignals[i-1].timestamp;
                    if (recentSignals[i-1].direction !== recentSignals[i].direction && dt <= 15000) { 
                        quickFlips++;
                    }
                }
            }
            const flipRatio = totalPairs ? (quickFlips / totalPairs) : 0;
            const volPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0.001;

            const cd = this.settings.cooldowns;
            const baseSame = this.loadSettings().cooldowns.sameDirectionMs;
            const baseOpp = this.loadSettings().cooldowns.oppositeDirectionMs;
            const baseSignal = this.loadSettings().cooldowns.signalMs;
            const baseProposalTimeout = this.loadSettings().cooldowns.proposalTimeoutMs;

            const newSame = Math.max(10000, Math.min(120000, Math.round(baseSame * (1 + flipRatio * 0.8))));
            const newOpp  = Math.max(5000, Math.min(120000, Math.round(baseOpp  * (1 + flipRatio * 1.2))));
            const volFactor = volPct < 0.005 ? 1.2 : (volPct > 0.02 ? 0.8 : 1.0);
            const newSignal = Math.max(3000, Math.min(60000, Math.round(baseSignal * volFactor)));
            const newProposalTimeout = Math.max(1500, Math.min(8000, Math.round(baseProposalTimeout * volFactor)));

            let changed = false;
            if (Math.abs(newSame - cd.sameDirectionMs) / cd.sameDirectionMs > 0.05) { cd.sameDirectionMs = newSame; changed = true; }
            if (Math.abs(newOpp - cd.oppositeDirectionMs) / cd.oppositeDirectionMs > 0.05) { cd.oppositeDirectionMs = newOpp; changed = true; }
            if (Math.abs(newSignal - cd.signalMs) / cd.signalMs > 0.05) { cd.signalMs = newSignal; changed = true; }
            if (Math.abs(newProposalTimeout - cd.proposalTimeoutMs) / cd.proposalTimeoutMs > 0.05) { cd.proposalTimeoutMs = newProposalTimeout; changed = true; }

            if (changed) {
                this.saveSettings();
                this.updateSettingsModalUI(); 
                this.showNotification(`Cooldown optimize edildi (flip: ${(flipRatio*100).toFixed(0)}%, vol: ${(volPct*100).toFixed(2)}%).`, 'info');
                this.speak(this.getRandomMessage('cooldownOptimize'));
            }
        }

        autoTuneThresholds() {
            if (!this.isRunning || !this.settings.optimization.enabled) return;
            const now = Date.now();
            const WINDOW_MS = 10 * 60 * 1000;
            const recentSignals = this.signals.filter(s => s.status !== 'active' && s.symbol === this.currentSymbol && now - s.timestamp <= WINDOW_MS).slice(0, 100);
            
            let winRate = recentSignals.length > 5 ? (recentSignals.filter(s => s.status === 'tp').length / recentSignals.length) : 0.55;
            let currentOffset = this.runtimeThresholdOffset || 0;
            let newOffset = currentOffset;

            if (winRate < 0.50) newOffset += 0.1;
            else if (winRate > 0.65) newOffset -= 0.1;
            
            newOffset = Math.max(-1.0, Math.min(2.0, newOffset));

            if (Math.abs(newOffset - currentOffset) > 0.05) {
                this.runtimeThresholdOffset = parseFloat(newOffset.toFixed(1));
                this.showNotification(`Sinyal eşiği optimize edildi: Yeni Ofset ${this.runtimeThresholdOffset.toFixed(1)} (WR: ${(winRate*100).toFixed(1)}%).`, 'info');
            }
        }

        autoTuneStrategyParams() {
            if (!this.settings.optimization.enabled) return;
            const step = 0.05;
            const meta = {
                wallBounce: { DISTANCE_THRESHOLD_PERCENT: {min:0.0001,max:0.001, strict:'down'} },
                velocityScalping: { VELOCITY_THRESHOLD_PERCENT:{min:0.0005,max:0.003, strict:'up'} },
                liquidityGaps: { GAP_THRESHOLD_PERCENT:{min:0.0003,max:0.003, strict:'up'} },
                breakoutPattern: { BREAK_PCT:{min:0.0001,max:0.001, strict:'up'}, VOL_SPIKE:{min:1.0,max:3.0, strict:'up'} },
                supportResistance: { THRESH:{min:0.0005,max:0.005, strict:'down'} },
                fibonacciRetracement: { TOL:{min:0.0005,max:0.005, strict:'down'} },
                vwapReversion: { MULT:{min:0.6,max:2.0, strict:'up'} },
                superTrend: { MULT:{min:1.0,max:6.0, strict:'up'} },
                marketStructure: { SWING:{min:2,max:7, strict:'up'} },
                institutionalOrderFlow: { IMB_THRESHOLD:{min:1.2,max:4.0, strict:'up'} },
                microSpreadArbitrage: { SPREAD_PCT:{min:0.0003,max:0.003, strict:'up'} },
                volumeProfile: { PERIOD: 20, SPIKE: 2.0, CLOSE_POS: 0.7 },
                divergenceDetection: { SWING_PERIOD:{min:2,max:5, strict:'up'} },
                volatilityBreakout: { SQUEEZE_MULT: {min:0.5,max:2.0, strict:'up'}, BREAKOUT_VOL_MULT: {min:1.0,max:3.0, strict:'up'} },
                candleCharacter: { MIN_BODY_TO_WICK_RATIO: {min:0.4,max:0.8, strict:'up'}, ANALYSIS_WINDOW_PERCENT: {min:0.1,max:0.3, strict:'down'} },
                fundingRateReversal: { EXTREME_FUNDING_THRESHOLD: {min:0.0005,max:0.002, strict:'up'} }
            };

            const p = this.settings.strategyParams;
            let changed = false;

            for (const key of this.allStrategyKeys) {
                const w = this.getStrategyWeight(key);
                const defs = meta[key]; if (!defs) continue;
                const currentParams = p[key] || {}; 
                let localChanged = false;
                const direction = (w < 0.7) ? 'moreStrict' : (w > 1.3 ? 'lessStrict' : 'keep');
                if (direction === 'keep') continue;

                for (const par of Object.keys(defs)) {
                    const conf = defs[par]; 
                    const val = currentParams[par] ?? this.strategies[key][par];
                    if (val == null) continue;

                    let newVal = val;
                    if (direction === 'moreStrict') {
                        if (conf.strict === 'up') newVal = val * (1 + step);
                        else if (conf.strict === 'down') newVal = val * (1 - step);
                    } else if (direction === 'lessStrict') {
                        if (conf.strict === 'up') newVal = val * (1 - step);
                        else if (conf.strict === 'down') newVal = val * (1 + step);
                    }
                    newVal = Math.max(conf.min, Math.min(conf.max, newVal));
                    
                    if (Math.abs(newVal - val) / Math.max(1e-8, val) > 0.001) {
                        currentParams[par] = Number.isInteger(val) ? Math.round(newVal) : parseFloat(newVal.toPrecision(4));
                        localChanged = true;
                    }
                }
                if (localChanged) { 
                    p[key] = currentParams; 
                    changed = true; 
                }
            }

            if (changed) {
                this.saveSettings();
                this.applyStrategyParamOverrides();
                this.showNotification('Strateji parametreleri mikro-optimize edildi (ameliyat).', 'warning');
            }
        }

        // DÜZELTME: Render fonksiyonları debounce ile çağrılacak
        debouncedRender() {
            clearTimeout(this.renderTimeout);
            this.renderTimeout = setTimeout(() => {
                this.renderSignals(true);
                this.renderStats(true);
            }, 200);
        }

        renderSignals(fullRender = false) {
            const tbody = document.getElementById('modal-signals-body');
            if (!tbody) return;
            if (fullRender) tbody.innerHTML = '';
            
            const signalsToRender = this.signals;

            signalsToRender.forEach((signal, index) => {
                const rowId = `signal-row-${signal.id}`;
                let row = document.getElementById(rowId);
                if(fullRender || !row) { 
                    if (row) row.remove();
                    row = tbody.insertRow(fullRender ? -1 : 0); // Tam render ise sona, değilse başa ekle
                    row.id = rowId;
                    for(let i=0; i<11; i++) row.insertCell();
                }

                row.className = signal.status === 'tp' ? 'signal-tp' : (signal.status === 'sl' ? 'signal-sl' : (signal.status === 'pending' ? 'signal-pending' : ''));
                row.cells[0].textContent = new Date(signal.timestamp).toLocaleTimeString();
                row.cells[1].textContent = signal.symbol.replace('USDT', '');
                row.cells[2].textContent = signal.direction.toUpperCase();
                row.cells[3].textContent = this.formatPrice(signal.price);
                row.cells[4].textContent = signal.tp ? this.formatPrice(signal.tp) : '-';
                row.cells[5].textContent = signal.sl ? this.formatPrice(signal.sl) : '-';
                row.cells[6].textContent = typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score;
                row.cells[7].textContent = signal.reason;
                row.cells[8].textContent = signal.recommendedSize || '-';
                row.cells[9].textContent = signal.status.toUpperCase();
                row.cells[10].textContent = signal.note || '';
            });
        }

        renderStats() {
            const statsContainer = document.getElementById('modal-stats-container');
            if (!statsContainer) return;

            const total = this.stats.total;
            const tp = this.stats.tp;
            const winRate = total > 0 ? ((tp / total) * 100).toFixed(1) : '0.0';

            const getWR = (stat) => {
                if (!stat) return '-';
                const totalObs = (stat.wins || 0) + (stat.losses || 0);
                if (totalObs === 0) return '-';
                return (((stat.wins || 0) / totalObs) * 100).toFixed(0);
            };

            const renderRegimeStats = (regime) => {
                let regimeTotal = 0, regimeWins = 0;
                Object.values(this.strategyStats).forEach(s => {
                    const stat = s[regime]; 
                    if(stat && (stat.wins !== undefined || stat.losses !== undefined)) { 
                        regimeWins += (stat.wins || 0);
                        regimeTotal += ((stat.wins || 0) + (stat.losses || 0));
                    }
                });
                const wr = regimeTotal > 0 ? (regimeWins / regimeTotal * 100).toFixed(0) : 'N/A';
                return `<div class="stat-item"><span class="stat-label">${regime.charAt(0).toUpperCase() + regime.slice(1)} WR:</span><span class="stat-value">${wr}%</span></div>`;
            };

            const html = `
                <div class="panel-title" style="margin-bottom: 10px;">Genel Sinyal İstatistikleri</div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0 15px;">
                    <div class="stat-item"><span class="stat-label">Toplam Sinyal:</span><span class="stat-value">${total}</span></div>
                    <div class="stat-item"><span class="stat-label">TP (Kazanılan):</span><span class="stat-value" style="color:var(--positive);">${tp}</span></div>
                    <div class="stat-item"><span class="stat-label">SL (Kaybedilen):</span><span class="stat-value" style="color:var(--negative);">${this.stats.sl}</span></div>
                    <div class="stat-item"><span class="stat-label">Kazanma Oranı:</span><span class="stat-value" style="color:${winRate >= 50 ? 'var(--positive)' : 'var(--negative)'};">${winRate}%</span></div>
                    ${renderRegimeStats('trend')}
                    ${renderRegimeStats('range')}
                </div>
                <div class="panel-title" style="margin-top: 15px; margin-bottom: 10px;">Strateji Performansı (Rejime Göre)</div>
                <div class="data-table-container" style="max-height: 250px;">
                    <table class="data-table">
                        <thead><tr><th>Strateji</th><th>Ağırlık</th><th>Genel WR%</th><th>Trend WR%</th><th>Range WR%</th><th>Katkı</th></tr></thead>
                        <tbody>
                            ${Object.keys(this.strategyStats).sort((a,b) => this.getStrategyWeight(b) - this.getStrategyWeight(a)).map(key => {
                                const s = this.strategyStats[key]; 
                                if (!s) return ''; 
                                const overallWR = getWR(s.overall);
                                const trendWR = getWR(s.trend);
                                const rangeWR = getWR(s.range);
                                return `
                                    <tr>
                                        <td>${this.strategies[key]?.displayName || key}</td>
                                        <td>${this.getStrategyWeight(key).toFixed(2)}</td>
                                        <td style="color:${overallWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${overallWR}</td>
                                        <td style="color:${trendWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${trendWR}</td>
                                        <td style="color:${rangeWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${rangeWR}</td>
                                        <td>${(s.overall?.contrib || 0)}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            statsContainer.innerHTML = html;
        }

        clearAllSignals() {
            if (confirm('Tüm sinyal geçmişini temizlemek istediğinizden emin misiniz?')) {
                this.signals = [];
                this.pendingSignals = [];
                this.stats = { total: 0, tp: 0, sl: 0 };
                this.saveData('utc_signals', this.signals);
                this.saveData('utc_stats', this.stats);
                this.debouncedRender();
                this.chartManager.clearMarkers();
                this.showNotification('Sinyal geçmişi temizlendi!', 'info');
            }
        }
        clearChartMarkers() { this.chartManager.clearMarkers(); this.showNotification('Grafik sinyalleri temizlendi.', 'info'); }

        formatPrice(price) { return price.toLocaleString('en-US', { minimumFractionDigits: this.getDecimalPlaces(price), maximumFractionDigits: this.getDecimalPlaces(price) }); }
        formatVolume(volume) { if (volume >= 1e9) return (volume / 1e9).toFixed(2) + 'B'; if (volume >= 1e6) return (volume / 1e6).toFixed(2) + 'M'; if (volume >= 1e3) return (volume / 1e3).toFixed(2) + 'K'; return volume.toFixed(2); }
        getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        
        showNotification(message, type = 'info', timeout = 5000) {
            // Map traditional notification types to new categories
            let category = 'system';
            let priority = 2;
            
            switch(type) {
                case 'success':
                    category = 'success';
                    priority = 3;
                    break;
                case 'danger':
                    category = 'error';
                    priority = 4;
                    break;
                case 'warning':
                    category = 'alert';
                    priority = 3;
                    break;
                case 'info':
                    if (message.toLowerCase().includes('sinyal')) {
                        category = 'trade';
                        priority = 3;
                    }
                    break;
            }
            
            // Detect important notifications
            if (message.toLowerCase().includes('tehlike') || 
                message.toLowerCase().includes('kritik') ||
                message.toLowerCase().includes('uyarı') ||
                message.toLowerCase().includes('dikkat') ||
                message.toLowerCase().includes('durdur')) {
                priority = 4;
            }
            
            // Use the new notification center if available
            if (this.notificationCenter) {
                return this.notificationCenter.notify(message, category, priority, timeout);
            } else {
                // Legacy fallback
                const container = document.getElementById('notifications-container');
                if (!container) return;
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                container.appendChild(notification);
                setTimeout(() => { notification.remove(); }, timeout);
                return notification;
            }
        }
                logToJournal(message, level = 'log') {
            const timestamp = new Date().toLocaleTimeString();
            const formattedMessage = `[${timestamp}] ${message}`;
            console.log(formattedMessage); // Konsola yazdırmaya devam et

            const logOutput = document.getElementById('log-output');
            if (logOutput) {
                const logEntry = document.createElement('div');
                logEntry.textContent = formattedMessage;
                if (level === 'error') logEntry.className = 'log-error';
                if (level === 'warn') logEntry.className = 'log-warn';
                if (level === 'info') logEntry.className = 'log-info';
                
                const isScrolledToBottom = logOutput.scrollHeight - logOutput.clientHeight <= logOutput.scrollTop + 1;
                logOutput.appendChild(logEntry);
                if (isScrolledToBottom) {
                    logOutput.scrollTop = logOutput.scrollHeight;
                }
            }
        }
        // YENİ: Logları dışa aktarma fonksiyonu
        exportLogs() {
            const logOutput = document.getElementById('log-output');
            if (!logOutput || !logOutput.textContent.trim()) {
                this.showNotification('Dışa aktarılacak log bulunmuyor.', 'warning');
                return;
            }
            const blob = new Blob([logOutput.textContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `utc_logs_${new Date().toISOString().slice(0,10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            this.showNotification('Loglar başarıyla dışa aktarıldı.', 'success');
        }

        updateConnectionStatus(isConnected, message = '') {
            const statusDot = document.getElementById('connection-status');
            const statusText = document.getElementById('connection-text');
            if (isConnected) {
                statusDot.classList.add('online');
                statusText.textContent = 'BAĞLI';
                statusText.style.color = 'var(--positive)';
            } else {
                statusDot.classList.remove('online');
                statusText.textContent = message || 'BAĞLANTI YOK';
                statusText.style.color = 'var(--negative)';
            }
        }

        updateSession() {
            this.sessionState = this.sessionProfiler.getCurrentSession();
        }

        activateCombatMode() {
            if (this.combatModeActive) return;
            this.combatModeActive = true;
            document.documentElement.setAttribute('data-theme', 'war');
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
            this.showNotification('SAVAŞ MODU AKTİF EDİLDİ!', 'danger');
            this.speak(this.getRandomMessage('combatModeActivate'));
            playSignal('combat');
        }

        deactivateCombatMode() {
            if (!this.combatModeActive) return;
            this.combatModeActive = false;
            const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
            this.showNotification('SAVAŞ MODU DEVRE DIŞI BIRAKILDI.', 'success');
            this.speak(this.getRandomMessage('combatModeDeactivate'));
        }

        loadVoices() {
            this.voices = this.synth.getVoices();
            this.updateTTSVoiceSelectUI();
        }

        updateTTSVoiceSelectUI() {
            const selectEl = document.getElementById('modal-tts-voice-select');
            if (!selectEl) return;
            const currentVoice = this.settings.features.preferredVoiceName;
            selectEl.innerHTML = '<option value="">Otomatik Seç</option>';
            if (this.voices.length > 0) {
                 this.voices.forEach(voice => {
                    if (voice.lang.startsWith('tr')) {
                        const option = document.createElement('option');
                        option.value = voice.name;
                        option.textContent = `${voice.name} (${voice.lang})`;
                        if (currentVoice === voice.name) {
                            option.selected = true;
                        }
                        selectEl.appendChild(option);
                    }
                });
            }
        }
        getRandomMessage(key, replacements = {}) {
            const messages = this.speechTexts[key];
            if (!messages || messages.length === 0) {
                console.warn(`'${key}' için konuşma metni bulunamadı.`);
                return `Varsayılan mesaj: ${key}`;
            }
            let message = messages[Math.floor(Math.random() * messages.length)];

            for (const placeholder in replacements) {
                const regex = new RegExp(`\\[${placeholder}\\]`, 'g');
                message = message.replace(regex, replacements[placeholder]);
            }
            return message;
        }

        // DÜZELTME: TTS Kuyruk Mekanizması
        speak(text, options = {}) {
            if (!this.synth || !this.settings.features.enableTTS) return;
            this.speechQueue.push({ text, options });
            if (!this.isSpeaking) {
                this.processSpeechQueue();
            }
        }

        processSpeechQueue() {
            if (this.speechQueue.length === 0) {
                this.isSpeaking = false;
                return;
            }
            this.isSpeaking = true;
            const { text, options } = this.speechQueue.shift();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = options.rate || 1.1; 
            utterance.pitch = options.pitch || 1.0; 
            utterance.volume = options.volume || 0.8; 
            utterance.lang = options.lang || 'tr-TR'; 

            const preferredVoice = this.voices.find(v => v.name === this.settings.features.preferredVoiceName);
            if (preferredVoice) {
                utterance.voice = preferredVoice;
            } else {
                            const turkishVoice = this.voices.find(v => v.lang.startsWith('tr-'));
            if (turkishVoice) utterance.voice = turkishVoice;
        }
        
        utterance.onend = () => {
            setTimeout(() => this.processSpeechQueue(), 300); // Sesler arası kısa bir bekleme
        };
        
        utterance.onerror = (event) => {
            console.error('SpeechSynthesis Hata:', event.error);
            this.isSpeaking = false; // Hata durumunda kuyruğu serbest bırak
            this.processSpeechQueue(); // Bir sonraki öğeyi dene
        };

        this.synth.speak(utterance);
    }

    openHonorModal(filter = 'all') {
        const el = document.getElementById('honor-modal-body');
        const honor = [], shame = [], banned = [];
        const minContrib = 10; 

        for (const key of this.allStrategyKeys) {
            const st = this.strategyStats[key]?.overall || {};
            const w = this.getStrategyWeight(key);
            const active = !!this.settings.activeStrategies[key];
            const isShadow = !!this.settings.statusMaps.shadowBanned[key];
            const isHard = !!this.settings.statusMaps.hardBanned[key];
            const contrib = (st.contrib || 0);
            const totalObs = (st.wins || 0) + (st.losses || 0);
            const wr = totalObs > 0 ? ((st.wins || 0) / totalObs * 100) : 0;

            const row = {
                key, name: this.strategies[key]?.displayName || key, w, wr, contrib, status: isHard ? 'HARDBAN' : (isShadow ? 'GÖLGE' : (active ? 'CANLI' : 'PASİF'))
            };

            if (isHard || isShadow) banned.push(row);
            if (!isShadow && !isHard) {
                if (w >= 1.1 && totalObs >= minContrib) honor.push(row);
                else if (w <= 0.8 && totalObs >= minContrib) shame.push(row);
            }
        }
        
        const pickRogue = shame.sort((a,b) => a.w - b.w)[0];

        const renderList = (title, arr, empty = '-') => `
            <div class="panel-title" style="margin:6px 0;">${title}</div>
            <div class="data-table-container" style="max-height:240px;">
            <table class="data-table">
                <thead><tr><th>Strateji</th><th>w</th><th>WR%</th><th>Katkı</th><th>Durum</th><th>Aksiyon</th></tr></thead>
                <tbody>
                ${arr.length ? arr.map(r => `
                    <tr>
                    <td>${r.name}</td><td>${r.w.toFixed(2)}</td><td>${r.wr.toFixed(0)}</td><td>${r.contrib}</td><td>${r.status}</td>
                    <td>
                        <button class="btn btn-tiny" onclick="window.app.toggleShadow('${r.key}')">${this.settings.statusMaps.shadowBanned[r.key] ? 'Gölgeden Al' : 'Gölgeye Al'}</button>
                        <button class="btn btn-tiny ${this.settings.statusMaps.hardBanned[r.key] ? 'btn-danger' : ''}" onclick="window.app.toggleHardBan('${r.key}')">${this.settings.statusMaps.hardBanned[r.key] ? 'Unban' : 'HardBan'}</button>
                    </td>
                    </tr>
                `).join('') : `<tr><td colspan="6">${empty}</td></tr>`}
                </tbody>
            </table></div>`;

        let html = '';
        if (filter === 'banned') {
            html += renderList('Banlılar (Gölge/HardBan)', banned, 'Kimse banlı değil.');
        } else {
            if (pickRogue) {
                html += `<div class="notification danger" style="position:relative; margin-bottom:10px;">Günün şerefsizi: <b>${pickRogue.name}</b> (w=${pickRogue.w.toFixed(2)})</div>`;
                this.speak(this.getRandomMessage('rogueOfDay', { 'Strateji': pickRogue.name }));
            }
            html += renderList('Şerefli (güçlüler)', honor.sort((a,b)=>b.w-a.w));
            html += renderList('Şerefsizler (zayıflar)', shame.sort((a,b)=>a.w-b.w));
            html += renderList('Banlılar (Gölge/HardBan)', banned);
        }

        el.innerHTML = html;
        document.getElementById('honor-modal-overlay').style.display = 'flex';
        this.lastHonorModalFilter = filter;
    }

    closeHonorModal() { document.getElementById('honor-modal-overlay').style.display = 'none'; }

    toggleShadow(key) {
        const cur = !!this.settings.statusMaps.shadowBanned[key];
        this.settings.statusMaps.shadowBanned[key] = !cur;
        if (cur) {
            if (!this.settings.statusMaps.hardBanned[key]) {
                this.settings.activeStrategies[key] = true;
            }
        } else {
            this.settings.activeStrategies[key] = false;
        }
        this.updateActiveStrategies();
        this.saveSettings();
        this.openHonorModal(this.lastHonorModalFilter);
        this.showNotification(`${this.strategies[key].displayName} ${cur ? 'gölgeden alındı' : 'gölgeye alındı'}.`, 'info');
        this.speak(this.getRandomMessage(cur ? 'shadowRehab' : 'shadowBan', { 'Strateji': this.strategies[key].displayName }));
    }

    toggleHardBan(key) {
        const cur = !!this.settings.statusMaps.hardBanned[key];
        this.settings.statusMaps.hardBanned[key] = !cur;
        if (this.settings.statusMaps.hardBanned[key]) {
            this.settings.statusMaps.shadowBanned[key] = true;
            this.settings.activeStrategies[key] = false;
        } else {
            this.settings.statusMaps.shadowBanned[key] = false;
        }
        this.updateActiveStrategies();
        this.saveSettings();
        this.openHonorModal(this.lastHonorModalFilter);
        this.showNotification(`${this.strategies[key].displayName} ${cur ? 'hardbandan çıkarıldı' : 'hardban edildi'}.`, cur ? 'success' : 'danger');
    }

    // DÜZELTME: Performans izleme fonksiyonu
    startPerformanceMonitor() {
        this.performanceMonitorInterval = setInterval(() => {
            if (performance.memory) {
                const memUsage = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
                this.logToJournal(`Performans: Bellek=${memUsage}MB, Sinyaller=${this.signals.length}, Bekleyenler=${this.pendingSignals.length}`);
            }
        }, 30000);
    }
}

// Uygulamayı başlat
window.app = new UltimateTradingCommandCenter();

/* =================================================================
   ADVANCED VISUALIZATION TOOLS
   ================================================================= */
class AdvancedTradingVisualizer {
    constructor(app) {
        this.app = app;
        this.isInitialized = false;
        this.heatmapEnabled = false;
        this.volumeProfileEnabled = false;
        this.liquidityHeatmapEnabled = false;
        this.orderFlowEnabled = false;
        this.marketStructureVisualization = false;
        this.optionsOverlayEnabled = false;
        this.supportResistanceLevels = [];
        this.fibonacciLevels = [];
        this.pivotPoints = [];
        this.init();
    }
    
    init() {
        if (this.isInitialized) return;
        
        // Initialize visualization components
        this.addVisualizationButtons();
        
        // Create necessary canvas layers
        this.createAdditionalCanvasLayers();
        
        // Bind events
        this.bindEvents();
        
        this.isInitialized = true;
        console.log('Advanced Trading Visualization Tools initialized');
    }
    
    createAdditionalCanvasLayers() {
        // Create order flow canvas layer
        const orderFlowCanvas = document.createElement('canvas');
        orderFlowCanvas.id = 'order-flow-canvas';
        orderFlowCanvas.style.position = 'absolute';
        orderFlowCanvas.style.top = '0';
        orderFlowCanvas.style.left = '0';
        orderFlowCanvas.style.width = '100%';
        orderFlowCanvas.style.height = '100%';
        orderFlowCanvas.style.pointerEvents = 'none';
        orderFlowCanvas.style.display = 'none';
        orderFlowCanvas.style.zIndex = '5';
        
        // Create volume profile canvas
        const volumeProfileCanvas = document.createElement('canvas');
        volumeProfileCanvas.id = 'volume-profile-canvas';
        volumeProfileCanvas.style.position = 'absolute';
        volumeProfileCanvas.style.top = '0';
        volumeProfileCanvas.style.right = '0';
        volumeProfileCanvas.style.width = '80px';
        volumeProfileCanvas.style.height = '100%';
        volumeProfileCanvas.style.pointerEvents = 'none';
        volumeProfileCanvas.style.display = 'none';
        volumeProfileCanvas.style.zIndex = '6';
        
        // Add to chart container
        const chartContainer = document.getElementById('live-chart');
        if (chartContainer) {
            chartContainer.style.position = 'relative';
            chartContainer.appendChild(orderFlowCanvas);
            chartContainer.appendChild(volumeProfileCanvas);
        }
    }
    
    addVisualizationButtons() {
        // Create visualization controls container
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'visualization-controls';
        controlsContainer.style.position = 'absolute';
        controlsContainer.style.top = '50px';
        controlsContainer.style.right = '10px';
        controlsContainer.style.display = 'flex';
        controlsContainer.style.flexDirection = 'column';
        controlsContainer.style.gap = '5px';
        controlsContainer.style.zIndex = '100';
        
        // Add buttons
        const buttons = [
            { id: 'toggle-heatmap-btn', icon: '🔥', title: 'Toggle Heatmap' },
            { id: 'toggle-volume-profile-btn', icon: '📊', title: 'Toggle Volume Profile' },
            { id: 'toggle-liquidity-btn', icon: '💧', title: 'Toggle Liquidity Visualization' },
            { id: 'toggle-order-flow-btn', icon: '📈', title: 'Toggle Order Flow' },
            { id: 'toggle-market-structure-btn', icon: '🔍', title: 'Toggle Market Structure' },
            { id: 'toggle-options-overlay-btn', icon: '🔄', title: 'Toggle Options Overlay' }
        ];
        
        buttons.forEach(btn => {
            const button = document.createElement('button');
            button.id = btn.id;
            button.className = 'btn-tiny visualization-btn';
            button.innerHTML = btn.icon;
            button.title = btn.title;
            button.style.width = '28px';
            button.style.height = '28px';
            button.style.padding = '2px';
            button.style.fontSize = '14px';
            button.style.background = 'rgba(1, 4, 9, 0.7)';
            button.style.backdropFilter = 'blur(2px)';
            button.style.border = '1px solid var(--border-color)';
            button.style.borderRadius = '4px';
            button.style.color = 'var(--text-main)';
            button.style.cursor = 'pointer';
            button.style.display = 'flex';
            button.style.alignItems = 'center';
            button.style.justifyContent = 'center';
            controlsContainer.appendChild(button);
        });
        
        // Add to chart container
        const chartContainer = document.getElementById('live-chart');
        if (chartContainer) {
            chartContainer.style.position = 'relative';
            chartContainer.appendChild(controlsContainer);
        }
    }
    
    bindEvents() {
        // Bind click events to visualization buttons
        document.getElementById('toggle-heatmap-btn')?.addEventListener('click', () => this.toggleHeatmap());
        document.getElementById('toggle-volume-profile-btn')?.addEventListener('click', () => this.toggleVolumeProfile());
        document.getElementById('toggle-liquidity-btn')?.addEventListener('click', () => this.toggleLiquidityHeatmap());
        document.getElementById('toggle-order-flow-btn')?.addEventListener('click', () => this.toggleOrderFlow());
        document.getElementById('toggle-market-structure-btn')?.addEventListener('click', () => this.toggleMarketStructure());
        document.getElementById('toggle-options-overlay-btn')?.addEventListener('click', () => this.toggleOptionsOverlay());
        
        // Resize event
        window.addEventListener('resize', () => this.handleResize());
    }
    
    toggleHeatmap() {
        this.heatmapEnabled = !this.heatmapEnabled;
        document.getElementById('toggle-heatmap-btn')?.classList.toggle('active', this.heatmapEnabled);
        if (this.heatmapEnabled) {
            this.app.switchMainView('heatmap');
        } else {
            this.app.switchMainView('chart');
        }
    }
    
    toggleVolumeProfile() {
        this.volumeProfileEnabled = !this.volumeProfileEnabled;
        document.getElementById('toggle-volume-profile-btn')?.classList.toggle('active', this.volumeProfileEnabled);
        const volumeProfileCanvas = document.getElementById('volume-profile-canvas');
        if (volumeProfileCanvas) {
            volumeProfileCanvas.style.display = this.volumeProfileEnabled ? 'block' : 'none';
        }
        if (this.volumeProfileEnabled) {
            this.drawVolumeProfile();
        }
    }
    
    toggleLiquidityHeatmap() {
        this.liquidityHeatmapEnabled = !this.liquidityHeatmapEnabled;
        document.getElementById('toggle-liquidity-btn')?.classList.toggle('active', this.liquidityHeatmapEnabled);
        // Implementation of liquidity heatmap visualization
        if (this.liquidityHeatmapEnabled) {
            this.app.showNotification('Liquidity heatmap activated', 'info');
            this.analyzeLiquidity();
        }
    }
    
    toggleOrderFlow() {
        this.orderFlowEnabled = !this.orderFlowEnabled;
        document.getElementById('toggle-order-flow-btn')?.classList.toggle('active', this.orderFlowEnabled);
        const orderFlowCanvas = document.getElementById('order-flow-canvas');
        if (orderFlowCanvas) {
            orderFlowCanvas.style.display = this.orderFlowEnabled ? 'block' : 'none';
        }
        if (this.orderFlowEnabled) {
            this.drawOrderFlow();
        }
    }
    
    toggleMarketStructure() {
        this.marketStructureVisualization = !this.marketStructureVisualization;
        document.getElementById('toggle-market-structure-btn')?.classList.toggle('active', this.marketStructureVisualization);
        if (this.marketStructureVisualization) {
            this.app.showNotification('Market structure visualization activated', 'info');
            this.analyzeMarketStructure();
        } else {
            // Clear market structure markers
            if (this.app.chartManager && this.app.chartManager.series && this.app.chartManager.series.candles) {
                // Remove market structure lines
                this.app.chartManager.series.candles.setMarkers(this.app.chartManager.signalMarkers); // Reset to only signal markers
            }
        }
    }
    
    toggleOptionsOverlay() {
        this.optionsOverlayEnabled = !this.optionsOverlayEnabled;
        document.getElementById('toggle-options-overlay-btn')?.classList.toggle('active', this.optionsOverlayEnabled);
        if (this.optionsOverlayEnabled) {
            this.app.showNotification('Options data overlay activated', 'info');
            this.fetchOptionsData();
        }
    }
    
    handleResize() {
        if (this.volumeProfileEnabled) {
            this.drawVolumeProfile();
        }
        if (this.orderFlowEnabled) {
            this.drawOrderFlow();
        }
    }
    
    drawVolumeProfile() {
        const canvas = document.getElementById('volume-profile-canvas');
        if (!canvas || !this.app.candles || this.app.candles.length < 10) return;
        
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        // Resize canvas to match its display size
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Get price range from visible candles
        const candles = this.app.candles;
        const minPrice = Math.min(...candles.map(c => c.low));
        const maxPrice = Math.max(...candles.map(c => c.high));
        const priceRange = maxPrice - minPrice;
        
        // Calculate volume at different price levels
        const priceLevels = 40; // Number of price levels
        const volumeByPrice = new Array(priceLevels).fill(0);
        
        candles.forEach(candle => {
            const priceRange = candle.high - candle.low;
            if (priceRange === 0) return;
            
            // Distribute volume across price range
            for (let i = 0; i < priceLevels; i++) {
                const levelPrice = minPrice + (i / priceLevels) * (maxPrice - minPrice);
                if (levelPrice >= candle.low && levelPrice <= candle.high) {
                    // Weight by proximity to close price
                    const weight = 1 - Math.abs(levelPrice - candle.close) / priceRange;
                    volumeByPrice[i] += candle.volume * weight;
                }
            }
        });
        
        // Find max volume for scaling
        const maxVolume = Math.max(...volumeByPrice);
        
        // Draw volume profile
        ctx.fillStyle = 'rgba(100, 100, 255, 0.5)';
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
        ctx.lineWidth = 1;
        
        for (let i = 0; i < priceLevels; i++) {
            const y = canvas.height - (i / priceLevels) * canvas.height;
            const volumeWidth = (volumeByPrice[i] / maxVolume) * canvas.width;
            
            ctx.fillRect(0, y, volumeWidth, canvas.height / priceLevels);
            ctx.strokeRect(0, y, volumeWidth, canvas.height / priceLevels);
        }
        
        // Draw POC (Point of Control) - highest volume level
        const pocIndex = volumeByPrice.indexOf(maxVolume);
        if (pocIndex >= 0) {
            const pocY = canvas.height - (pocIndex / priceLevels) * canvas.height;
            ctx.strokeStyle = 'rgba(255, 255, 0, 1)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, pocY);
            ctx.lineTo(canvas.width, pocY);
            ctx.stroke();
        }
    }
    
    drawOrderFlow() {
        const canvas = document.getElementById('order-flow-canvas');
        if (!canvas || !this.app.aggTrades || this.app.aggTrades.length < 10) return;
        
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        // Resize canvas to match its display size
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Get recent trades
        const trades = this.app.aggTrades.slice(-50);
        if (trades.length === 0) return;
        
        // Draw trade flow
        let x = 50;
        const spacing = (canvas.width - 100) / trades.length;
        
        for (let i = 0; i < trades.length - 1; i++) {
            const trade = trades[i];
            const nextTrade = trades[i + 1];
            
            // Calculate y position based on price (normalized to canvas height)
            const minPrice = Math.min(...trades.map(t => t.price));
            const maxPrice = Math.max(...trades.map(t => t.price));
            const priceRange = maxPrice - minPrice;
            
            if (priceRange === 0) continue;
            
            const y1 = canvas.height - ((trade.price - minPrice) / priceRange) * (canvas.height - 40);
            const y2 = canvas.height - ((nextTrade.price - minPrice) / priceRange) * (canvas.height - 40);
            
            // Draw line connecting trades
            ctx.beginPath();
            ctx.moveTo(x, y1);
            ctx.lineTo(x + spacing, y2);
            
            // Color based on whether it's a buy or sell
            if (trade.isBuyerMaker) {
                ctx.strokeStyle = 'rgba(220, 53, 69, 0.7)'; // Red for sells
            } else {
                ctx.strokeStyle = 'rgba(40, 167, 69, 0.7)'; // Green for buys
            }
            
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw circle for trade point with size based on quantity
            const radius = Math.min(10, Math.max(3, Math.sqrt(trade.quantity) * 0.5));
            ctx.beginPath();
            ctx.arc(x, y1, radius, 0, Math.PI * 2);
            
            if (trade.isBuyerMaker) {
                ctx.fillStyle = 'rgba(220, 53, 69, 0.7)'; // Red for sells
            } else {
                ctx.fillStyle = 'rgba(40, 167, 69, 0.7)'; // Green for buys
            }
            
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            x += spacing;
        }
    }
    
    analyzeMarketStructure() {
        if (!this.app.candles || this.app.candles.length < 50) return;
        
        const candles = this.app.candles;
        
        // Find swing highs and lows
        const swingHighs = [];
        const swingLows = [];
        
        const lookback = 3; // Number of candles to look back and forward
        
        for (let i = lookback; i < candles.length - lookback; i++) {
            // Check for swing high
            let isSwingHigh = true;
            for (let j = i - lookback; j <= i + lookback; j++) {
                if (j === i) continue;
                if (candles[j].high >= candles[i].high) {
                    isSwingHigh = false;
                    break;
                }
            }
            
            if (isSwingHigh) {
                swingHighs.push({ time: candles[i].time, price: candles[i].high });
            }
            
            // Check for swing low
            let isSwingLow = true;
            for (let j = i - lookback; j <= i + lookback; j++) {
                if (j === i) continue;
                if (candles[j].low <= candles[i].low) {
                    isSwingLow = false;
                    break;
                }
            }
            
            if (isSwingLow) {
                swingLows.push({ time: candles[i].time, price: candles[i].low });
            }
        }
        
        // Draw swing points on chart
        if (this.app.chartManager && this.app.chartManager.series && this.app.chartManager.series.candles) {
            const markers = [];
            
            swingHighs.forEach(high => {
                markers.push({
                    time: high.time / 1000,
                    position: 'aboveBar',
                    color: 'rgba(220, 53, 69, 0.7)',
                    shape: 'arrowDown',
                    text: 'H'
                });
            });
            
            swingLows.forEach(low => {
                markers.push({
                    time: low.time / 1000,
                    position: 'belowBar',
                    color: 'rgba(40, 167, 69, 0.7)',
                    shape: 'arrowUp',
                    text: 'L'
                });
            });
            
            this.app.chartManager.series.candles.setMarkers([...this.app.chartManager.signalMarkers, ...markers]); // Combine with existing signal markers
        }
    }
    
    analyzeLiquidity() {
        if (!this.app.orderBook || !this.app.orderBook.bids || !this.app.orderBook.asks) return;
        
        const { bids, asks } = this.app.orderBook;
        
        // Find liquidity clusters
        const bidClusters = this.findLiquidityClusters(bids);
        const askClusters = this.findLiquidityClusters(asks);
        
        // Add horizontal lines at major liquidity levels
        if (this.app.chartManager && this.app.chartManager.chart) {
            // Implementation depends on your charting library
            console.log('Liquidity clusters identified:', { bidClusters, askClusters });
        }
    }
    
    findLiquidityClusters(levels) {
        if (!levels || levels.length === 0) return [];
        
        // Sort levels by price
        const sortedLevels = [...levels].sort((a, b) => a[0] - b[0]);
        
        // Group nearby levels
        const clusters = [];
        let currentCluster = { price: sortedLevels[0][0], volume: sortedLevels[0][1] };
        
        for (let i = 1; i < sortedLevels.length; i++) {
            const [price, volume] = sortedLevels[i];
            const prevPrice = sortedLevels[i-1][0];
            
            // If close to previous level, add to cluster
            if (Math.abs(price - prevPrice) / prevPrice < 0.001) { // 0.1% threshold
                currentCluster.price = (currentCluster.price * currentCluster.volume + price * volume) / 
                                      (currentCluster.volume + volume); // Volume-weighted average price
                currentCluster.volume += volume;
            } else {
                // Start new cluster
                clusters.push(currentCluster);
                currentCluster = { price, volume };
            }
        }
        
        clusters.push(currentCluster);
        
        // Sort by volume and take top clusters
        return clusters.sort((a, b) => b.volume - a.volume).slice(0, 5);
    }
    
    fetchOptionsData() {
        // Simulate options data fetch
        setTimeout(() => {
            this.app.showNotification('Options data fetched successfully', 'success');
            // Process options data
            this.processOptionsData({
                callsOpenInterest: [/* mock data */],
                putsOpenInterest: [/* mock data */],
                maxPain: 45000,
                putCallRatio: 0.85
            });
        }, 1000);
    }
    
    processOptionsData(optionsData) {
        // Add options-related indicators to chart
        console.log('Processing options data:', optionsData);
        
        // Show max pain line on chart
        if (this.app.chartManager && this.app.chartManager.chart && optionsData.maxPain) {
            // Implementation depends on your charting library
            this.app.showNotification(`Max pain level: ${optionsData.maxPain}`, 'info');
        }
    }
}

/* =================================================================
   RITUAL SYSTEM
   ================================================================= */
class RitualManager {
    constructor(app) {
        this.app = app;
        this.rituals = [
            {
                id: 'marketHarmony',
                name: 'Piyasa Uyumu',
                description: 'Piyasa akışı ile uyumlanma ritüeli. Trend yönünü daha net gösterir ve geçişleri erken yakalar.',
                effect: 'Trend analiz doğruluğu +25%, trend geçiş tespiti +30%',
                duration: 15 * 60 * 1000, // 15 dakika
                preparationTime: 60 * 1000, // 1 dakika
                energyCost: 15,
                type: 'trend',
                active: false,
                prepared: false,
                prepProgress: 0,
                remainingTime: 0,
                activatedAt: null
            },
            {
                id: 'confluenceRitual',
                name: 'Uyum Noktası Ritüeli',
                description: 'Çoklu zaman dilimlerindeki fiyat uyumlarını görme yeteneğini artırır.',
                effect: 'Uyum skorları +35%, çoklu zaman dilimi doğruluğu +25%',
                duration: 20 * 60 * 1000, // 20 dakika
                preparationTime: 90 * 1000, // 1.5 dakika
                energyCost: 20,
                type: 'confluence',
                active: false,
                prepared: false,
                prepProgress: 0,
                remainingTime: 0,
                activatedAt: null
            },
            {
                id: 'liquidityVision',
                name: 'Likidite Görüşü',
                description: 'Piyasadaki büyük likidite havuzlarını ve emir duvarlarını daha net görmenizi sağlar.',
                effect: 'Likidite tespiti +40%, büyük emirlerin tespiti +30%',
                duration: 10 * 60 * 1000, // 10 dakika
                preparationTime: 45 * 1000, // 45 saniye
                energyCost: 12,
                type: 'liquidity',
                active: false,
                prepared: false,
                prepProgress: 0,
                remainingTime: 0,
                activatedAt: null
            },
            {
                id: 'orderFlowInsight',
                name: 'Emir Akışı İçgörüsü',
                description: 'Piyasa katılımcılarının davranışlarını daha iyi anlama ve emir akışını derinlemesine görme yeteneği.',
                effect: 'Emir akışı analizi +30%, piyasa katılımcı analizi +25%',
                duration: 12 * 60 * 1000, // 12 dakika
                preparationTime: 75 * 1000, // 1.25 dakika
                energyCost: 18,
                type: 'orderflow',
                active: false,
                prepared: false,
                prepProgress: 0,
                remainingTime: 0,
                activatedAt: null
            },
            {
                id: 'divineProtection',
                name: 'İlahi Koruma',
                description: 'Piyasa manipülasyonlarına karşı koruma sağlar ve ani fiyat hareketlerinden sizi korur.',
                effect: 'Manipülasyon tespiti +40%, ani hareket koruması +35%',
                duration: 30 * 60 * 1000, // 30 dakika
                preparationTime: 120 * 1000, // 2 dakika
                energyCost: 25,
                type: 'protection',
                active: false,
                prepared: false,
                prepProgress: 0,
                remainingTime: 0,
                activatedAt: null
            }
        ];
        
        this.selectedRitualId = null;
        this.isContainerVisible = false;
        this.prepInterval = null;
        this.ritualIntervals = {};
        
        // UI elemanları
        this.container = document.getElementById('ritual-container');
        this.ritualList = document.getElementById('ritual-list');
        this.ritualStatus = document.getElementById('ritual-status');
        
        // Görünürlük durumunu yükle
        this.loadVisibilityState();
        
        // Ritüelleri listele
        this.renderRituals();
        
        // Aktif ritüelleri kontrol et
        this.checkActiveRituals();
        
        // Event listeners
        window.addEventListener('beforeunload', () => {
            this.saveRitualStates();
        });
    }
    
    loadVisibilityState() {
        const visible = localStorage.getItem('utc_ritual_visible');
        if (visible === 'true') {
            this.toggleRitualContainer(true);
        }
        
        // Kayıtlı ritüel durumlarını yükle
        const savedRituals = localStorage.getItem('utc_ritual_states');
        if (savedRituals) {
            try {
                const ritualStates = JSON.parse(savedRituals);
                ritualStates.forEach(state => {
                    const ritual = this.rituals.find(r => r.id === state.id);
                    if (ritual) {
                        ritual.active = state.active;
                        ritual.prepared = state.prepared;
                        ritual.prepProgress = state.prepProgress;
                        ritual.activatedAt = state.activatedAt ? new Date(state.activatedAt) : null;
                        
                        if (ritual.active && ritual.activatedAt) {
                            // Kalan süreyi hesapla
                            const elapsedTime = Date.now() - ritual.activatedAt;
                            ritual.remainingTime = Math.max(0, ritual.duration - elapsedTime);
                            
                            // Eğer süre dolmadıysa, ritüeli aktifleştir
                            if (ritual.remainingTime > 0) {
                                this.applyRitualEffects(ritual);
                                this.startRitualTimer(ritual);
                            } else {
                                ritual.active = false;
                                ritual.activatedAt = null;
                            }
                        }
                    }
                });
            } catch (e) {
                console.error('Ritüel durumları yüklenirken hata:', e);
            }
        }
    }
    
    saveRitualStates() {
        // Sadece ID, active, prepared, prepProgress ve activatedAt verilerini kaydet
        const ritualStates = this.rituals.map(ritual => ({
            id: ritual.id,
            active: ritual.active,
            prepared: ritual.prepared,
            prepProgress: ritual.prepProgress,
            activatedAt: ritual.activatedAt
        }));
        
        localStorage.setItem('utc_ritual_states', JSON.stringify(ritualStates));
    }
    
    toggleRitualContainer(show) {
        if (show === undefined) {
            this.isContainerVisible = !this.isContainerVisible;
        } else {
            this.isContainerVisible = show;
        }
        
        if (this.container) {
            this.container.classList.toggle('active', this.isContainerVisible);
            this.container.style.transform = this.isContainerVisible ? 'translateX(0)' : 'translateX(-100%)';
        }
        
        // Görünürlük durumunu kaydet
        localStorage.setItem('utc_ritual_visible', this.isContainerVisible);
    }
    
    renderRituals() {
        if (!this.ritualList) return;
        
        this.ritualList.innerHTML = '';
        
        this.rituals.forEach(ritual => {
            const ritualElement = document.createElement('div');
            ritualElement.className = `ritual-item ${ritual.active ? 'active' : ''} ${ritual.prepared ? 'prepared' : ''}`;
            ritualElement.dataset.ritualId = ritual.id;
            
            // Aktif etiketini ekle
            if (ritual.active) {
                const activeLabel = document.createElement('span');
                activeLabel.className = 'ritual-active-label';
                activeLabel.textContent = 'AKTİF';
                ritualElement.appendChild(activeLabel);
                ritualElement.classList.add('ritual-active');
            }
            
            let durationText = this.formatTime(ritual.duration);
            if (ritual.active && ritual.remainingTime) {
                durationText = this.formatTime(ritual.remainingTime);
            }
            
            ritualElement.innerHTML += `
                <div class="ritual-item-header">
                    <div class="ritual-item-title">${ritual.name}</div>
                    <div class="ritual-item-duration">⏱️ ${durationText}</div>
                </div>
                <div class="ritual-item-description">${ritual.description}</div>
                <div class="ritual-item-effect">${ritual.effect}</div>
                <div class="ritual-item-cost">Enerji: ${ritual.energyCost}%</div>
                <div class="ritual-item-progress">
                    <div class="ritual-item-progress-bar" style="width: ${ritual.prepProgress}%"></div>
                </div>
            `;
            
            // Tıklama olayı ekle
            ritualElement.addEventListener('click', () => {
                this.selectRitual(ritual.id);
            });
            
            this.ritualList.appendChild(ritualElement);
        });
        
        // Status metnini güncelle
        this.updateStatusText();
    }
    
    selectRitual(ritualId) {
        this.selectedRitualId = ritualId;
        
        // Seçili ritüeli vurgula
        const ritualItems = this.ritualList.querySelectorAll('.ritual-item');
        ritualItems.forEach(item => {
            if (item.dataset.ritualId === ritualId) {
                item.classList.add('selected');
            } else {
                item.classList.remove('selected');
            }
        });
        
        // Status metnini güncelle
        this.updateStatusText();
    }
    
    updateStatusText() {
        if (!this.ritualStatus) return;
        
        const selectedRitual = this.rituals.find(r => r.id === this.selectedRitualId);
        
        if (!selectedRitual) {
            this.ritualStatus.textContent = 'Aktif ritüel yok. Bir ritüel seçip hazırlayın.';
            return;
        }
        
        if (selectedRitual.active) {
            const remainingText = this.formatTime(selectedRitual.remainingTime);
            this.ritualStatus.textContent = `${selectedRitual.name} aktif. Kalan süre: ${remainingText}`;
        } else if (selectedRitual.prepared) {
            this.ritualStatus.textContent = `${selectedRitual.name} hazır. Aktifleştirmek için tıklayın.`;
        } else if (this.prepInterval && selectedRitual.prepProgress > 0) {
            this.ritualStatus.textContent = `${selectedRitual.name} hazırlanıyor... (${Math.round(selectedRitual.prepProgress)}%)`;
        } else {
            this.ritualStatus.textContent = `${selectedRitual.name} seçildi. Hazırlamak için tıklayın.`;
        }
    }
    
    prepareSelectedRitual() {
        if (!this.selectedRitualId) {
            this.app.showNotification('Lütfen önce bir ritüel seçin!', 'warning');
            return;
        }
        
        const ritual = this.rituals.find(r => r.id === this.selectedRitualId);
        
        if (!ritual) return;
        
        // Zaten hazırlanmışsa veya aktifse
        if (ritual.prepared) {
            this.app.showNotification(`${ritual.name} zaten hazır!`, 'info');
            return;
        }
        
        if (ritual.active) {
            this.app.showNotification(`${ritual.name} zaten aktif!`, 'info');
            return;
        }
        
        // Enerji kontrolü
        if (!this.app.energyManager || this.app.energyManager.currentEnergy < ritual.energyCost) {
            this.app.showNotification(`Yeterli enerji yok! ${ritual.energyCost}% enerji gerekiyor.`, 'danger');
            if (this.app.speak) {
                this.app.speak(`Ritüeli hazırlamak için yeterli enerji yok. ${ritual.energyCost} birim enerji gerekiyor.`);
            }
            return;
        }
        
        // Hazırlanmaya başla
        ritual.prepProgress = 0;
        
        // Sesli bildirim
        if (this.app.speak) {
            this.app.speak(`${ritual.name} ritüeli hazırlanıyor. Lütfen bekleyin.`);
        }
        
        this.app.showNotification(`${ritual.name} ritüeli hazırlanmaya başladı...`, 'info');
        
        // Enerji tüketimi
        this.app.energyManager.useEnergy(ritual.energyCost / 2); // Yarısını şimdi kullan
        
        // Hazırlanma zamanlayıcısı
        if (this.prepInterval) {
            clearInterval(this.prepInterval);
        }
        
        const updateInterval = 100; // 100ms'de bir güncelle
        const progressStep = (updateInterval / ritual.preparationTime) * 100;
        
        this.prepInterval = setInterval(() => {
            ritual.prepProgress += progressStep;
            
            // İlerlemeyi UI'da güncelle
            const progressBar = this.ritualList.querySelector(`[data-ritual-id="${ritual.id}"] .ritual-item-progress-bar`);
            if (progressBar) {
                progressBar.style.width = `${ritual.prepProgress}%`;
            }
            
            this.updateStatusText();
            
            // Hazırlık tamamlandı mı?
            if (ritual.prepProgress >= 100) {
                ritual.prepProgress = 100;
                ritual.prepared = true;
                clearInterval(this.prepInterval);
                this.prepInterval = null;
                
                // Diğer yarı enerjiyi kullan
                this.app.energyManager.useEnergy(ritual.energyCost / 2);
                
                this.app.showNotification(`${ritual.name} ritüeli hazırlandı! Aktifleştirmek için tıklayın.`, 'success');
                
                if (this.app.speak) {
                    this.app.speak(`${ritual.name} ritüeli hazır. Aktifleştir butonuna tıklayın.`);
                }
                
                // Ritüel listesini yenile
                this.renderRituals();
            }
        }, updateInterval);
    }
    
    activateSelectedRitual() {
        if (!this.selectedRitualId) {
            this.app.showNotification('Lütfen önce bir ritüel seçin!', 'warning');
            return;
        }
        
        const ritual = this.rituals.find(r => r.id === this.selectedRitualId);
        
        if (!ritual) return;
        
        // Aktifse zaten
        if (ritual.active) {
            this.app.showNotification(`${ritual.name} zaten aktif!`, 'info');
            return;
        }
        
        // Hazır değilse
        if (!ritual.prepared) {
            this.app.showNotification(`${ritual.name} henüz hazır değil! Önce hazırlayın.`, 'warning');
            return;
        }
        
        // Ritüeli aktifleştir
        ritual.active = true;
        ritual.prepared = false; // Hazırlık durumunu sıfırla
        ritual.activatedAt = new Date();
        ritual.remainingTime = ritual.duration;
        
        // Ritüel efektlerini uygula
        this.applyRitualEffects(ritual);
        
        // Zamanlayıcıyı başlat
        this.startRitualTimer(ritual);
        
        // Sesli bildirim
        if (this.app.speak) {
            this.app.speak(`${ritual.name} ritüeli aktifleştirildi. Tüm gizli güçler artık emrinde. Süre: ${this.formatTime(ritual.duration)}.`);
        }
        
        // Bildirim
        this.app.showNotification(`${ritual.name} ritüeli aktifleştirildi! Süre: ${this.formatTime(ritual.duration)}.`, 'success');
        
        // Görsel efekt
        const ritualElement = this.ritualList.querySelector(`[data-ritual-id="${ritual.id}"]`);
        if (ritualElement) {
            ritualElement.classList.add('ritual-activate-effect');
            setTimeout(() => {
                ritualElement.classList.remove('ritual-activate-effect');
            }, 500);
        }
        
        // Ritüel listesini yenile
        this.renderRituals();
        
        // Ritüel durumlarını kaydet
        this.saveRitualStates();
    }
    
    startRitualTimer(ritual) {
        // Önceki zamanlayıcıyı temizle
        if (this.ritualIntervals[ritual.id]) {
            clearInterval(this.ritualIntervals[ritual.id]);
        }
        
        const updateInterval = 1000; // 1 saniyede bir güncelle
        
        this.ritualIntervals[ritual.id] = setInterval(() => {
            ritual.remainingTime -= updateInterval;
            
            // İlerlemeyi UI'da güncelle
            this.updateStatusText();
            
            // Süre doldu mu?
            if (ritual.remainingTime <= 0) {
                ritual.active = false;
                ritual.activatedAt = null;
                clearInterval(this.ritualIntervals[ritual.id]);
                delete this.ritualIntervals[ritual.id];
                
                // Efektleri kaldır
                this.removeRitualEffects(ritual);
                
                this.app.showNotification(`${ritual.name} ritüeli sona erdi.`, 'info');
                
                if (this.app.speak) {
                    this.app.speak(`${ritual.name} ritüeli sona erdi. Gizli güçler artık erişilebilir değil.`);
                }
                
                // Ritüel listesini yenile
                this.renderRituals();
                
                // Ritüel durumlarını kaydet
                this.saveRitualStates();
            }
            
            // Her 10 saniyede bir ritüel durumlarını kaydet
            if (ritual.remainingTime % 10000 === 0) {
                this.saveRitualStates();
            }
        }, updateInterval);
    }
    
    applyRitualEffects(ritual) {
        if (!this.app) return;
        
        switch (ritual.type) {
            case 'trend':
                // Trend analiz hassasiyetini artır
                if (this.app.marketStructureAnalyzer) {
                    this.app._originalMarketStructureThreshold = this.app.marketStructureAnalyzer.trendThreshold || 0.5;
                    this.app.marketStructureAnalyzer.trendThreshold = this.app._originalMarketStructureThreshold * 0.75;
                }
                // Trend görselleştirmesini geliştir
                if (this.app.chartManager) {
                    this.app.chartManager.trendVisualizationEnhanced = true;
                }
                break;
            
            case 'confluence':
                // Uyum skorlarını artır
                if (this.app.confluenceEngine) {
                    this.app._originalConfluenceMultiplier = this.app.confluenceEngine.confluenceMultiplier || 1.0;
                    this.app.confluenceEngine.confluenceMultiplier = this.app._originalConfluenceMultiplier * 1.35;
                }
                // Çoklu zaman dilimi doğruluğunu artır
                if (this.app.multiTimeframeManager) {
                    this.app._originalMtfAccuracyFactor = this.app.multiTimeframeManager.accuracyFactor || 1.0;
                    this.app.multiTimeframeManager.accuracyFactor = this.app._originalMtfAccuracyFactor * 1.25;
                }
                break;
            
            case 'liquidity':
                // Likidite tespitini geliştir
                if (this.app.heatmapManager) {
                    this.app._originalLiquiditySensitivity = this.app.heatmapManager.liquiditySensitivity || 1.0;
                    this.app.heatmapManager.liquiditySensitivity = this.app._originalLiquiditySensitivity * 1.4;
                }
                // Emir duvarı tespitini geliştir
                if (this.app.spoofDetector) {
                    this.app._originalSpoofThreshold = this.app.spoofDetector.threshold || 20;
                    this.app.spoofDetector.threshold = this.app._originalSpoofThreshold * 0.7;
                }
                break;
            
            case 'orderflow':
                // Emir akışı analizini geliştir
                this.app._originalOrderFlowSensitivity = this.app.settings?.orderFlowSensitivity || 1.0;
                if (this.app.settings) {
                    this.app.settings.orderFlowSensitivity = this.app._originalOrderFlowSensitivity * 1.3;
                }
                // Piyasa katılımcı analizini geliştir
                this.app._originalParticipantDetection = this.app.settings?.participantDetection || 1.0;
                if (this.app.settings) {
                    this.app.settings.participantDetection = this.app._originalParticipantDetection * 1.25;
                }
                break;
            
            case 'protection':
                // Manipülasyon tespitini geliştir
                if (this.app.manipulationDetector) {
                    this.app._originalManipulationThreshold = this.app.manipulationDetector.threshold || 0.5;
                    this.app.manipulationDetector.threshold = this.app._originalManipulationThreshold * 0.6;
                }
                // Risk koruma faktörünü geliştir
                this.app._originalRiskFactor = this.app.settings?.riskFactor || 1.0;
                if (this.app.settings) {
                    this.app.settings.riskFactor = this.app._originalRiskFactor * 1.35;
                }
                break;
        }
        
        // Ritüel aktif edildiğini bildir
        this.app.emit('ritualActivated', {
            ritualId: ritual.id,
            ritualName: ritual.name,
            ritualType: ritual.type,
            duration: ritual.duration
        });
        
        // Aktif görsel efekt
        const chartElement = document.getElementById('live-chart');
        if (chartElement) {
            chartElement.classList.add(`ritual-effect-${ritual.type}`);
        }
    }
    
    removeRitualEffects(ritual) {
        if (!this.app) return;
        
        switch (ritual.type) {
            case 'trend':
                if (this.app.marketStructureAnalyzer && this.app._originalMarketStructureThreshold !== undefined) {
                    this.app.marketStructureAnalyzer.trendThreshold = this.app._originalMarketStructureThreshold;
                }
                if (this.app.chartManager) {
                    this.app.chartManager.trendVisualizationEnhanced = false;
                }
                break;
            
            case 'confluence':
                if (this.app.confluenceEngine && this.app._originalConfluenceMultiplier !== undefined) {
                    this.app.confluenceEngine.confluenceMultiplier = this.app._originalConfluenceMultiplier;
                }
                if (this.app.multiTimeframeManager && this.app._originalMtfAccuracyFactor !== undefined) {
                    this.app.multiTimeframeManager.accuracyFactor = this.app._originalMtfAccuracyFactor;
                }
                break;
            
            case 'liquidity':
                if (this.app.heatmapManager && this.app._originalLiquiditySensitivity !== undefined) {
                    this.app.heatmapManager.liquiditySensitivity = this.app._originalLiquiditySensitivity;
                }
                if (this.app.spoofDetector && this.app._originalSpoofThreshold !== undefined) {
                    this.app.spoofDetector.threshold = this.app._originalSpoofThreshold;
                }
                break;
            
            case 'orderflow':
                if (this.app.settings && this.app._originalOrderFlowSensitivity !== undefined) {
                    this.app.settings.orderFlowSensitivity = this.app._originalOrderFlowSensitivity;
                }
                if (this.app.settings && this.app._originalParticipantDetection !== undefined) {
                    this.app.settings.participantDetection = this.app._originalParticipantDetection;
                }
                break;
            
            case 'protection':
                if (this.app.manipulationDetector && this.app._originalManipulationThreshold !== undefined) {
                    this.app.manipulationDetector.threshold = this.app._originalManipulationThreshold;
                }
                if (this.app.settings && this.app._originalRiskFactor !== undefined) {
                    this.app.settings.riskFactor = this.app._originalRiskFactor;
                }
                break;
        }
        
        // Ritüel sonlandığını bildir
        this.app.emit('ritualDeactivated', {
            ritualId: ritual.id,
            ritualName: ritual.name,
            ritualType: ritual.type
        });
        
        // Görsel efekti kaldır
        const chartElement = document.getElementById('live-chart');
        if (chartElement) {
            chartElement.classList.remove(`ritual-effect-${ritual.type}`);
        }
    }
    
    checkActiveRituals() {
        // Aktif ritüelleri kontrol et ve gerekirse zamanlayıcıyı yeniden başlat
        this.rituals.forEach(ritual => {
            if (ritual.active && ritual.activatedAt) {
                const elapsedTime = Date.now() - ritual.activatedAt;
                ritual.remainingTime = Math.max(0, ritual.duration - elapsedTime);
                
                if (ritual.remainingTime > 0) {
                    this.applyRitualEffects(ritual);
                    this.startRitualTimer(ritual);
                } else {
                    ritual.active = false;
                    ritual.activatedAt = null;
                }
            }
        });
    }
    
    formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    getActiveRituals() {
        return this.rituals.filter(r => r.active);
    }
}

/* =================================================================
   ENERGY MANAGEMENT SYSTEM
   ================================================================= */
class EnergyManager {
    constructor(app) {
        this.app = app;
        this.currentEnergy = parseFloat(localStorage.getItem('utc_energy_level')) || 80; // Başlangıç değeri %80
        this.maxEnergy = 100;
        this.minEnergy = 10;
        this.decayRate = 0.05; // Saniyede %0.05 azalma
        this.lastUpdateTime = Date.now();
        this.isVisible = localStorage.getItem('utc_energy_box_visible') === 'true' || false;
        this.criticalThreshold = 20; // %20'nin altı kritik seviye
        this._warnedAboutEnergy = false; // Initialize the warning flag
        
        // Enerji optimizasyonu için sıcaklık değeri
        this.systemHeat = 0; // 0-100 arası
        this.coolingRate = 0.1; // Saniyede %0.1 soğuma
        
        // UI elemanları
        this.energyBox = document.getElementById('energy-box');
        this.energyFill = document.getElementById('energy-fill');
        this.energyLevel = document.getElementById('energy-level');
        this.energyTime = document.getElementById('energy-time');
        this.energyStatus = document.getElementById('energy-status');
        
        // Event'ları bağla
        this.bindEvents();
        
        // Zamanlayıcıyı başlat
        this.startTimer();
        
        // Sayfanın yüklenmesinde görünürlüğü kontrol et
        this.loadVisibilityState();
    }
    
    bindEvents() {
        // Event binding işlemleri
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Sayfa arka planda, enerji tüketimini azalt
                this.decayRate = 0.02;
            } else {
                // Sayfa aktif, enerji tüketimini normale döndür
                this.decayRate = 0.05;
                this.updateUI(); // UI'ı güncelle
            }
        });
        
        // Sistemdeki olayların enerji üzerindeki etkilerini izle
        if (this.app) {
            // Sinyal oluştuğunda
            this.app.on('signal', () => {
                this.useEnergy(5); // Sinyal oluşturma %5 enerji tüketir
            });
            
            // Analiz yapıldığında
            this.app.on('analysis', () => {
                this.useEnergy(2); // Analiz %2 enerji tüketir
            });
            
            // Savaş modu aktifleştiğinde
            this.app.on('combatMode', (isActive) => {
                if (isActive) {
                    this.decayRate = 0.1; // Savaş modunda enerji 2 kat hızlı tükenir
                } else {
                    this.decayRate = 0.05; // Normal moda dönünce eski hızına döner
                }
            });
        }
    }
    
    startTimer() {
        // Her saniye enerjiyi güncelle
        setInterval(() => {
            this.updateEnergy();
        }, 1000);
    }
    
    updateEnergy() {
        const now = Date.now();
        const deltaTime = (now - this.lastUpdateTime) / 1000; // Saniye cinsinden geçen süre
        this.lastUpdateTime = now;
        
        // Enerjiyi azalt
        const decayAmount = this.decayRate * deltaTime;
        this.currentEnergy = Math.max(this.minEnergy, this.currentEnergy - decayAmount);
        
        // Sistem ısısını soğut
        this.systemHeat = Math.max(0, this.systemHeat - this.coolingRate * deltaTime);
        
        // UI'ı güncelle
        this.updateUI();
        
        // Kritik enerji seviyesi kontrolü
        this.checkCriticalEnergy();
        
        // Enerji değerini kaydet
        localStorage.setItem('utc_energy_level', this.currentEnergy);
    }
    
    updateUI() {
        if (!this.energyFill || !this.energyLevel || !this.energyTime || !this.energyStatus) return;
        
        // Enerji çubuğunu güncelle
        this.energyFill.style.width = `${this.currentEnergy}%`;
        this.energyLevel.textContent = `${Math.round(this.currentEnergy)}%`;
        
        // Saat bilgisini güncelle
        const now = new Date();
        this.energyTime.textContent = now.toLocaleTimeString();
        
        // Durum metnini güncelle
        this.updateStatusText();
        
        // Düşük enerji görsel uyarısı
        if (this.currentEnergy < this.criticalThreshold) {
            this.energyBox.classList.add('energy-low');
        } else {
            this.energyBox.classList.remove('energy-low');
        }
    }
    
    updateStatusText() {
        if (!this.energyStatus) return;
        
        if (this.currentEnergy < this.criticalThreshold) {
            this.energyStatus.textContent = 'KRİTİK: Enerji seviyesi düşük!';
        } else if (this.currentEnergy < 50) {
            this.energyStatus.textContent = 'Enerji seviyesi azalıyor';
        } else if (this.systemHeat > 70) {
            this.energyStatus.textContent = 'Sistem sıcaklığı yüksek';
        } else {
            this.energyStatus.textContent = 'Normal işleyiş sürüyor';
        }
    }
    
    checkCriticalEnergy() {
        // Enerji kritik seviyenin altına düştüğünde uyarı ver ve işlemleri optimize et
        if (this.currentEnergy < this.criticalThreshold && !this._warnedAboutEnergy) {
            this._warnedAboutEnergy = true;
            this.app.showNotification('KRİTİK ENERJİ SEVİYESİ! Sistem performansı düşürülüyor.', 'danger');
            
            // TTS ile uyarı
            if (this.app && this.app.speak) {
                this.app.speak('Dikkat! Kritik enerji seviyesi. Sistem performansı düşürülüyor. Lütfen enerji seviyesini optimize edin.');
            }
            
            // Performansı düşür ve enerji tasarruf moduna geç
            if (this.app) {
                // Analiz aralığını uzat
                if (this.app.analysisInterval) {
                    clearInterval(this.app.analysisInterval);
                    this.app.analysisInterval = setInterval(() => this.app.runPeriodicAnalysis(), 10000); // 5s yerine 10s
                }
                
                // Render aralığını uzat
                if (this.app.renderInterval) {
                    clearInterval(this.app.renderInterval);
                    this.app.renderInterval = setInterval(() => this.app.render(), 500); // 250ms yerine 500ms
                }
            }
        } else if (this.currentEnergy >= 30 && this._warnedAboutEnergy) {
            this._warnedAboutEnergy = false;
            
            // Enerji normal seviyeye döndü, performansı normale getir
            if (this.app) {
                // Analiz aralığını normale getir
                if (this.app.analysisInterval) {
                    clearInterval(this.app.analysisInterval);
                    this.app.analysisInterval = setInterval(() => this.app.runPeriodicAnalysis(), 5000);
                }
                
                // Render aralığını normale getir
                if (this.app.renderInterval) {
                    clearInterval(this.app.renderInterval);
                    this.app.renderInterval = setInterval(() => this.app.render(), 250);
                }
            }
        }
    }
    
    useEnergy(amount) {
        this.currentEnergy = Math.max(this.minEnergy, this.currentEnergy - amount);
        this.systemHeat = Math.min(100, this.systemHeat + amount * 1.5);
        this.updateUI();
    }
    
    addEnergy(amount) {
        this.currentEnergy = Math.min(this.maxEnergy, this.currentEnergy + amount);
        this.updateUI();
    }
    
    boostEnergy() {
        // Enerjiyi %15 artır ancak sistem ısısını %10 artır (yan etki)
        this.addEnergy(15);
        this.systemHeat = Math.min(100, this.systemHeat + 10);
        this.updateStatusText();
        
        this.app.showNotification('Sistem enerjisi güçlendirildi! Sistem ısısı arttı.', 'success');
        if (this.app && this.app.speak) {
            this.app.speak('Sistem enerjisi güçlendirildi. Performans artışı sağlandı. Sistem ısısı yükseliyor.');
        }
    }
    
    optimizeEnergy() {
        // Sistem ısısını %20 düşür ve enerji tüketim oranını %20 azalt
        this.systemHeat = Math.max(0, this.systemHeat - 20);
        const originalDecayRate = this.decayRate;
        this.decayRate *= 0.8; // %20 daha az enerji tüketimi
        
        // 30 saniye sonra normal değere dön
        setTimeout(() => {
            this.decayRate = originalDecayRate;
        }, 30000);
        
        this.app.showNotification('Sistem enerjisi optimize edildi. Tüketim 30 saniyeliğine azaltıldı.', 'info');
        if (this.app && this.app.speak) {
            this.app.speak('Enerji optimizasyonu başarılı. Sistem ısısı düşürüldü ve enerji tüketimi geçici olarak azaltıldı.');
        }
    }
    
    recycleEnergy() {
        // Kullanılmayan işlemleri temizle ve o enerjiyi geri kazan
        let recycledAmount = 5;
        
        // Eski sinyalleri temizle
        if (this.app && this.app.signals && this.app.signals.length > 50) {
            // 50'den fazla sinyal varsa, en eski 10 tanesini temizle
            this.app.signals = this.app.signals.slice(-50);
            recycledAmount += 5;
        }
        
        // Kullanılmayan önerileri temizle
        if (this.app && this.app.confluenceEngine && this.app.confluenceEngine.proposals) {
            const oldLength = this.app.confluenceEngine.proposals.length;
            // 5 dakikadan eski önerileri temizle
            const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
            this.app.confluenceEngine.proposals = this.app.confluenceEngine.proposals.filter(p => p.timestamp > fiveMinutesAgo);
            
            const removedCount = oldLength - this.app.confluenceEngine.proposals.length;
            recycledAmount += removedCount;
        }
        
        // Bellekteki büyük verileri temizle (olmayan seriler gibi)
        if (window.gc) { // JavaScript'in garbage collector'ı varsa çağır (çoğu tarayıcıda yok)
            try {
                window.gc();
                recycledAmount += 3;
            } catch (e) {}
        }
        
        this.addEnergy(recycledAmount);
        this.app.showNotification(`Enerji geri dönüşümü tamamlandı. ${recycledAmount}% enerji kazanıldı.`, 'success');
        if (this.app && this.app.speak) {
            this.app.speak(`Enerji geri dönüşümü başarılı. Kullanılmayan kaynaklar temizlendi ve yüzde ${recycledAmount} enerji geri kazanıldı.`);
        }
    }
    
    toggleEnergyBox(show) {
        if (show === undefined) {
            this.isVisible = !this.isVisible;
        } else {
            this.isVisible = show;
        }
        
        if (this.energyBox) {
            this.energyBox.classList.toggle('active', this.isVisible);
            this.energyBox.style.transform = this.isVisible ? 'translateX(0)' : 'translateX(-100%)';
        }
        
        // Görünürlük durumunu kaydet
        localStorage.setItem('utc_energy_box_visible', this.isVisible);
    }
    
    loadVisibilityState() {
        const savedEnergy = parseFloat(localStorage.getItem('utc_energy_level'));
        if (!isNaN(savedEnergy)) {
            this.currentEnergy = savedEnergy;
        }
        
        const visible = localStorage.getItem('utc_energy_box_visible');
        if (visible === 'false') {
            this.toggleEnergyBox(false);
        }
        
        this.updateUI();
    }
}

/* =================================================================
   MARKET MANIPULATION DETECTION
   ================================================================= */
class MarketManipulationDetector {
    constructor(app) {
        this.app = app;
        this.thresholds = {
            volumeSpike: 3.0,   // Normal hacmin 3 katı
            priceJump: 0.025,   // %2.5'luk ani fiyat değişimi
            orderBookImbalance: 0.7  // %70 tek yönde dengesizlik
        };
        this.detectionWindow = 10;  // Son 10 mum
        this.lastAlert = 0;
        this.alertCooldown = 300000;  // 5 dakika
        this.threshold = 0.5; // Ritual effect
    }
    
    // Hacim anomalilerini tespit et
    detectVolumeAnomalies(candles) {
        if (candles.length < 30) return false;
        
        // Son 20 mumu analiz et
        const recentCandles = candles.slice(-30);
        const volumes = recentCandles.map(c => c.volume);
        
        // Ortalama ve standart sapma hesapla (son 30 mumdan)
        const avgVolume = volumes.reduce((sum, vol) => sum + vol, 0) / volumes.length;
        const stdDev = Math.sqrt(volumes.reduce((sum, vol) => sum + Math.pow(vol - avgVolume, 2), 0) / volumes.length);
        
        // Son 3 mum için kontrol et
        const latestVolumes = volumes.slice(-3);
        
        for (const volume of latestVolumes) {
            // Z-skoru hesapla
            const zScore = (volume - avgVolume) / stdDev;
            
            if (zScore > (this.thresholds.volumeSpike * this.threshold)) { // Apply ritual threshold
                return {
                    type: 'volumeSpike',
                    value: volume,
                    avg: avgVolume,
                    zScore: zScore
                };
            }
        }
        
        return false;
    }
    
    // Ani fiyat hareketlerini tespit et
    detectPriceJumps(candles) {
        if (candles.length < 10) return false;
        
        const recentCandles = candles.slice(-10);
        
        for (let i = 1; i < recentCandles.length; i++) {
            const prevClose = recentCandles[i-1].close;
            const currentClose = recentCandles[i].close;
            
            const priceChange = Math.abs((currentClose - prevClose) / prevClose);
            
            if (priceChange > (this.thresholds.priceJump * this.threshold)) { // Apply ritual threshold
                return {
                    type: 'priceJump',
                    from: prevClose,
                    to: currentClose,
                    change: priceChange
                };
            }
        }
        
        return false;
    }
    
    // Emir defteri dengesizliğini tespit et (bakiyelerinizi kullanarak)
    detectOrderBookImbalance() {
        if (!this.app || !this.app.marketData || !this.app.marketData.lastOrderBook) return false; // Use lastOrderBook
        
        const orderBook = this.app.marketData.lastOrderBook;
        
        // Toplam alım ve satım miktarını hesapla
        const totalBids = orderBook.bids.reduce((sum, [price, amount]) => sum + amount, 0);
        const totalAsks = orderBook.asks.reduce((sum, [price, amount]) => sum + amount, 0);
        
        // Oran hesapla
        const totalOrders = totalBids + totalAsks;
        if (totalOrders === 0) return false;
        
        const bidRatio = totalBids / totalOrders;
        const askRatio = totalAsks / totalOrders;
        
        // Dengesizliği kontrol et
        if (bidRatio > (this.thresholds.orderBookImbalance * this.threshold)) { // Apply ritual threshold
            return {
                type: 'buyImbalance',
                ratio: bidRatio
            };
        } else if (askRatio > (this.thresholds.orderBookImbalance * this.threshold)) { // Apply ritual threshold
            return {
                type: 'sellImbalance',
                ratio: askRatio
            };
        }
        
        return false;
    }
    
    // Ana algılama metodu
    detect() {
        if (!this.app || !this.app.candles) return false;
        
        const now = Date.now();
        if (now - this.lastAlert < this.alertCooldown) return false;  // Çok sık uyarı verme
        
        // Hacim anomalilerini kontrol et
        const volumeAnomaly = this.detectVolumeAnomalies(this.app.candles);
        
        // Ani fiyat hareketlerini kontrol et
        const priceJump = this.detectPriceJumps(this.app.candles);
        
        // Emir defteri dengesizliğini kontrol et
        const orderBookImbalance = this.detectOrderBookImbalance();
        
        // Herhangi bir manipülasyon tespit edildi mi?
        if (volumeAnomaly || priceJump || orderBookImbalance) {
            this.lastAlert = now;
            
            let alertType = '';
            let alertMessage = '';
            
            if (volumeAnomaly) {
                alertType = 'volumeSpike';
                alertMessage = `Anormal işlem hacmi tespit edildi! Normal hacmin ${volumeAnomaly.zScore.toFixed(1)} katı.`;
            } else if (priceJump) {
                alertType = 'priceJump';
                alertMessage = `Ani fiyat hareketi tespit edildi! ${(priceJump.change * 100).toFixed(2)}% değişim.`;
            } else if (orderBookImbalance) {
                alertType = orderBookImbalance.type;
                alertMessage = `Emir defteri dengesizliği tespit edildi! ${(orderBookImbalance.ratio * 100).toFixed(0)}% ${orderBookImbalance.type === 'buyImbalance' ? 'alım' : 'satım'} hakimiyeti.`;
            }
            
            return {
                type: alertType,
                message: alertMessage,
                timestamp: now
            };
        }
        
        return false;
    }
}

/* =================================================================
   ENHANCED RISK MANAGEMENT SYSTEM
   ================================================================= */
class EnhancedRiskManagement {
    constructor(app) {
        this.app = app;
        this.maxDrawdown = 0;
        this.historicalVolatility = 0;
        this.valueAtRisk = 0;
        this.riskAnalysisEnabled = false;
        this.dynamicPositionSizing = true;
        this.correlationMatrix = {};
        this.optimalLeverage = 1.0;
        this.volatilityThresholds = {
            low: 0.5,
            medium: 1.0,
            high: 2.0,
            extreme: 3.0
        };
        this.riskMetrics = {
            sharpeRatio: 0,
            sortinoRatio: 0,
            calmarRatio: 0,
            maxDrawdown: 0,
            winRate: 0,
            profitFactor: 0
        };
        this.riskFactor = 1.0; // Ritual effect
        
        this.init();
    }
    
    init() {
        this.calculateHistoricalMetrics();
        this.scheduleRiskUpdates();
        this.bindControls();
        
        console.log('Enhanced Risk Management System initialized');
    }
    
    bindControls() {
        // Add risk controls to settings panel
        const settingsContainer = document.getElementById('modal-features');
        
        if (settingsContainer) {
            const riskControlsHTML = `
                <div class="settings-item">
                    <label for="dynamic-position-sizing">Dynamic Position Sizing</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="dynamic-position-sizing" ${this.dynamicPositionSizing ? 'checked' : ''}>
                        <span class="toggle-slider"></span>
                    </div>
                </div>
                <div class="settings-item">
                    <label for="risk-analysis">Advanced Risk Analysis</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="risk-analysis" ${this.riskAnalysisEnabled ? 'checked' : ''}>
                        <span class="toggle-slider"></span>
                    </div>
                </div>
            `;
            
            const riskDiv = document.createElement('div');
            riskDiv.className = 'settings-group';
            riskDiv.innerHTML = `<div class="panel-title">Risk Management</div>${riskControlsHTML}`;
            
            settingsContainer.appendChild(riskDiv);
            
            // Add event listeners
            document.getElementById('dynamic-position-sizing')?.addEventListener('change', (e) => {
                this.dynamicPositionSizing = e.target.checked;
                this.app.showNotification(`Dynamic position sizing ${e.target.checked ? 'enabled' : 'disabled'}`, 'info');
            });
            
            document.getElementById('risk-analysis')?.addEventListener('change', (e) => {
                this.riskAnalysisEnabled = e.target.checked;
                if (e.target.checked) {
                    this.calculateRiskMetrics();
                    this.app.showNotification('Advanced risk analysis enabled', 'info');
                } else {
                    this.app.showNotification('Advanced risk analysis disabled', 'info');
                }
            });
        }
    }
    
    calculateHistoricalMetrics() {
        if (!this.app.candles || this.app.candles.length < 30) return;
        
        const candles = this.app.candles;
        const returns = [];
        
        // Calculate daily returns
        for (let i = 1; i < candles.length; i++) {
            const prevClose = candles[i-1].close;
            const currentClose = candles[i].close;
            returns.push((currentClose - prevClose) / prevClose);
        }
        
        // Calculate historical volatility
        this.historicalVolatility = this.calculateStandardDeviation(returns) * Math.sqrt(365); // Annualized
        
        // Calculate maximum drawdown
        let peak = -Infinity;
        let maxDrawdown = 0;
        
        for (let i = 0; i < candles.length; i++) {
            if (candles[i].close > peak) {
                peak = candles[i].close;
            } else {
                const drawdown = (peak - candles[i].close) / peak;
                maxDrawdown = Math.max(maxDrawdown, drawdown);
            }
        }
        
        this.maxDrawdown = maxDrawdown;
        
        // Calculate VaR (Value at Risk)
        returns.sort((a, b) => a - b);
        const varIndex = Math.floor(returns.length * 0.05);
        this.valueAtRisk = Math.abs(returns[varIndex]);
        
        // Calculate optimal leverage based on volatility
        this.optimalLeverage = this.calculateOptimalLeverage();
    }
    
    calculateRiskMetrics() {
        if (!this.app.signals || this.app.signals.length < 5) return;
        
        const signals = this.app.signals;
        const returns = [];
        let wins = 0;
        let grossProfit = 0;
        let grossLoss = 0;
        
        // Process completed signals
        signals.filter(s => s.status === 'tp' || s.status === 'sl').forEach(signal => {
            const entryPrice = signal.price;
            const exitPrice = signal.exitPrice || entryPrice;
            const direction = signal.type === 'buy' ? 1 : -1;
            const returnPct = direction * (exitPrice - entryPrice) / entryPrice;
            
            returns.push(returnPct);
            
            if (returnPct > 0) {
                wins++;
                grossProfit += returnPct;
            } else {
                grossLoss += Math.abs(returnPct);
            }
        });
        
        // Calculate metrics
        this.riskMetrics.winRate = signals.length > 0 ? wins / signals.length : 0;
        this.riskMetrics.profitFactor = grossLoss > 0 ? grossProfit / grossLoss : 0;
        
        // Calculate Sharpe Ratio
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const stdDev = this.calculateStandardDeviation(returns);
        this.riskMetrics.sharpeRatio = stdDev > 0 ? avgReturn / stdDev : 0;
        
        // Calculate Sortino Ratio (only negative returns for denominator)
        const negativeReturns = returns.filter(r => r < 0);
        const downside = this.calculateStandardDeviation(negativeReturns);
        this.riskMetrics.sortinoRatio = downside > 0 ? avgReturn / downside : 0;
        
        // Calculate Calmar Ratio
        this.riskMetrics.calmarRatio = this.maxDrawdown > 0 ? avgReturn / this.maxDrawdown : 0;
        
        console.log('Risk metrics calculated:', this.riskMetrics);
    }
    
    calculateStandardDeviation(array) {
        const n = array.length;
        if (n === 0) return 0;
        
        const mean = array.reduce((sum, val) => sum + val, 0) / n;
        const variance = array.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
        
        return Math.sqrt(variance);
    }
    
    calculateOptimalLeverage() {
        // Using Kelly Criterion for optimal leverage
        if (this.riskMetrics.winRate === 0) return 1.0;
        
        const winRate = this.riskMetrics.winRate;
        const avgWin = this.riskMetrics.profitFactor * (1 - winRate) / winRate;
        const avgLoss = 1;
        
        const kellyFraction = (winRate / avgLoss) - ((1 - winRate) / avgWin);
        return Math.max(0.5, Math.min(2.0, kellyFraction)); // Limit between 0.5x and 2x
    }
    
    getPositionSizing(baseSize) {
        if (!this.dynamicPositionSizing) return baseSize;
        
        // Adjust position size based on volatility and risk metrics
        let volatilityFactor = 1.0;
        
        if (this.historicalVolatility < this.volatilityThresholds.low) {
            volatilityFactor = 1.2; // Increase position size in low volatility
        } else if (this.historicalVolatility > this.volatilityThresholds.high) {
            volatilityFactor = 0.8; // Decrease position size in high volatility
        } else if (this.historicalVolatility > this.volatilityThresholds.extreme) {
            volatilityFactor = 0.5; // Significantly reduce position size in extreme volatility
        }
        
        // Adjust by win rate and profit factor
        let performanceFactor = 1.0;
        if (this.riskMetrics.winRate > 0.6 && this.riskMetrics.profitFactor > 1.5) {
            performanceFactor = 1.1; // Increase size when performing well
        } else if (this.riskMetrics.winRate < 0.4 || this.riskMetrics.profitFactor < 1.0) {
            performanceFactor = 0.9; // Decrease size when performing poorly
        }
        
        // Apply Kelly-based optimal leverage
        const leverageFactor = this.optimalLeverage;
        
        // Calculate final position size
        const adjustedSize = baseSize * volatilityFactor * performanceFactor * leverageFactor * this.riskFactor; // Apply ritual risk factor
        
        return Math.max(baseSize * 0.5, Math.min(baseSize * 2.0, adjustedSize)); // Limit between 50%-200% of base size
    }
    
    scheduleRiskUpdates() {
        // Update risk metrics every 15 minutes
        setInterval(() => {
            if (this.riskAnalysisEnabled) {
                this.calculateHistoricalMetrics();
                this.calculateRiskMetrics();
            }
        }, 15 * 60 * 1000);
    }
    
    getCurrentRiskLevel() {
        // Determine current risk level based on volatility and metrics
        if (this.historicalVolatility > this.volatilityThresholds.extreme) {
            return 'extreme';
        } else if (this.historicalVolatility > this.volatilityThresholds.high) {
            return 'high';
        } else if (this.historicalVolatility > this.volatilityThresholds.medium) {
            return 'medium';
        } else {
            return 'low';
        }
    }
    
    getRiskReport() {
        return {
            riskLevel: this.getCurrentRiskLevel(),
            historicalVolatility: this.historicalVolatility,
            valueAtRisk: this.valueAtRisk,
            maxDrawdown: this.maxDrawdown,
            sharpeRatio: this.riskMetrics.sharpeRatio,
            sortinoRatio: this.riskMetrics.sortinoRatio,
            winRate: this.riskMetrics.winRate,
            profitFactor: this.riskMetrics.profitFactor,
            optimalLeverage: this.optimalLeverage
        };
    }
}

</script>
<!-- === AI/ML Prediction Engine === -->
<script>
// --- LSTM Price Prediction (TensorFlow.js) ---
class LSTMPricePredictor {
    constructor() {
        this.model = null;
    }
    async buildModel(inputShape) {
        this.model = tf.sequential();
        this.model.add(tf.layers.lstm({units: 32, inputShape: inputShape, returnSequences: false}));
        this.model.add(tf.layers.dense({units: 1}));
        this.model.compile({optimizer: 'adam', loss: 'meanSquaredError'});
    }
    async train(prices, epochs=30) {
        // prices: [p1, p2, ...]
        const seqLen = 10;
        const xs = [], ys = [];
        for (let i = 0; i < prices.length - seqLen; i++) {
            xs.push(prices.slice(i, i+seqLen));
            ys.push(prices[i+seqLen]);
        }
        const xsTensor = tf.tensor3d(xs.map(x => x.map(v => [v])), [xs.length, seqLen, 1]);
        const ysTensor = tf.tensor2d(ys, [ys.length, 1]);
        await this.buildModel([seqLen, 1]);
        await this.model.fit(xsTensor, ysTensor, {epochs});
        xsTensor.dispose(); ysTensor.dispose();
    }
    predictNext(prices) {
        // prices: [p1, ..., p10]
        const input = tf.tensor3d([prices.map(v => [v])], [1, prices.length, 1]);
        const pred = this.model.predict(input);
        const val = pred.dataSync()[0];
        input.dispose(); pred.dispose();
        return val;
    }
}

// --- Random Forest Trend Classifier (ml.js) ---
class TrendRandomForest {
    constructor() {
        this.model = null;
    }
    train(features, labels) {
        // features: [[f1, f2, ...], ...], labels: [0,1,...]
        this.model = new ML.RandomForestClassifier({nEstimators: 20});
        this.model.train(features, labels);
    }
    predict(feature) {
        return this.model.predict([feature])[0];
    }
}

// --- SVM Support/Resistance Detector (ml.js) ---
class SupportResistanceSVM {
    constructor() {
        this.model = null;
    }
    train(features, labels) {
        // features: [[price, volume, ...]], labels: [0/1]
        this.model = new ML.SVM({kernel: 'rbf', c: 1.0});
        this.model.train(features, labels);
    }
    predict(feature) {
        return this.model.predict([feature])[0];
    }
}

// --- AI Prediction Engine ---
class AIPredictionEngine {
    constructor(app) {
        this.app = app;
        this.lstm = new LSTMPricePredictor();
        this.rf = new TrendRandomForest();
        this.svm = new SupportResistanceSVM();
        this.isTrained = false;
    }
    async trainAll() {
        // Fiyat verisiyle LSTM eğit
        const candles = this.app.candles || [];
        if (candles.length < 50) return;
        const prices = candles.map(c => c.close);
        await this.lstm.train(prices);
        // Trend için Random Forest eğit
        const features = [], labels = [];
        for (let i = 20; i < candles.length; i++) {
            const window = candles.slice(i-20, i);
            const mean = window.reduce((a,b)=>a+b.close,0)/20;
            const std = Math.sqrt(window.reduce((a,b)=>a+Math.pow(b.close-mean,2),0)/20);
            features.push([mean, std, window[19].volume]);
            labels.push(window[19].close > window[0].close ? 1 : 0); // 1: uptrend, 0: downtrend
        }
        this.rf.train(features, labels);
        // SVM ile destek/direnç eğit
        const srFeatures = [], srLabels = [];
        for (let i = 20; i < candles.length; i++) {
            const window = candles.slice(i-20, i);
            const max = Math.max(...window.map(c=>c.high));
            const min = Math.min(...window.map(c=>c.low));
            srFeatures.push([window[19].close, window[19].volume]);
            srLabels.push(Math.abs(window[19].close-max)<Math.abs(window[19].close-min)?1:0); // 1: resistance, 0: support
        }
        this.svm.train(srFeatures, srLabels);
        this.isTrained = true;
    }
    async predictAll() {
        if (!this.isTrained) return null;
        const candles = this.app.candles;
        if (!candles || candles.length < 30) return null;
        const lastPrices = candles.slice(-10).map(c=>c.close);
        const lstmPred = this.lstm.predictNext(lastPrices);
        const last = candles[candles.length-1];
        const mean = lastPrices.reduce((a,b)=>a+b,0)/lastPrices.length;
        const std = Math.sqrt(lastPrices.reduce((a,b)=>a+Math.pow(b-mean,2),0)/lastPrices.length);
        const rfPred = this.rf.predict([mean, std, last.volume]);
        const svmPred = this.svm.predict([last.close, last.volume]);
        return {
            pricePrediction: lstmPred,
            trend: rfPred ? 'YÜKSELİŞ' : 'DÜŞÜŞ',
            supportOrResistance: svmPred ? 'DİRENÇ' : 'DESTEK',
        };
    }
}

// --- Kehanet Paneli AI Entegrasyonu ---
window.addEventListener('DOMContentLoaded', async ()=>{
    if (!window.app) return;
    window.app.aiPredictionEngine = new AIPredictionEngine(window.app);
    // Initial training on demo data
    if (window.app.candles && window.app.candles.length >= 50) {
        await window.app.aiPredictionEngine.trainAll();
    }
    
    // Kehanet Paneli butonuna tıklandığında AI tahminlerini göster
    const kehanetRefreshBtn = document.getElementById('kp-refresh-btn');
    if (kehanetRefreshBtn) {
        kehanetRefreshBtn.addEventListener('click', async ()=>{
            const ai = window.app.aiPredictionEngine;
            // Retrain if not trained or if significant new data
            if (!ai.isTrained || (window.app.candles && window.app.candles.length > ai.lastTrainCandleCount + 50)) {
                await ai.trainAll();
                ai.lastTrainCandleCount = window.app.candles.length;
            }
            if (!ai.isTrained) {
                console.warn("AI Prediction Engine not trained. Cannot make predictions.");
                return;
            }
            const pred = await ai.predictAll();
            if (!pred) return;
            
            // Update Kehanet Panel UI with AI predictions
            if (window.kehanetPanel) {
                window.kehanetPanel.elements.prediction.textContent = pred.trend;
                window.kehanetPanel.elements.probability.textContent = `${(pred.confidence || 70).toFixed(0)}%`; // Assuming confidence from AI
                // More detailed updates could be implemented here
            }
        });
    }
});
</script>

<!-- DÖRT ATLI (FOUR HORSEMEN) MARKET REGIME SİSTEMİ ve PANTEON ENTEGRASYONU -->
<script>
// Four Horsemen Market Regime Detection System
class FourHorsemenSystem {
    constructor(app) {
        this.app = app;
        this.horsemen = { war: false, famine: false, pestilence: false, death: false };
        this.averageVolume = 0;
        this.averageRange = 0;
        this.trendStrength = 0;
        this.volatilityThreshold = 1.5;
        this.liquidityThreshold = 0.7;
        this.trendThreshold = 2.0;
        this.dropThreshold = -3.0;
        this.updateInterval = 60000;
        this.lastUpdate = 0;
        this.listeners = { regimeChange: [] };
    }
    async init() {
        if (!this.app || !this.app.candles) return;
        this.calculateBaseMetrics();
        this.updateHorsemen();
        setInterval(() => this.update(), this.updateInterval);
    }
    async update() {
        try {
            const now = Date.now();
            const elapsed = now - this.lastUpdate;
            if (elapsed < this.updateInterval * 0.9) return;
            this.lastUpdate = now;
            this.calculateBaseMetrics();
            this.updateHorsemen();
        } catch (error) { console.error("Four Horsemen güncelleme hatası:", error); }
    }
    calculateBaseMetrics() {
        if (!this.app.candles || this.app.candles.length < 20) return;
        const candles = this.app.candles.slice(-20);
        let totalVolume = 0;
        candles.forEach(candle => { totalVolume += candle.volume; });
        this.averageVolume = totalVolume / candles.length;
        let totalRange = 0;
        candles.forEach(candle => { totalRange += Math.abs(candle.high - candle.low); });
        this.averageRange = totalRange / candles.length;
        const prices = candles.map(c => c.close);
        this.trendStrength = this.calculateTrendStrength(prices);
    }
    calculateTrendStrength(prices) {
        const n = prices.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        for (let i = 0; i < n; i++) {
            sumX += i;
            sumY += prices[i];
            sumXY += i * prices[i];
            sumX2 += i * i;
        }
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const normalizedSlope = (slope / prices[0]) * 100;
        return normalizedSlope;
    }
    updateHorsemen() {
        if (!this.app.candles || this.app.candles.length < 20) return;
        const candles = this.app.candles;
        const recent = candles.slice(-5);
        const current = candles[candles.length - 1];
        const previous = candles[candles.length - 2];
        const prevHorsemen = { ...this.horsemen };
        Object.keys(this.horsemen).forEach(key => { this.horsemen[key] = false; });
        const recentVolatility = this.calculateVolatility(recent.map(c => c.close));
        if (recentVolatility > this.volatilityThreshold) this.horsemen.war = true;
        const currentVolume = current.volume;
        if (currentVolume < this.averageVolume * this.liquidityThreshold) this.horsemen.famine = true;
        const recentTrendStrength = this.calculateTrendStrength(recent.map(c => c.close));
        if (Math.abs(recentTrendStrength) > Math.abs(this.trendStrength) * this.trendThreshold) this.horsemen.pestilence = true;
        const priceChange = ((current.close - previous.close) / previous.close) * 100;
        if (priceChange < this.dropThreshold) this.horsemen.death = true;
        if (this.hasRegimeChanged(prevHorsemen)) this.notifyRegimeChange();
        this.updateUI();
    }
    hasRegimeChanged(prevHorsemen) {
        for (const [key, value] of Object.entries(this.horsemen)) {
            if (prevHorsemen[key] !== value) return true;
        }
        return false;
    }
    notifyRegimeChange() {
        this.listeners.regimeChange.forEach(callback => { callback(this.getActiveRegime()); });
        const activeHorsemen = this.getActiveHorsemen();
        if (activeHorsemen.length > 0) {
            const message = `Mahşerin ${activeHorsemen.length > 1 ? "Atlıları" : "Atlısı"} görüldü: ${activeHorsemen.map(key => this.getHorsemanName(key)).join(", ")}`;
            if (this.app.notificationCenter) {
                this.app.notificationCenter.notify(message, 'warning', 3);
            } else {
                console.log(message);
            }
        }
    }
    calculateVolatility(prices) {
        const n = prices.length;
        if (n < 2) return 0;
        const avg = prices.reduce((sum, price) => sum + price, 0) / n;
        const variance = prices.reduce((sum, price) => sum + Math.pow(price - avg, 2), 0) / (n - 1);
        const stdDev = Math.sqrt(variance);
        return (stdDev / avg) * 100;
    }
    updateUI() {
        const kehanetPanel = document.getElementById('kehanet-panel');
        if (!kehanetPanel) return;

        // Update current regime in Kehanet Panel
        const regimeElement = kehanetPanel.querySelector('#kp-regime');
        if (regimeElement) {
            const activeRegime = this.getActiveRegime();
            regimeElement.textContent = activeRegime;
            // Apply appropriate class for styling
            regimeElement.className = 'kp-val';
            if (activeRegime === 'Savaş') {
                regimeElement.classList.add('trend-up');
            } else if (activeRegime === 'Ölüm') {
                regimeElement.classList.add('trend-down');
            } else if (activeRegime === 'Kıtlık' || activeRegime === 'Veba') {
                regimeElement.classList.add('trend-neutral');
            }
        }

        // Update the Panteon Panel's regime indicator
        const panteonRegimeElement = document.querySelector('#panteon-panel .current-regime');
        if (panteonRegimeElement) {
            panteonRegimeElement.textContent = this.getActiveRegime();
        }
    }
    getHorsemanName(key) {
        const names = { war: "Savaş", famine: "Kıtlık", pestilence: "Veba", death: "Ölüm" };
        return names[key] || key;
    }
    getActiveHorsemen() {
        return Object.entries(this.horsemen).filter(([_, active]) => active).map(([key, _]) => key);
    }
    isAnyHorsemanActive() {
        return Object.values(this.horsemen).some(active => active);
    }
    getActiveRegime() {
        const active = this.getActiveHorsemen();
        if (active.length === 0) return "Normal";
        if (active.includes("death")) return "Ölüm";
        if (active.includes("war")) return "Savaş";
        if (active.includes("pestilence")) return "Veba";
        if (active.includes("famine")) return "Kıtlık";
        return "Karışık";
    }
    onRegimeChange(callback) {
        if (typeof callback === 'function') this.listeners.regimeChange.push(callback);
    }
    updateThresholds(thresholds) {
        if (!thresholds) return;
        if (thresholds.volatility !== undefined) this.volatilityThreshold = thresholds.volatility;
        if (thresholds.liquidity !== undefined) this.liquidityThreshold = thresholds.liquidity;
        if (thresholds.trend !== undefined) this.trendThreshold = thresholds.trend;
        if (thresholds.drop !== undefined) this.dropThreshold = thresholds.drop;
        this.updateHorsemen();
    }
}

// Panteon ve Four Horsemen entegrasyonu
class PanteonHorsemenIntegration {
    constructor(app) {
        this.app = app;
        this.horsemenSystem = null;
        this.regimeHistory = [];
        this.maxHistorySize = 10;
    }
    async init() {
        this.horsemenSystem = new FourHorsemenSystem(this.app);
        this.horsemenSystem.init();
        this.horsemenSystem.onRegimeChange(regime => { this.recordRegimeChange(regime); });
        this.setupUIUpdater();
    }
    setupUIUpdater() {
        this.horsemenSystem.onRegimeChange(regime => {
            const regimeElement = document.querySelector('#kehanet-panel #kp-regime'); // Update Kehanet Panel
            if (regimeElement) {
                regimeElement.textContent = regime;
                regimeElement.className = 'kp-val';
                if (regime === 'Savaş') regimeElement.classList.add('trend-up');
                else if (regime === 'Ölüm') regimeElement.classList.add('trend-down');
                else regimeElement.classList.add('trend-neutral');
            }
            const panteonRegimeElement = document.querySelector('#panteon-panel .current-regime'); // Update Panteon Panel
            if (panteonRegimeElement) {
                panteonRegimeElement.textContent = regime;
            }
            // Trigger effects based on regime change
            if (this.app.effectsManager) {
                this.app.effectsManager.showHorsemanEffect(regime);
            }
        });
    }
    recordRegimeChange(regime) {
        const timestamp = new Date();
        this.regimeHistory.push({
            regime,
            timestamp,
            activeHorsemen: this.horsemenSystem ? this.horsemenSystem.getActiveHorsemen() : []
        });
        if (this.regimeHistory.length > this.maxHistorySize) this.regimeHistory.shift();
        // Regime history can be written to a table here
    }
    getRegimeHistory() { return this.regimeHistory; }
    getCurrentRegime() { return this.horsemenSystem ? this.horsemenSystem.getActiveRegime() : "Normal"; }
}

// DOM yüklendiğinde otomatik başlatmak için örnek entegrasyon
document.addEventListener('DOMContentLoaded', function() {
    if (!window.app) window.app = {};
    if (!window.app.candles) {
        // Basit örnek veri (gerçek sistemde canlı veri ile değiştirin)
        window.app.candles = Array.from({length: 100}, (_, i) => {
            const price = 100 + Math.sin(i/10)*5 + Math.random()*2;
            return {
                time: Date.now() - (100-i)*60000,
                open: price,
                close: price + (Math.random()-0.5),
                high: price * (1 + Math.random()*0.01),
                low: price * (1 - Math.random()*0.01),
                volume: 1000 + Math.random()*500
            };
        });
    }
    if (!window.app.notificationCenter) {
        window.app.notificationCenter = {
            notify: function(message, type, priority, duration) {
                console.log(`[${type}] ${message}`);
            }
        };
    }
    // Update the TheOracle instance in the main app
    if (window.app.oracle) {
        window.panteonHorsemenIntegration = new PanteonHorsemenIntegration(window.app);
        window.panteonHorsemenIntegration.init();
    }
});
</script>

<!-- Advanced Notification Container -->
<div id="notifications-container" class="notifications side-panel left-panel">
    <div class="panel-header">
        <span>📢 Bildirimler</span>
        <button class="pp-expand-btn" onclick="document.getElementById('notifications-container').classList.remove('active'); document.querySelector('#notifications-btn').classList.remove('active');">✖</button>
    </div>
    <div class="panel-body" id="notifications-list">
        <!-- Notifications will be inserted here by AdvancedNotificationCenter -->
    </div>
</div>

<!-- Notification History Modal -->
<div id="notification-history-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Bildirim Geçmişi</h3>
            <span class="close-modal">&times;</span>
        </div>
        <div class="modal-body">
            <div class="notification-filters">
                <button class="filter active" data-filter="all">Tümü</button>
                <button class="filter" data-filter="trade">İşlem</button>
                <button class="filter" data-filter="alert">Uyarı</button>
                <button class="filter" data-filter="success">Başarılı</button>
                <button class="filter" data-filter="error">Hata</button>
                <button class="filter" data-filter="system">Sistem</button>
            </div>
            <div id="notification-history-list"></div>
        </div>
        <div class="modal-footer">
            <button id="clear-notifications-history" class="btn btn-danger">Geçmişi Temizle</button>
        </div>
    </div>
</div>
</body>
</html>