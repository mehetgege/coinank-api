
<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gemini AI CryptoSignals Terminal</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Orbitron:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    /* CSS Variables for a futuristic dark theme */
    :root {
      --bg-primary: #0a0e14;
      --bg-secondary: #131a24;
      --bg-tertiary: #1c2533;
      --text-primary: #e0e6f1;
      --text-secondary: #8c98a9;
      --accent-blue-light: #4a90e2;
      --accent-blue-dark: #2a63b4;
      --success-green: #2ecc71; /* Brighter green */
      --danger-red: #e74c3c;     /* Brighter red */
      --warning-yellow: #f1c40f; /* Brighter yellow */
      --border-color: rgba(74, 144, 226, 0.2); /* Accent-based border */
      --card-bg: rgba(19, 26, 36, 0.85); /* Slightly transparent for blur */
      --input-bg: rgba(28, 37, 51, 0.7);
      --signal-long-bg: rgba(46, 204, 113, 0.1);
      --signal-short-bg: rgba(231, 76, 60, 0.1);
      --signal-neutral-bg: rgba(241, 196, 15, 0.08);
      --hover-bg: rgba(74, 144, 226, 0.08);
      --active-bg: rgba(74, 144, 226, 0.15);
      --scroll-thumb: var(--accent-blue-dark);
      --scroll-track: var(--bg-secondary);
    }

    /* General Resets */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: linear-gradient(145deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      color: var(--text-primary);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden; /* Prevent horizontal scroll */
    }

    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--scroll-track);
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--scroll-thumb);
      border-radius: 10px;
      border: 2px solid var(--scroll-track);
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--accent-blue-light);
    }
    
    /* Main Container */
    #app-container {
      max-width: 1500px;
      margin: 0 auto;
      padding: 25px;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      gap: 25px;
    }
    
    /* Header Section */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 25px 30px;
      background: var(--card-bg);
      border-radius: 15px;
      backdrop-filter: blur(15px);
      border: 1px solid var(--border-color);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      flex-wrap: wrap;
    }
    
    .header h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 32px;
      background: linear-gradient(90deg, var(--accent-blue-light), var(--accent-blue-dark));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-right: 20px;
    }

    #current-time {
        font-size: 16px;
        color: var(--text-secondary);
        font-weight: 500;
        letter-spacing: 0.5px;
        min-width: 150px;
        text-align: right;
    }
    
    /* Control Panel */
    .controls-panel {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }
    
    .controls-panel input {
      flex: 1;
      min-width: 250px;
      padding: 15px 20px;
      background: var(--input-bg);
      color: var(--text-primary);
      border: 1px solid var(--bg-tertiary);
      border-radius: 10px;
      font-size: 17px;
      transition: all 0.3s ease;
      font-family: 'Inter', sans-serif;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    
    .controls-panel input:focus {
      outline: none;
      border-color: var(--accent-blue-light);
      box-shadow: 0 0 0 4px rgba(74, 144, 226, 0.25);
    }
    
    .controls-panel button {
      padding: 15px 30px;
      background: linear-gradient(135deg, var(--accent-blue-light), var(--accent-blue-dark));
      color: #ffffff;
      border: none;
      border-radius: 10px;
      font-size: 17px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 20px rgba(74, 144, 226, 0.25);
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .controls-panel button:hover:not(:disabled) {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(74, 144, 226, 0.4);
    }
    
    .controls-panel button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    /* Info Grid Layout */
    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 20px;
    }
    
    .info-card {
      padding: 22px;
      background: var(--card-bg);
      border-radius: 12px;
      border: 1px solid rgba(74, 144, 226, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      overflow: hidden; /* For price up/down animation */
    }

    .info-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
    }
    
    .info-label {
      font-size: 13px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }
    
    .info-value {
      font-size: 28px;
      font-weight: 700;
      line-height: 1.2;
      display: flex;
      align-items: center;
    }
    
    .price-up { color: var(--success-green); }
    .price-down { color: var(--danger-red); }

    /* Main Grid Layout */
    .main-grid {
      display: grid;
      grid-template-columns: 3fr 1fr;
      gap: 25px;
    }

    @media (max-width: 1200px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }
    
    /* Chart Panel */
    .chart-panel {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 25px;
      border: 1px solid rgba(74, 144, 226, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
      height: 450px; /* Increased height for better chart view */
      display: flex;
      flex-direction: column;
      margin-bottom: 0; /* Remove extra margin if within main-grid */
    }
    
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .chart-title {
      font-size: 20px;
      font-weight: 600;
      color: var(--accent-blue-light);
      font-family: 'Orbitron', sans-serif;
      margin-right: 15px;
    }
    
    .chart-timeframes {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .timeframe-btn {
      padding: 8px 15px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px solid transparent;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
    }
    
    .timeframe-btn:hover {
      background: var(--hover-bg);
      color: var(--accent-blue-light);
      border-color: rgba(74, 144, 226, 0.15);
    }
    
    .timeframe-btn.active {
      background: var(--active-bg);
      color: var(--accent-blue-light);
      border-color: var(--accent-blue-dark);
    }
    
    .chart-container {
      flex: 1;
      position: relative;
    }
    
    /* Signal Output Area */
    .signals-panel {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 25px;
      border: 1px solid rgba(74, 144, 226, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 400px; /* Ensure it doesn't collapse */
    }
    
    .signals-title {
      font-size: 20px;
      font-weight: 600;
      color: var(--accent-blue-light);
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-family: 'Orbitron', sans-serif;
    }
    
    .signal-stats {
      font-size: 14px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    #signals-output {
      flex: 1;
      overflow-y: auto;
      background: rgba(10, 14, 20, 0.6);
      padding: 15px;
      border-radius: 10px;
      font-family: 'Inter', monospace; /* Monospace for clarity */
      font-size: 14px;
      line-height: 1.6;
      color: var(--text-primary);
      word-wrap: break-word;
      max-height: 700px; /* Limit height if content grows too much */
    }

    #signals-output p {
      padding: 12px;
      border-bottom: 1px dashed rgba(74, 144, 226, 0.1);
      margin: 0;
      border-radius: 8px;
      transition: background-color 0.2s ease;
    }

    #signals-output p:hover {
      background: var(--hover-bg);
    }

    #signals-output p:last-child {
      border-bottom: none;
    }

    .signal-long {
      background-color: var(--signal-long-bg);
      color: var(--success-green);
      font-weight: 600;
    }
    
    .signal-short {
      background-color: var(--signal-short-bg);
      color: var(--danger-red);
      font-weight: 600;
    }
    
    .signal-neutral {
      color: var(--warning-yellow);
      font-weight: 500;
    }

    .signal-timestamp {
      color: var(--text-secondary);
      font-size: 11px;
      font-weight: normal;
      margin-right: 8px;
      opacity: 0.8;
    }
    
    /* Status Bar (Fixed) */
    .status-bar {
      position: fixed;
      bottom: 25px;
      right: 25px;
      padding: 12px 25px;
      background: rgba(19, 26, 36, 0.95);
      border-radius: 10px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 15px;
      color: var(--text-primary);
      border: 1px solid rgba(74, 144, 226, 0.2);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
      z-index: 1000;
    }
    
    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: pulse 2s infinite cubic-bezier(0.4, 0, 0.6, 1);
    }
    
    .status-dot.connected { background: var(--success-green); }
    .status-dot.disconnected { background: var(--danger-red); }
    .status-dot.connecting { background: var(--warning-yellow); animation: pulse 1s linear infinite; }
    
    .loader {
      display: inline-block;
      width: 18px;
      height: 18px;
      border: 3px solid rgba(74, 144, 226, 0.3);
      border-top-color: var(--accent-blue-light);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    /* Order Book Styles */
    .depth-container {
      display: flex;
      flex-direction: column; /* Stack bids/asks if needed */
      flex: 1; /* Take remaining space in chart-panel */
    }
    
    .order-book {
      display: flex;
      flex-direction: column;
      width: 100%;
      border-radius: 8px;
      overflow: hidden;
      font-size: 13px;
      background: rgba(10, 14, 20, 0.6);
      border: 1px solid rgba(74, 144, 226, 0.1);
    }
    
    .order-book-header {
      display: grid;
      grid-template-columns: 1.2fr 1fr 1fr; /* Price, Amount, Total */
      background: var(--bg-tertiary);
      padding: 10px 15px;
      font-weight: 600;
      color: var(--text-secondary);
      text-align: right;
      border-bottom: 1px solid var(--border-color);
    }
    
    .order-book-header > div:first-child {
      text-align: left;
    }

    .order-column-wrapper { /* Added wrapper for scrollable columns */
        display: flex;
        flex-direction: column;
        flex: 1;
        overflow: hidden;
    }
    
    .order-column {
      overflow-y: auto;
      flex-grow: 1; /* Allow column to grow */
      max-height: 200px; /* Fixed height for each column */
      min-height: 100px;
    }
    
    .order-row {
      display: grid;
      grid-template-columns: 1.2fr 1fr 1fr;
      padding: 8px 15px;
      text-align: right;
      position: relative; /* For depth bar */
      overflow: hidden;
      transition: background-color 0.1s ease;
    }
    
    .order-row > div:first-child {
      text-align: left;
      z-index: 1;
      position: relative;
    }
    
    .bid-row {
      color: var(--success-green);
    }
    
    .bid-row:hover {
      background: var(--signal-long-bg);
    }
    
    .ask-row {
      color: var(--danger-red);
    }
    
    .ask-row:hover {
      background: var(--signal-short-bg);
    }
    
    .bid-price, .ask-price {
      font-weight: 600;
    }

    .depth-bar {
      position: absolute;
      top: 0;
      bottom: 0;
      opacity: 0.3;
      pointer-events: none; /* Make it unclickable */
      transition: width 0.1s ease;
    }
    
    .bid-bar {
      background: var(--success-green);
      right: 0;
    }
    
    .ask-bar {
      background: var(--danger-red);
      right: 0;
    }

    /* Tab Styles */
    .tabs {
      display: flex;
      margin-bottom: 10px;
      border-bottom: 1px solid var(--bg-tertiary);
      padding-top: 5px; /* Spacing from header */
    }
    
    .tab {
      padding: 10px 20px;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      font-size: 15px;
      font-weight: 500;
      transition: all 0.2s ease;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px solid transparent;
      margin-right: 5px;
      border-bottom: none; /* Handled by container */
    }
    
    .tab:hover {
      background: var(--hover-bg);
      color: var(--text-primary);
    }
    
    .tab.active {
      background: var(--card-bg); /* Match panel background */
      color: var(--accent-blue-light);
      border-color: var(--border-color);
      border-bottom-color: var(--card-bg); /* Hide bottom border */
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
      z-index: 1; /* Bring active tab to front */
    }

    .tab-content {
      flex: 1;
      display: none; /* Hidden by default */
      overflow: hidden;
    }

    .tab-content.active {
      display: block; /* Shown when active */
    }

    /* Media Queries (Responsive Design) */
    @media (max-width: 992px) {
      #app-container { padding: 20px; gap: 20px; }
      .header { flex-direction: column; align-items: flex-start; gap: 15px; padding: 20px; }
      .header h1 { font-size: 28px; margin-bottom: 10px; }
      #current-time { font-size: 15px; text-align: left; }
      .controls-panel { flex-direction: column; gap: 12px; }
      .controls-panel input, .controls-panel button { padding: 14px; font-size: 16px; min-width: unset; width: 100%;}
      .info-grid { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 15px; }
      .info-card { padding: 18px; }
      .info-value { font-size: 24px; }
      .chart-panel { padding: 20px; height: 400px; }
      .chart-header { flex-direction: column; align-items: flex-start; gap: 10px; }
      .chart-title { font-size: 18px; margin-bottom: 5px; }
      .chart-timeframes { flex-wrap: wrap; justify-content: flex-start; }
      .timeframe-btn { font-size: 13px; padding: 6px 12px; }
      .signals-panel { padding: 20px; min-height: 350px; }
      .signals-title { font-size: 18px; }
      #signals-output { font-size: 13px; padding: 12px; }
      .status-bar { bottom: 15px; right: 15px; padding: 10px 20px; font-size: 13px; }
      .status-dot { width: 10px; height: 10px; }
    }

    @media (max-width: 600px) {
      #app-container { padding: 15px; gap: 15px; }
      .header { padding: 15px; }
      .header h1 { font-size: 24px; }
      .controls-panel button { font-size: 15px; }
      .info-grid { grid-template-columns: 1fr 1fr; gap: 10px; }
      .info-card { padding: 15px; }
      .info-value { font-size: 20px; }
      .chart-panel { padding: 15px; height: 300px; }
      .chart-title { font-size: 16px; }
      .timeframe-btn { font-size: 11px; padding: 5px 10px; }
      .signals-panel { padding: 15px; min-height: 300px; }
      .signals-title { font-size: 16px; }
      #signals-output { font-size: 12px; padding: 10px; }
      .status-bar { bottom: 10px; right: 10px; padding: 8px 15px; font-size: 12px; }
    }
  </style>
</head>
<body>
  <div id="app-container">
    <header class="header">
      <h1>Gemini AI CryptoSignals Terminal</h1>
      <div id="current-time"></div>
    </header>
    
    <section class="controls-panel">
      <input id="symbolInput" type="text" placeholder="Enter symbol (e.g., BTCUSDT, ETHUSDT)" value="BTCUSDT" />
      <button id="startBtn">Connect & Start Signals</button>
      <button id="stopBtn" disabled>Stop</button>
    </section>
    
    <section class="info-grid">
      <div class="info-card">
        <div class="info-label">Current Price</div>
        <div class="info-value" id="price">-</div>
      </div>
      <div class="info-card">
        <div class="info-label">24h Change</div>
        <div class="info-value" id="change">-</div>
      </div>
      <div class="info-card">
        <div class="info-label">24h Volume</div>
        <div class="info-value" id="volume">-</div>
      </div>
      <div class="info-card">
        <div class="info-label">RSI (14)</div>
        <div class="info-value" id="rsi">-</div>
      </div>
    </section>
    
    <div class="main-grid">
      <div class="charts-column">
        <section class="chart-panel">
          <div class="chart-header">
            <div class="chart-title">Price Chart</div>
            <div class="chart-timeframes">
              <button class="timeframe-btn" data-interval="1m">1m</button>
              <button class="timeframe-btn" data-interval="5m">5m</button>
              <button class="timeframe-btn active" data-interval="15m">15m</button>
              <button class="timeframe-btn" data-interval="1h">1h</button>
              <button class="timeframe-btn" data-interval="4h">4h</button>
              <button class="timeframe-btn" data-interval="1d">1d</button>
            </div>
          </div>
          <div id="price-chart" class="chart-container"></div>
        </section>
        
        <section class="chart-panel">
          <div class="chart-header">
            <div class="chart-title">Market Depth</div>
            <div class="tabs">
              <div class="tab active" data-tab="depth-chart-content">Chart</div>
              <div class="tab" data-tab="order-book-content">Order Book</div>
            </div>
          </div>
          <div id="depth-chart-content" class="chart-container tab-content active"></div>
          <div id="order-book-content" class="tab-content depth-container">
            <div class="order-book">
              <div class="order-book-header">
                <div>Price (USDT)</div>
                <div>Amount</div>
                <div>Total</div>
              </div>
              <div class="order-column-wrapper">
                <div id="asks-container" class="order-column">
                  <!-- Ask orders will be injected here -->
                </div>
                <div id="bids-container" class="order-column">
                  <!-- Bid orders will be injected here -->
                </div>
              </div>
            </div>
          </div>
        </section>
      </div>
      
      <div class="signals-column">
        <section class="signals-panel">
          <div class="signals-title">
            <span>Signal Stream</span>
            <span id="signal-stats" class="signal-stats">Signals: 0 | LONG: 0 | SHORT: 0</span>
          </div>
          <div id="signals-output">
            <p><span class="signal-neutral">Signals will appear here once connected and data is received...</span></p>
          </div>
        </section>
      </div>
    </div>
  </div>
  
  <footer class="status-bar">
    <div class="status-dot disconnected" id="statusDot"></div>
    <span id="statusText">Disconnected</span>
    <div id="loadingIndicator" class="loader" style="display: none;"></div>
  </footer>

  <script>
    class GeminiCryptoSignalsTerminal {
      constructor() {
        // WebSocket instances
        this.wsConnections = {}; // Store all WebSocket connections
        this.wsUrls = {
          aggTrade: (symbol) => `wss://stream.binance.com/ws/${symbol.toLowerCase()}@aggTrade`,
          depth: (symbol) => `wss://stream.binance.com/ws/${symbol.toLowerCase()}@depth@100ms`, // More frequent depth
          ticker: (symbol) => `wss://stream.binance.com/ws/${symbol.toLowerCase()}@ticker`,
          kline: (symbol, interval) => `wss://stream.binance.com/ws/${symbol.toLowerCase()}@kline_${interval}`
        };

        // LightweightCharts instances
        this.priceChart = null;
        this.depthChart = null;
        this.candleSeries = null;
        this.volumeSeries = null;
        this.askSeries = null;
        this.bidSeries = null;

        // Configuration
        this.symbol = 'BTCUSDT';
        this.interval = '15m';
        this.klineLimit = 300; // Increased limit for better indicator calculation
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 20; // More attempts for mobile
        this.reconnectDelay = 1000; // Start with 1s, will use exponential backoff

        // Signal parameters (tuned for common strategies)
        this.rsiPeriod = 14;
        this.rsiOverbought = 70;
        this.rsiOversold = 30;
        this.emaShortPeriod = 9;
        this.emaMediumPeriod = 21;
        this.emaLongPeriod = 50;
        this.macdFastPeriod = 12;
        this.macdSlowPeriod = 26;
        this.macdSignalPeriod = 9;
        this.volumeThreshold = 1.8; // Higher threshold for volume spikes
        this.signalCheckInterval = 3000; // Check signals every 3 seconds

        // Stats
        this.signalCount = { total: 0, long: 0, short: 0 };

        // Data buffers
        this.klineHistory = []; // Stores formatted kline data for charts and indicators
        this.depthData = { bids: [], asks: [] }; // Raw depth data
        this.indicators = { rsi: [], emaShort: [], emaMedium: [], emaLong: [], macd: { macdLine: [], signalLine: [], histogram: [] } };

        // Timers
        this.clockTimer = null;
        this.signalTimer = null;
        this.connectionCheckTimer = null;

        // DOM Elements
        this.dom = {
          symbolInput: document.getElementById('symbolInput'),
          startBtn: document.getElementById('startBtn'),
          stopBtn: document.getElementById('stopBtn'),
          price: document.getElementById('price'),
          change: document.getElementById('change'),
          volume: document.getElementById('volume'),
          rsi: document.getElementById('rsi'),
          priceChartDiv: document.getElementById('price-chart'),
          depthChartDiv: document.getElementById('depth-chart-content'),
          orderBookContent: document.getElementById('order-book-content'),
          asksContainer: document.getElementById('asks-container'),
          bidsContainer: document.getElementById('bids-container'),
          statusDot: document.getElementById('statusDot'),
          statusText: document.getElementById('statusText'),
          loadingIndicator: document.getElementById('loadingIndicator'),
          currentTime: document.getElementById('current-time'),
          signalsOutput: document.getElementById('signals-output'),
          signalStats: document.getElementById('signal-stats'),
          timeframeButtons: document.querySelectorAll('.timeframe-btn'),
          tabs: document.querySelectorAll('.tab'),
          tabContents: document.querySelectorAll('.tab-content')
        };

        // Initialize
        this.init();
      }

      init() {
        this.setupEventListeners();
        this.startClock();
        this.loadPreferences();
        this.setupCharts();
        this.dom.symbolInput.value = this.symbol;
        this.dom.timeframeButtons.forEach(btn => {
          if (btn.dataset.interval === this.interval) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        this.dom.tabs.forEach(tab => { // Ensure correct tab is active on load
            const tabContentId = tab.dataset.tab;
            if (tabContentId === 'depth-chart-content') { // Default active tab
                tab.classList.add('active');
                document.getElementById(tabContentId).classList.add('active');
            } else {
                tab.classList.remove('active');
                document.getElementById(tabContentId).classList.remove('active');
            }
        });
      }

      loadPreferences() {
        const storedSymbol = localStorage.getItem('geminiSignalsSymbol');
        const storedInterval = localStorage.getItem('geminiSignalsInterval');
        if (storedSymbol) this.symbol = storedSymbol;
        if (storedInterval) this.interval = storedInterval;
      }

      savePreferences() {
        localStorage.setItem('geminiSignalsSymbol', this.symbol);
        localStorage.setItem('geminiSignalsInterval', this.interval);
      }

      setupEventListeners() {
        this.dom.startBtn.addEventListener('click', () => this.startTerminal());
        this.dom.stopBtn.addEventListener('click', () => this.stopTerminal());
        this.dom.symbolInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            this.startTerminal();
          }
        });

        this.dom.timeframeButtons.forEach(btn => {
          btn.addEventListener('click', (e) => {
            if (this.interval === btn.dataset.interval) return; // Prevent unnecessary reloads
            this.dom.timeframeButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this.interval = btn.dataset.interval;
            this.savePreferences();
            
            if (Object.keys(this.wsConnections).length > 0) { // If already connected, restart klines
              this.addSignal(`Timeframe changed to ${this.interval}. Reconnecting Klines...`, 'neutral');
              this.disconnectKlines();
              this.fetchHistoricalKlines();
              this.connectKlines();
            }
          });
        });

        this.dom.tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            this.dom.tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            this.dom.tabContents.forEach(content => content.classList.remove('active'));
            document.getElementById(tab.dataset.tab).classList.add('active');
            // Resize charts if they were hidden
            if (this.priceChart) this.priceChart.resize(this.dom.priceChartDiv.clientWidth, this.dom.priceChartDiv.clientHeight);
            if (this.depthChart) this.depthChart.resize(this.dom.depthChartDiv.clientWidth, this.dom.depthChartDiv.clientHeight);
          });
        });
      }

      startTerminal() {
        const inputSymbol = this.dom.symbolInput.value.trim().toUpperCase();
        if (!inputSymbol) {
          this.addSignal('Please enter a valid symbol (e.g., BTCUSDT).', 'neutral');
          return;
        }

        this.symbol = inputSymbol.endsWith('USDT') ? inputSymbol : inputSymbol + 'USDT';
        this.savePreferences();

        this.resetState();
        this.connectWebSockets();
        this.toggleControls(true);
      }

      stopTerminal() {
        this.disconnectWebSockets();
        this.toggleControls(false);
        this.updateStatus('Disconnected', 'disconnected');
        this.dom.loadingIndicator.style.display = 'none';
        this.addSignal('Disconnected from all market data streams.', 'neutral');
      }

      resetState() {
        this.disconnectWebSockets(); // Ensure all previous connections are closed

        // Clear charts
        if (this.candleSeries) this.candleSeries.setData([]);
        if (this.volumeSeries) this.volumeSeries.setData([]);
        if (this.askSeries) this.askSeries.setData([]);
        if (this.bidSeries) this.bidSeries.setData([]);

        // Clear order book
        this.dom.asksContainer.innerHTML = '';
        this.dom.bidsContainer.innerHTML = '';

        // Reset buffers
        this.klineHistory = [];
        this.depthData = { bids: [], asks: [] };
        this.indicators = { rsi: [], emaShort: [], emaMedium: [], emaLong: [], macd: { macdLine: [], signalLine: [], histogram: [] } };

        // Reset stats
        this.signalCount = { total: 0, long: 0, short: 0 };
        this.updateSignalStats();

        // Reset UI
        this.dom.price.textContent = '-';
        this.dom.change.innerHTML = '-';
        this.dom.volume.textContent = '-';
        this.dom.rsi.textContent = '-';
        this.dom.signalsOutput.innerHTML = '<p><span class="signal-neutral">Signals will appear here once connected and data is received...</span></p>';
      }

      toggleControls(connecting) {
        this.dom.symbolInput.disabled = connecting;
        this.dom.startBtn.disabled = connecting;
        this.dom.stopBtn.disabled = !connecting;
        this.dom.loadingIndicator.style.display = connecting ? 'inline-block' : 'none';
      }

      connectWebSockets() {
        this.updateStatus('Connecting...', 'connecting');
        this.reconnectAttempts = 0;

        const symbolLower = this.symbol.toLowerCase();

        // AggTrade WebSocket
        this.connectWebSocket('aggTrade', this.wsUrls.aggTrade(this.symbol), (data) => this.handleAggTrade(data));
        // Depth WebSocket
        this.connectWebSocket('depth', this.wsUrls.depth(this.symbol), (data) => this.handleDepth(data));
        // Ticker WebSocket
        this.connectWebSocket('ticker', this.wsUrls.ticker(this.symbol), (data) => this.handleTicker(data));
        // Klines WebSocket
        this.connectKlines();

        // Fetch historical data first, then start signal generation
        this.fetchHistoricalKlines();
        this.startSignalGeneration();
        this.startConnectionCheck();
      }

      connectWebSocket(type, url, messageHandler) {
        this.disconnectSingleWebSocket(type); // Ensure clean slate
        try {
          const ws = new WebSocket(url);
          this.wsConnections[type] = ws;

          ws.onopen = () => {
            console.log(`${type} WebSocket connected`);
            this.updateStatus('Connected', 'connected');
            this.reconnectAttempts = 0; // Reset attempts on successful connection
          };

          ws.onmessage = (event) => {
            this.lastMessageTime = Date.now();
            messageHandler(JSON.parse(event.data));
          };

          ws.onerror = (e) => this.handleWebSocketError(e, type);
          ws.onclose = (e) => this.handleWebSocketClose(e, type);
        } catch (err) {
          console.error(`WebSocket creation error for ${type}:`, err);
          this.addSignal(`Connection error for ${type}: ${err.message}.`, 'short');
          this.updateStatus('Connection Error', 'disconnected');
          this.toggleControls(false);
        }
      }

      connectKlines() {
        this.connectWebSocket('kline', this.wsUrls.kline(this.symbol, this.interval), (data) => this.handleKline(data));
      }

      disconnectKlines() {
        this.disconnectSingleWebSocket('kline');
      }

      disconnectSingleWebSocket(type) {
        if (this.wsConnections[type]) {
          this.wsConnections[type].close();
          this.wsConnections[type] = null;
          delete this.wsConnections[type];
        }
      }

      disconnectWebSockets() {
        for (const type in this.wsConnections) {
          this.disconnectSingleWebSocket(type);
        }
        clearInterval(this.signalTimer);
        this.signalTimer = null;
        clearInterval(this.connectionCheckTimer);
        this.connectionCheckTimer = null;
        console.log("All WebSockets disconnected.");
      }

      startConnectionCheck() {
        clearInterval(this.connectionCheckTimer);
        this.connectionCheckTimer = setInterval(() => {
          const currentTime = Date.now();
          // Check if any WebSocket is still alive or attempting to connect
          const anyConnectedOrConnecting = Object.values(this.wsConnections).some(ws => ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING));

          if (!anyConnectedOrConnecting && this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1); // Exponential backoff
            console.warn(`Attempting full reconnection in ${delay / 1000}s (Attempt ${this.reconnectAttempts})`);
            this.updateStatus(`Reconnecting... (${this.reconnectAttempts})`, 'connecting');
            setTimeout(() => this.connectWebSockets(), Math.min(delay, 30000)); // Cap delay at 30s
          } else if (!anyConnectedOrConnecting && this.reconnectAttempts >= this.maxReconnectAttempts) {
            this.updateStatus('Connection Failed', 'disconnected');
            this.addSignal('Maximum reconnection attempts reached. Please check your internet connection and refresh.', 'short');
            this.toggleControls(false);
            this.disconnectWebSockets(); // Stop trying
          } else if (anyConnectedOrConnecting) {
             this.updateStatus('Connected', 'connected');
             this.reconnectAttempts = 0; // Reset on successful check
          }
        }, 15000); // Check every 15 seconds
      }

      handleWebSocketError(event, type) {
        console.error(`${type} WebSocket error:`, event);
        this.updateStatus(`Error (${type})`, 'disconnected');
        this.addSignal(`WebSocket error for ${type}. Attempting reconnect...`, 'neutral');
        this.disconnectSingleWebSocket(type); // Close errored connection
      }

      handleWebSocketClose(event, type) {
        console.log(`${type} WebSocket closed:`, event);
        if (!event.wasClean) {
          console.warn(`${type} closed uncleanly. Attempting reconnect.`);
          this.addSignal(`${type} connection lost. Reconnecting...`, 'neutral');
          setTimeout(() => {
            if (type === 'kline') {
              this.connectKlines();
            } else {
              this.reconnectSingleWebSocket(type);
            }
          }, this.reconnectDelay); // Short initial delay
        }
      }

      reconnectSingleWebSocket(type) {
        if (!this.wsConnections[type] || this.wsConnections[type].readyState === WebSocket.CLOSED) {
          if (type === 'aggTrade') this.connectWebSocket('aggTrade', this.wsUrls.aggTrade(this.symbol), (data) => this.handleAggTrade(data));
          else if (type === 'depth') this.connectWebSocket('depth', this.wsUrls.depth(this.symbol), (data) => this.handleDepth(data));
          else if (type === 'ticker') this.connectWebSocket('ticker', this.wsUrls.ticker(this.symbol), (data) => this.handleTicker(data));
        }
      }

      async fetchHistoricalKlines() {
        try {
          this.updateStatus('Loading Historical Data...', 'connecting');
          const apiUrl = `https://api.binance.com/api/v3/klines?symbol=${this.symbol}&interval=${this.interval}&limit=${this.klineLimit}`;
          
          const response = await fetch(apiUrl);
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.json();
          
          const formattedData = data.map(k => ({
            time: k[0] / 1000,
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
          }));
          
          if (formattedData.length === 0) {
            throw new Error("No valid historical data received. Check symbol or interval.");
          }
          
          this.klineHistory = formattedData;
          this.updatePriceChart(formattedData, true); // True for initial set
          this.calculateIndicators(formattedData);
          this.updateStatus('Connected', 'connected');
          this.addSignal(`Historical data loaded for ${this.symbol} (${this.interval}).`, 'neutral');
        } catch (error) {
          console.error('Error fetching historical klines:', error);
          this.addSignal(`Failed to load historical price data: ${error.message}.`, 'short');
          this.updateStatus('Data Error!', 'disconnected');
          this.toggleControls(false);
        }
      }

      handleAggTrade(data) {
        try {
          // No direct UI update needed from aggTrade, it just confirms connection
          // Price and volume will come from Ticker.
        } catch (error) {
          console.error('Error processing AggTrade:', error);
        }
      }

      handleDepth(data) {
        try {
          // Process updates from @depth@100ms
          // Bids are sorted descending by price, asks ascending.
          this.depthData.bids = data.b.map(item => ({ price: parseFloat(item[0]), amount: parseFloat(item[1]) }));
          this.depthData.asks = data.a.map(item => ({ price: parseFloat(item[0]), amount: parseFloat(item[1]) }));
          
          this.updateDepthChart();
          this.updateOrderBook();
        } catch (error) {
          console.error('Error processing Depth:', error);
        }
      }

      handleTicker(data) {
        try {
          const currentPrice = parseFloat(data.c);
          const priceChange = parseFloat(data.p);
          const changePercent = parseFloat(data.P);
          const volume = parseFloat(data.v);

          this.updateCurrentPrice(currentPrice, priceChange >= 0);

          this.dom.change.innerHTML = `
            <span class="${changePercent >= 0 ? 'price-up' : 'price-down'}">
              ${changePercent >= 0 ? '+' : ''}${this.formatNumber(changePercent, 2)}%
            </span>
          `;
          this.dom.volume.textContent = this.formatVolume(volume);
        } catch (error) {
          console.error('Error processing Ticker:', error);
        }
      }

      handleKline(data) {
        try {
          if (data.e === 'kline') {
            const k = data.k;
            const newCandle = {
              time: k.t / 1000,
              open: parseFloat(k.o),
              high: parseFloat(k.h),
              low: parseFloat(k.l),
              close: parseFloat(k.c),
              volume: parseFloat(k.v)
            };
            
            // Update chart with live candle
            this.updatePriceChart([newCandle]);
            
            // If the candle is closed, update history and recalculate indicators
            if (k.x) { // k.x is 'is this candle closed?'
              const lastIndex = this.klineHistory.length - 1;
              if (lastIndex >= 0 && this.klineHistory[lastIndex].time === newCandle.time) {
                // Update existing last candle if it's the same time
                this.klineHistory[lastIndex] = newCandle;
              } else {
                // Add new candle
                this.klineHistory.push(newCandle);
                // Keep history limited
                if (this.klineHistory.length > this.klineLimit) {
                  this.klineHistory.shift();
                }
              }
              this.calculateIndicators(this.klineHistory);
            }
          }
        } catch (error) {
          console.error('Error processing Kline:', error);
        }
      }

      // Chart Setup and Update
      setupCharts() {
        const chartOptions = {
          layout: {
            backgroundColor: 'transparent',
            textColor: varColor('--text-secondary'),
          },
          grid: {
            vertLines: { color: varColor('--bg-tertiary') },
            horzLines: { color: varColor('--bg-tertiary') },
          },
          timeScale: {
            timeVisible: true,
            secondsVisible: false,
            borderColor: varColor('--border-color'),
          },
          rightPriceScale: {
            borderColor: varColor('--border-color'),
          },
          crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal,
          },
        };

        // Price Chart
        if (this.priceChart) {
          this.priceChart.remove();
        }
        this.priceChart = LightweightCharts.createChart(this.dom.priceChartDiv, {
          ...chartOptions,
          width: this.dom.priceChartDiv.clientWidth,
          height: this.dom.priceChartDiv.clientHeight,
        });

        this.candleSeries = this.priceChart.addCandlestickSeries({
          upColor: varColor('--success-green'),
          downColor: varColor('--danger-red'),
          borderVisible: false,
          wickUpColor: varColor('--success-green'),
          wickDownColor: varColor('--danger-red'),
        });

        this.volumeSeries = this.priceChart.addHistogramSeries({
          color: '#26a69a', // Default, will be overridden by update
          lineWidth: 2,
          priceFormat: {
            type: 'volume',
          },
          overlay: true,
          scaleMargins: {
            top: 0.8,
            bottom: 0,
          },
        });

        // Depth Chart
        if (this.depthChart) {
          this.depthChart.remove();
        }
        this.depthChart = LightweightCharts.createChart(this.dom.depthChartDiv, {
          ...chartOptions,
          width: this.dom.depthChartDiv.clientWidth,
          height: this.dom.depthChartDiv.clientHeight,
        });

        this.bidSeries = this.depthChart.addLineSeries({
          color: varColor('--success-green'),
          lineWidth: 2,
          lineType: LightweightCharts.LineType.Stepped,
          crosshairMarkerVisible: false,
          priceLineVisible: false,
          lastValueVisible: false,
          topColor: 'rgba(46, 204, 113, 0.2)',
          bottomColor: 'rgba(46, 204, 113, 0.05)',
        });
        
        this.askSeries = this.depthChart.addLineSeries({
          color: varColor('--danger-red'),
          lineWidth: 2,
          lineType: LightweightCharts.LineType.Stepped,
          crosshairMarkerVisible: false,
          priceLineVisible: false,
          lastValueVisible: false,
          topColor: 'rgba(231, 76, 60, 0.2)',
          bottomColor: 'rgba(231, 76, 60, 0.05)',
        });
        
        // Helper to get CSS variable values
        function varColor(variable) {
            return getComputedStyle(document.documentElement).getPropertyValue(variable).trim();
        }

        // Handle chart resizing
        new ResizeObserver(entries => {
          if (this.priceChart) {
            const entry = entries.find(e => e.target === this.dom.priceChartDiv);
            if (entry) this.priceChart.resize(entry.contentRect.width, entry.contentRect.height);
          }
          if (this.depthChart) {
            const entry = entries.find(e => e.target === this.dom.depthChartDiv);
            if (entry) this.depthChart.resize(entry.contentRect.width, entry.contentRect.height);
          }
        }).observe(this.dom.priceChartDiv);
        new ResizeObserver(entries => {
          if (this.depthChart) {
            const entry = entries.find(e => e.target === this.dom.depthChartDiv);
            if (entry) this.depthChart.resize(entry.contentRect.width, entry.contentRect.height);
          }
        }).observe(this.dom.depthChartDiv);
      }

      updatePriceChart(data, isInitialSet = false) {
        if (isInitialSet) {
          this.candleSeries.setData(data);
          this.volumeSeries.setData(data.map(d => ({
            time: d.time,
            value: d.volume,
            color: d.close > d.open ? varColor('--success-green') : varColor('--danger-red')
          })));
        } else if (data.length > 0) {
          const latestCandle = data[data.length - 1];
          this.candleSeries.update(latestCandle);
          this.volumeSeries.update({
            time: latestCandle.time,
            value: latestCandle.volume,
            color: latestCandle.close > latestCandle.open ? varColor('--success-green') : varColor('--danger-red')
          });
        }
      }

      updateDepthChart() {
        if (!this.askSeries || !this.bidSeries || !this.depthData.asks.length || !this.depthData.bids.length) {
          this.askSeries.setData([]);
          this.bidSeries.setData([]);
          return;
        }

        const maxDepthEntries = 50; // Use more entries for chart, fewer for table
        
        // Ask (sell) data for chart (sorted ascending by price)
        let cumulativeAskVolume = 0;
        const askChartData = this.depthData.asks
          .sort((a, b) => a.price - b.price)
          .slice(0, maxDepthEntries)
          .map(item => {
            cumulativeAskVolume += item.amount;
            return { time: item.price, value: cumulativeAskVolume };
          });
        
        // Bid (buy) data for chart (sorted descending by price)
        let cumulativeBidVolume = 0;
        const bidChartData = this.depthData.bids
          .sort((a, b) => b.price - a.price)
          .slice(0, maxDepthEntries)
          .map(item => {
            cumulativeBidVolume += item.amount;
            return { time: item.price, value: cumulativeBidVolume };
          })
          .reverse(); // Reverse to match chart's ascending time scale

        this.askSeries.setData(askChartData);
        this.bidSeries.setData(bidChartData);

        // Adjust visible range to show the spread
        if (askChartData.length > 0 && bidChartData.length > 0) {
            const minPrice = Math.min(bidChartData[0].time, askChartData[0].time);
            const maxPrice = Math.max(bidChartData[bidChartData.length - 1].time, askChartData[askChartData.length - 1].time);
            
            // Give a small buffer
            const buffer = (maxPrice - minPrice) * 0.05;
            this.depthChart.timeScale().setVisibleRange({
                from: minPrice - buffer,
                to: maxPrice + buffer
            });
        }
      }

      updateOrderBook() {
        if (!this.depthData.asks.length || !this.depthData.bids.length) {
          this.dom.asksContainer.innerHTML = '<div>No asks available.</div>';
          this.dom.bidsContainer.innerHTML = '<div>No bids available.</div>';
          return;
        }
        
        const displayLimit = 15; // Number of orders to display in the table
        
        const maxTotalVolume = Math.max(
            ...this.depthData.bids.map(item => item.amount),
            ...this.depthData.asks.map(item => item.amount)
        );

        // Render Ask orders (selling, red, sorted high to low for display)
        this.dom.asksContainer.innerHTML = '';
        this.depthData.asks
            .sort((a, b) => b.price - a.price) // Sort high to low for asks display
            .slice(0, displayLimit)
            .forEach(item => {
                const total = item.price * item.amount;
                const volumePercentage = (item.amount / maxTotalVolume) * 100;
                const row = document.createElement('div');
                row.className = 'order-row ask-row';
                row.innerHTML = `
                    <div class="ask-price">${this.formatNumber(item.price, item.price < 1 ? 6 : 2)}</div>
                    <div>${this.formatNumber(item.amount, 4)}</div>
                    <div>${this.formatNumber(total, 2)}</div>
                    <div class="depth-bar ask-bar" style="width: ${volumePercentage}%"></div>
                `;
                this.dom.asksContainer.appendChild(row);
            });
        
        // Render Bid orders (buying, green, sorted high to low for display)
        this.dom.bidsContainer.innerHTML = '';
        this.depthData.bids
            .sort((a, b) => b.price - a.price) // Sort high to low for bids display
            .slice(0, displayLimit)
            .forEach(item => {
                const total = item.price * item.amount;
                const volumePercentage = (item.amount / maxTotalVolume) * 100;
                const row = document.createElement('div');
                row.className = 'order-row bid-row';
                row.innerHTML = `
                    <div class="bid-price">${this.formatNumber(item.price, item.price < 1 ? 6 : 2)}</div>
                    <div>${this.formatNumber(item.amount, 4)}</div>
                    <div>${this.formatNumber(total, 2)}</div>
                    <div class="depth-bar bid-bar" style="width: ${volumePercentage}%"></div>
                `;
                this.dom.bidsContainer.appendChild(row);
            });
      }

      // Indicator Calculations
      calculateIndicators(data) {
        if (!data || data.length < Math.max(this.rsiPeriod, this.emaLongPeriod, this.macdSlowPeriod + this.macdSignalPeriod)) {
          // Not enough data for full calculation
          this.dom.rsi.textContent = '-';
          this.indicators = { rsi: [], emaShort: [], emaMedium: [], emaLong: [], macd: { macdLine: [], signalLine: [], histogram: [] } };
          return;
        }
        
        const closes = data.map(candle => candle.close);

        this.indicators.rsi = this._calculateRSI(closes, this.rsiPeriod);
        this.indicators.emaShort = this._calculateEMA(closes, this.emaShortPeriod);
        this.indicators.emaMedium = this._calculateEMA(closes, this.emaMediumPeriod);
        this.indicators.emaLong = this._calculateEMA(closes, this.emaLongPeriod);
        this.indicators.macd = this._calculateMACD(closes, this.macdFastPeriod, this.macdSlowPeriod, this.macdSignalPeriod);

        // Update UI with latest RSI
        const lastRsi = this.indicators.rsi[this.indicators.rsi.length - 1];
        if (lastRsi !== undefined && !isNaN(lastRsi)) {
          this.dom.rsi.innerHTML = `<span class="${lastRsi > this.rsiOverbought ? 'price-down' : lastRsi < this.rsiOversold ? 'price-up' : ''}">${this.formatNumber(lastRsi, 1)}</span>`;
        } else {
          this.dom.rsi.textContent = '-';
        }
      }

      _calculateRSI(closes, period) {
        const rsiValues = [];
        let avgGain = 0;
        let avgLoss = 0;

        for (let i = 1; i <= closes.length; i++) {
            if (i <= period) {
                // Initial calculation for the first 'period' candles
                if (i > 1) {
                    const diff = closes[i-1] - closes[i-2];
                    if (diff > 0) avgGain += diff;
                    else avgLoss += Math.abs(diff);
                }
                if (i === period) {
                    avgGain /= period;
                    avgLoss /= period;
                    const rs = avgLoss === 0 ? 200 : avgGain / avgLoss; // Handle division by zero
                    rsiValues.push(100 - (100 / (1 + rs)));
                } else { // This else block handles calculations beyond initial setup for a more robust RSI calculation
                    const diff = closes[i-1] - closes[i-2];
                    const gain = diff > 0 ? diff : 0;
                    const loss = diff < 0 ? Math.abs(diff) : 0;

                    avgGain = ((avgGain * (period - 1)) + gain) / period;
                    avgLoss = ((avgLoss * (period - 1)) + loss) / period;

                    const rs = avgLoss === 0 ? 200 : avgGain / avgLoss;
                    rsiValues.push(100 - (100 / (1 + rs)));
                }
            } else { // Subsequent calculations using smoothing formula
                const diff = closes[i-1] - closes[i-2];
                const gain = diff > 0 ? diff : 0;
                const loss = diff < 0 ? Math.abs(diff) : 0;

                avgGain = ((avgGain * (period - 1)) + gain) / period;
                avgLoss = ((avgLoss * (period - 1)) + loss) / period;

                const rs = avgLoss === 0 ? 200 : avgGain / avgLoss;
                rsiValues.push(100 - (100 / (1 + rs)));
            }
        }
        return rsiValues;
      }

      _calculateEMA(closes, period) {
        if (closes.length < period) return [];
        const emaValues = [];
        const k = 2 / (period + 1);

        // Calculate initial SMA for the first EMA
        let sum = 0;
        for (let i = 0; i < period; i++) {
          sum += closes[i];
        }
        emaValues.push(sum / period);

        // Calculate subsequent EMAs
        for (let i = period; i < closes.length; i++) {
          const ema = (closes[i] * k) + (emaValues[emaValues.length - 1] * (1 - k));
          emaValues.push(ema);
        }
        return emaValues;
      }

      _calculateMACD(closes, fastPeriod, slowPeriod, signalPeriod) {
        const fastEMA = this._calculateEMA(closes, fastPeriod);
        const slowEMA = this._calculateEMA(closes, slowPeriod);

        const macdLine = [];
        const minLength = Math.min(fastEMA.length, slowEMA.length);
        for (let i = 0; i < minLength; i++) {
          macdLine.push(fastEMA[fastEMA.length - minLength + i] - slowEMA[slowEMA.length - minLength + i]);
        }

        const signalLine = this._calculateEMA(macdLine, signalPeriod);

        const histogram = [];
        const macdStartIdx = macdLine.length - signalLine.length;
        for (let i = macdStartIdx; i < macdLine.length; i++) {
          histogram.push(macdLine[i] - signalLine[i - macdStartIdx]);
        }
        
        return { macdLine, signalLine, histogram };
      }

      // Signal Generation
      startSignalGeneration() {
        clearInterval(this.signalTimer);
        this.signalTimer = setInterval(() => {
          this.generateSignals();
        }, this.signalCheckInterval);
      }

      generateSignals() {
        if (!this.klineHistory.length || this.klineHistory.length < Math.max(this.rsiPeriod, this.emaLongPeriod, this.macdSlowPeriod + this.macdSignalPeriod)) {
          return; // Not enough data for reliable signals
        }
        
        const signals = [];
        const lastCandle = this.klineHistory[this.klineHistory.length - 1];
        const prevCandle = this.klineHistory[this.klineHistory.length - 2];
        
        if (!lastCandle || !prevCandle) return;

        const price = lastCandle.close;
        const lastRsi = this.indicators.rsi[this.indicators.rsi.length - 1];
        const prevRsi = this.indicators.rsi[this.indicators.rsi.length - 2];
        
        // RSI Signals
        if (lastRsi < this.rsiOversold && prevRsi >= this.rsiOversold) {
          signals.push({ type: 'long', strength: 2, reason: `RSI rising from oversold (${this.formatNumber(lastRsi, 1)})` });
        } else if (lastRsi > this.rsiOverbought && prevRsi <= this.rsiOverbought) {
          signals.push({ type: 'short', strength: 2, reason: `RSI entering overbought (${this.formatNumber(lastRsi, 1)})` });
        }
        
        // EMA Crossover Signals (Golden/Death Cross - Short EMA crossing Medium EMA)
        const lastShortEma = this.indicators.emaShort[this.indicators.emaShort.length - 1];
        const prevShortEma = this.indicators.emaShort[this.indicators.emaShort.length - 2];
        const lastMediumEma = this.indicators.emaMedium[this.indicators.emaMedium.length - 1];
        const prevMediumEma = this.indicators.emaMedium[this.indicators.emaMedium.length - 2];

        if (lastShortEma > lastMediumEma && prevShortEma <= prevMediumEma) {
          signals.push({ type: 'long', strength: 3, reason: `EMA${this.emaShortPeriod} crossed above EMA${this.emaMediumPeriod} (Golden Cross)` });
        } else if (lastShortEma < lastMediumEma && prevShortEma >= prevMediumEma) {
          signals.push({ type: 'short', strength: 3, reason: `EMA${this.emaShortPeriod} crossed below EMA${this.emaMediumPeriod} (Death Cross)` });
        }

        // MACD Signals (Crossover of MACD line and Signal line)
        const lastMacdLine = this.indicators.macd.macdLine[this.indicators.macd.macdLine.length - 1];
        const prevMacdLine = this.indicators.macd.macdLine[this.indicators.macd.macdLine.length - 2];
        const lastSignalLine = this.indicators.macd.signalLine[this.indicators.macd.signalLine.length - 1];
        const prevSignalLine = this.indicators.macd.signalLine[this.indicators.macd.signalLine.length - 2];

        if (lastMacdLine > lastSignalLine && prevMacdLine <= prevSignalLine) {
            signals.push({ type: 'long', strength: 2, reason: 'MACD line crossed above Signal line (Bullish Crossover)' });
        } else if (lastMacdLine < lastSignalLine && prevMacdLine >= prevSignalLine) {
            signals.push({ type: 'short', strength: 2, reason: 'MACD line crossed below Signal line (Bearish Crossover)' });
        }

        // Volume Spike Signals
        const last10Candles = this.klineHistory.slice(-10);
        const avgVolume = last10Candles.reduce((sum, candle) => sum + candle.volume, 0) / last10Candles.length;
        if (lastCandle.volume > avgVolume * this.volumeThreshold) {
          if (lastCandle.close > lastCandle.open) {
            signals.push({ type: 'long', strength: 1, reason: `High volume green candle (${this.formatNumber(lastCandle.volume / avgVolume, 1)}x avg. volume)` });
          } else if (lastCandle.close < lastCandle.open) {
            signals.push({ type: 'short', strength: 1, reason: `High volume red candle (${this.formatNumber(lastCandle.volume / avgVolume, 1)}x avg. volume)` });
          }
        }
        
        // Consolidate signals and determine final action
        let totalLongStrength = 0;
        let totalShortStrength = 0;
        let longReasons = [];
        let shortReasons = [];

        signals.forEach(signal => {
            if (signal.type === 'long') {
                totalLongStrength += signal.strength;
                longReasons.push(signal.reason);
            } else if (signal.type === 'short') {
                totalShortStrength += signal.strength;
                shortReasons.push(signal.reason);
            }
        });

        const minStrengthForSignal = 4; // Require at least 4 points for a confident signal

        if (totalLongStrength >= minStrengthForSignal && totalLongStrength > totalShortStrength) {
            this.addSignal(
                ` LONG SIGNAL for ${this.symbol} [Strength: ${totalLongStrength}]: ${longReasons.join(' | ')}`,
                'long'
            );
            this.signalCount.long++;
            this.signalCount.total++;
        } else if (totalShortStrength >= minStrengthForSignal && totalShortStrength > totalLongStrength) {
            this.addSignal(
                ` SHORT SIGNAL for ${this.symbol} [Strength: ${totalShortStrength}]: ${shortReasons.join(' | ')}`,
                'short'
            );
            this.signalCount.short++;
            this.signalCount.total++;
        } else if (signals.length > 0) {
            // Optional: Log weaker or conflicting signals as neutral
            // this.addSignal(`Neutral outlook for ${this.symbol}. Conflicting or weak signals.`, 'neutral');
        }
        this.updateSignalStats();
      }

      addSignal(message, type) {
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const p = document.createElement('p');
        p.className = `signal-${type}`;
        p.innerHTML = `<span class="signal-timestamp">${timestamp}</span>${message}`;
        
        // Add to top of the signal output
        if (this.dom.signalsOutput.firstChild) {
            this.dom.signalsOutput.insertBefore(p, this.dom.signalsOutput.firstChild);
        } else {
            this.dom.signalsOutput.appendChild(p);
        }

        // Limit the number of signals to avoid performance issues
        while (this.dom.signalsOutput.children.length > 100) {
          this.dom.signalsOutput.removeChild(this.dom.signalsOutput.lastChild);
        }
      }

      updateSignalStats() {
        this.dom.signalStats.textContent = `Signals: ${this.signalCount.total} | LONG: ${this.signalCount.long} | SHORT: ${this.signalCount.short}`;
      }

      // Utility Functions
      startClock() {
        this.clockTimer = setInterval(() => {
          this.dom.currentTime.textContent = new Date().toLocaleString('en-US', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: true,
            day: '2-digit',
            month: 'short',
            year: 'numeric'
          });
        }, 1000);
      }

      updateStatus(text, statusClass) {
        this.dom.statusText.textContent = text;
        this.dom.statusDot.className = `status-dot ${statusClass}`;
      }

      formatNumber(num, decimalPlaces) {
        if (typeof num !== 'number' || isNaN(num)) return '-';
        return num.toLocaleString('en-US', {
            minimumFractionDigits: decimalPlaces,
            maximumFractionDigits: decimalPlaces,
            useGrouping: true
        });
      }

      formatVolume(volume) {
        if (volume >= 1_000_000_000) {
          return this.formatNumber(volume / 1_000_000_000, 2) + 'B';
        } else if (volume >= 1_000_000) {
          return this.formatNumber(volume / 1_000_000, 2) + 'M';
        } else if (volume >= 1_000) {
          return this.formatNumber(volume / 1_000, 2) + 'K';
        } else {
          return this.formatNumber(volume, 2);
        }
      }
    }

    // Initialize the terminal when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      new GeminiCryptoSignalsTerminal();
    });
  </script>
</body>
</html>
--- END OF FILE indi.html ---