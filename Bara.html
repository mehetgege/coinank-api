
<!DOCTYPE html>
<html lang="tr" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTIMATE TRADING KOMUTA MERKEZİ v2.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>

    <style>
        :root {
            --background-dark: #0d1117; --panel-bg-dark: #161b22; --text-main-dark: #c9d1d9; --text-secondary-dark: #8b949e; --border-color-dark: #30363d; --input-bg-dark: #010409; --hover-bg-dark: #21262d; --primary-dark: #58a6ff;
            --background-light: #ffffff; --panel-bg: #f6f8fa; --text-main: #24292f; --text-secondary: #57606a; --border-color: #d0d7de; --input-bg: #f0f2f5; --hover-bg: #e8eaed; --primary: #0969da;
            --war-mode-bg: linear-gradient(145deg, #4d0000 0%, #000000 75%); --war-mode-panel-bg: rgba(255, 0, 0, 0.08); --war-mode-border: #8B0000; --war-mode-text: #ff5858; --war-mode-primary: #ffc107;
            --positive: #28a745; --negative: #dc3545; --neutral: #ffc107;
            --ticker-height: 30px; 
            --signal-bar-height: 40px;
            --header-min-height: 40px;
        }
        /* Fullscreen modda gizlenecek elemanlar */
        body.fullscreen-chart #super-top-ticker,
        body.fullscreen-chart #signal-progress-bar-container,
        body.fullscreen-chart .header,
        body.fullscreen-chart .panel-title {
            display: none !important;
        }

        /* Fullscreen modda chart'ı büyütme */
        body.fullscreen-chart .container { padding-top: 0 !important; height: 100vh !important; }
        body.fullscreen-chart .main-grid { height: 100vh !important; margin: 0 !important; }
        body.fullscreen-chart .center-panel { flex-grow: 1 !important; height: 100vh !important; border-radius: 0 !important; margin: 0 !important; }
        body.fullscreen-chart .data-container { height: 100% !important; }
        body.fullscreen-chart #chart-container-view,
        body.fullscreen-chart #live-chart { height: 100% !important; flex-grow: 1 !important; }
        body.fullscreen-chart .heatmap-container { display: none !important; }
        body.fullscreen-chart .chart-zoom-controls { background: rgba(0,0,0,0.7); }
        body.fullscreen-chart #exit-fullscreen-btn { display: block !important; }
        body.fullscreen-chart #chart-countdown-overlay { display: block !important; }

        [data-theme="light"] { --background: var(--background-light); --panel-bg: var(--panel-bg-light); --text-main: var(--text-main-light); --text-secondary: var(--text-secondary-light); --border-color: var(--border-color-light); --input-bg: var(--input-bg-light); --hover-bg: var(--hover-bg-light); --primary: var(--primary-light); }
        [data-theme="dark"] { --background: var(--background-dark); --panel-bg: var(--panel-bg-dark); --text-main: var(--text-main-dark); --text-secondary: var(--text-secondary-dark); --border-color: var(--border-color-dark); --input-bg: var(--input-bg-dark); --hover-bg: var(--hover-bg-dark); --primary: var(--primary-dark); }
        [data-theme="war"] { --background: var(--war-mode-bg); --panel-bg: var(--war-mode-panel-bg); --text-main: var(--war-mode-text); --text-secondary: #ffaaaa; --border-color: var(--war-mode-border); --input-bg: rgba(255, 255, 255, 0.05); --hover-bg: rgba(255, 255, 255, 0.1); --primary: var(--war-mode-primary); }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Roboto Mono', monospace; font-size: 12px; background: var(--background); color: var(--text-main); overflow: hidden; transition: background 0.5s, color 0.5s; }
        
        #super-top-ticker { display: flex; position: fixed; top: 0; left: 0; width: 100%; background: var(--panel-bg); border-bottom: 1px solid var(--border-color); padding: 2px 10px; z-index: 1100; align-items: center; justify-content: space-between; font-size: 11px; font-weight: 700; height: var(--ticker-height); }
        .super-top-left { display: flex; align-items: center; gap: 10px; flex-shrink: 0;}
        #ticker-bar-symbol { color: var(--primary); }
        #ticker-bar-price { color: var(--text-main); font-size: 12px; }
        .super-top-right-buttons { display: flex; gap: 5px; }

        .container { display: flex; flex-direction: column; height: 100vh; padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); }

        .header { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; flex-shrink: 0; box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 5px; position: relative; }
        .header-top-bar { display: flex; align-items: center; width: 100%; padding: 5px 15px; min-height: var(--header-min-height); justify-content: space-between; cursor: pointer; font-weight: 700; font-size: 16px; color: var(--primary); }
        .header-collapsible-content { transition: max-height 0.35s ease-in-out, opacity 0.3s ease, padding 0.35s ease, visibility 0.35s; max-height: 300px; opacity: 1; overflow: hidden; visibility: visible; padding: 0 15px 8px 15px; }
        body.header-collapsed .header-collapsible-content { max-height: 0; opacity: 0; visibility: hidden; padding-top: 0; padding-bottom: 0; }

        .main-controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; padding-bottom: 8px; }
        .form-control { background: var(--input-bg); color: var(--text-main); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-family: 'Roboto Mono', monospace; }
        
        .status { display: flex; align-items: center; gap: 5px; font-size: 11px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--negative); transition: background-color 0.5s; }
        .status-dot.online { background: var(--positive); animation: pulse 2s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 #28a745b3; } 70% { box-shadow: 0 0 0 6px #28a74500; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        [data-theme="war"] .status-dot.online { background: var(--war-mode-primary); animation: war-pulse 1s infinite; }
        @keyframes war-pulse { 0% { box-shadow: 0 0 0 0 #ffc107b3; } 70% { box-shadow: 0 0 0 6px #ffc10700; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        .btn { padding: 4px 12px; border: 1px solid var(--border-color); background: var(--panel-bg); color: var(--text-main); border-radius: 4px; cursor: pointer; transition: all 0.2s; }
        .btn:hover { background: var(--hover-bg); border-color: var(--primary); }
        .btn-success { background: var(--positive); color: white; border-color: var(--positive); } .btn-danger { background: var(--negative); color: white; border-color: var(--negative); }
        .btn-tiny { padding: 2px 6px; font-size: 10px; line-height: 1; min-width: 0; white-space: nowrap; }
        
        .main-grid { display: grid; grid-template-columns: 1fr; gap: 5px; flex-grow: 1; margin: 5px; overflow: hidden; height: calc(100% - var(--header-min-height) - 10px - var(--ticker-height) - var(--signal-bar-height)); }
        body.header-collapsed .main-grid { height: calc(100vh - var(--ticker-height) - var(--signal-bar-height) - 10px); margin-top: 0; } 
        
        .panel { display: flex; flex-direction: column; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; overflow: hidden; position: relative;}
        .panel-title { font-weight: 700; font-size: 13px; color: var(--primary); padding: 8px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; display: flex; justify-content: space-between; align-items: center;}
        .panel-content { padding: 10px; overflow-y: auto; flex-grow: 1; }
        .settings-group { margin-bottom: 15px; } .form-group { margin-bottom: 8px; } .form-label { display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px; }
        .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 12px; padding: 4px 0;}
        
        .price-display { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; width: 100%; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; font-size: 10px; margin-top: 8px; } 
        .price-item .price-label { color: var(--text-secondary); } 
        .price-item .price-value { font-size: 18px; font-weight: 700; }
        .price-item.countdown { grid-column: 1 / span 2; display: flex; justify-content: center; align-items: center; font-size: 14px; font-weight: 700; color: var(--primary); padding-top: 5px;}
        
        .center-panel { display: grid; grid-template-rows: 1fr; gap: 5px; padding: 0 !important; } 
        .data-container { display: grid; grid-template-rows: 1fr auto; overflow: hidden; height: 100%; } 
        .data-grid { position: relative; overflow: hidden; min-height: 0; } 

        #live-chart { width: 100%; height: 100%; } 
        .heatmap-container { display: grid; grid-template-rows: auto 1fr; border-top: 1px solid var(--border-color); }
        #orderbook-heatmap { width: 100%; height: 100%; display: block; }

        .chart-zoom-controls { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; z-index: 100; }
        .chart-zoom-controls .btn-tiny { background: rgba(1, 4, 9, 0.7); backdrop-filter: blur(2px); }

        #exit-fullscreen-btn {
            position: absolute; top: 10px; right: 10px; z-index: 101; 
            background: rgba(1, 4, 9, 0.7); color: white; border-radius: 4px; 
            padding: 2px 6px; font-size: 16px; cursor: pointer; border: 1px solid var(--border-color);
            line-height: 1;
        }
        #chart-countdown-overlay {
            position: absolute; top: 10px; left: 10px; z-index: 100; 
            background: rgba(1, 4, 9, 0.7); padding: 4px 8px; border-radius: 4px; 
            color: var(--primary); font-size: 14px; font-weight: bold;
        }

        .data-table-container { width: 100%; height: 100%; overflow: auto; }
        .data-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .data-table th, .data-table td { padding: 6px 8px; text-align: left; border-bottom: 1px solid var(--border-color); white-space: nowrap;}
        .data-table th { font-weight: 700; position: sticky; top: 0; background: var(--panel-bg); z-index: 10;}
        .data-table tr:hover { background: var(--hover-bg); }
        .signal-buy { background-color: #28a74514; } .signal-sell { background-color: #dc354514; }
        .signal-tp { background-color: #28a74533; } .signal-sl { background-color: #dc354533; }
        .stat-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border-color); font-size: 12px; }
        .stat-item:last-child { border-bottom: none; } .stat-label { color: var(--text-secondary); } .stat-value { font-weight: 700; }
        .btn-sm { padding: 1px 4px; font-size: 9px; margin-left: 4px; border-radius: 3px; cursor: pointer;}
        ::-webkit-scrollbar { width: 6px; height: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: var(--text-secondary); border-radius: 3px; }
        .notifications { position: fixed; bottom: 15px; right: 15px; z-index: 2000; width: 320px; }
        .notification { background: var(--panel-bg); border: 1px solid var(--border-color); border-left-width: 5px; border-radius: 4px; padding: 12px; font-size: 13px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); margin-top: 10px; }
        .notification.success { border-left-color: var(--positive); } .notification.danger { border-left-color: var(--negative); } .notification.warning { border-left-color: var(--neutral); }
        
        aside#settings-panel, aside#analytics-panel { display: none !important; }
        .hidden-view { display: none !important; } 

        #settings-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 2500; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        #settings-modal-overlay.visible { opacity: 1; visibility: visible; }
        .settings-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 90%; max-width: 860px; max-height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); transform: translateY(20px); transition: transform 0.3s ease; }
        #settings-modal-overlay.visible .settings-modal-content { transform: translateY(0); }
        .settings-modal-header { padding: 12px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 15px; color: var(--primary); }
        .settings-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
        .settings-modal-header .close-btn:hover { color: var(--negative); }
        .settings-modal-body { padding: 15px; overflow-y: auto; flex-grow: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .settings-modal-footer { padding: 12px 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 10px; }

        /* Yeni Sinyal Barı */
        #signal-progress-bar-container {
            display: flex; gap: 5px; width: 100%; padding: 5px 10px; background: var(--panel-bg); 
            border-bottom: 1px solid var(--border-color); justify-content: space-around; align-items: center;
            position: fixed; top: var(--ticker-height); left: 0; z-index: 1099;
            height: var(--signal-bar-height);
        }
        .signal-bar-wrapper { flex: 1; text-align: center; }
        .signal-bar-label { font-size: 10px; color: var(--text-secondary); margin-bottom: 3px; }
        .signal-bar { width: 100%; height: 10px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 5px; overflow: hidden; position: relative; }
        .signal-bar-fill { height: 100%; width: 0%; transition: width 0.2s ease-out; position: absolute; left: 0; top: 0; background: linear-gradient(90deg, transparent, var(--positive)); }
        .signal-bar-fill.buy { background: linear-gradient(90deg, transparent, var(--positive)); }
        .signal-bar-fill.sell { background: linear-gradient(90deg, transparent, var(--negative)); }
        .signal-score-text { font-size: 9px; margin-top: 2px; color: var(--primary); }

        /* Resizable Handle */
        .resize-handle { position: absolute; bottom: 0; left: 0; width: 100%; height: 8px; cursor: ns-resize; background: var(--border-color); z-index: 10; border-top: 1px solid var(--border-color); }
        .center-panel.resizing { user-select: none; }

        @media screen and (max-width: 768px) {
            .container { padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); }
            #signal-progress-bar-container { top: var(--ticker-height); }
            .header { order: 2; position: sticky; bottom: 0; top: auto; width: 100%; z-index: 1000; margin: 0; border-radius: 0; border: none; border-top: 1px solid var(--border-color); }
            .header-top-bar { flex-direction: column; align-items: center; gap: 10px; padding: 10px 15px; }
            .header-collapsible-content { padding: 0; }
            .header-collapsible-content .main-controls { flex-direction: column; align-items: center; padding: 0; width: 100%; }
            .form-control, .btn, .status { width: 100%; text-align: center; padding: 8px 10px; font-size: 11px; }
            .status { justify-content: center; }
            .price-display { grid-template-columns: repeat(2, 1fr); margin-top: 10px; }
            .price-item .price-value { font-size: 14px; } 
            .main-grid { order: 1; flex-direction: column; margin: 5px; overflow: visible; padding-bottom: 5px; height: auto; }
            .center-panel { order: 1; flex-grow: 0; height: auto; border: 1px solid var(--border-color); border-radius: 6px; background: var(--panel-bg); box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 0; }
            .center-panel > .panel-title { display: none; }
            .data-container { flex-direction: column; height: auto; padding: 10px; }
            .data-grid { height: 50vh; flex-shrink: 0; }
            #live-chart { height: 100%; width: 100%; } 
            .heatmap-container { height: 150px; flex-shrink: 0; margin-top: 10px; border-top: 1px solid var(--border-color); padding-top: 10px; }
            .heatmap-container .panel-title { border-bottom: none; margin-bottom: 5px; }
            .settings-modal-content { width: 95%; margin: 10px; }
            .settings-modal-body { grid-template-columns: 1fr; gap: 15px; }
            .super-top-right-buttons { display: none; }
            .resize-handle { display: none; }
            #chart-countdown-overlay { font-size: 12px; padding: 3px 6px; }
        }
    </style>
</head>
<body class="header-collapsed"> 
    <div id="super-top-ticker">
        <div class="super-top-left">
            <span id="ticker-bar-symbol"></span>
            <span id="ticker-bar-price"></span>
        </div>
        <div class="super-top-right-buttons">
            <button id="main-controls-btn" class="btn btn-tiny">Komuta Merkezi</button>
            <button id="chart-view-btn" class="btn btn-tiny">Grafik</button>
            <button id="heatmap-view-btn" class="btn btn-tiny">Isı Haritası</button>
            <button id="fullscreen-chart-btn" class="btn btn-tiny">Tam Ekran Grafik</button>
            <button id="honor-board-btn" class="btn btn-tiny">Şeref Tablosu</button>
            <button id="banned-board-btn" class="btn btn-tiny">Banlılar</button>
            <button id="open-settings-modal-btn" class="btn btn-tiny">Ayarlar</button>
        </div>
    </div>

    <!-- Yeni Sinyal Barı -->
    <div id="signal-progress-bar-container">
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">BUY SINYAL GÜCÜ</div>
            <div class="signal-bar">
                <div id="buy-signal-bar-fill" class="signal-bar-fill buy"></div>
            </div>
            <div id="buy-signal-score-text" class="signal-score-text">0.0</div>
        </div>
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">SELL SINYAL GÜCÜ</div>
            <div class="signal-bar">
                <div id="sell-signal-bar-fill" class="signal-bar-fill sell"></div>
            </div>
            <div id="sell-signal-score-text" class="signal-score-text">0.0</div>
        </div>
    </div>

    <div class="container">
        <header class="header">
            <div id="header-main-bar" class="header-top-bar" title="Paneli aç/kapatmak için çift tıkla">
                <span>KOMUTA MERKEZİ KONTROLLERİ</span>
            </div>
            <div class="header-collapsible-content">
                <div class="main-controls">
                    <input type="text" id="symbol-input" class="form-control" placeholder="Örn: BTC, ETH, SOL">
                    <select id="timeframe-select" class="form-control">
                        <option value="1m">1m</option><option value="5m">5m</option><option value="15m" selected>15m</option><option value="1h">1h</option><option value="4h">4h</option>
                    </select>
                    <div class="status">
                        <div id="connection-status" class="status-dot"></div>
                        <span id="connection-text">BAĞLANTI YOK</span>
                    </div>
                    <button id="theme-toggle-btn" class="btn">Tema</button>
                    <button id="start-btn" class="btn btn-success">SİSTEMİ BAŞLAT</button>
                    <button id="stop-btn" class="btn btn-danger" disabled>DURDUR</button>
                    <button id="clear-markers-btn" class="btn">Grafik Sinyallerini Sil</button> 
                </div>
                <div class="price-display">
                    <div class="price-item"><div class="price-label">FİYAT</div><div class="price-value" id="current-price">-</div></div>
                    <div class="price-item"><div class="price-label">24s DEĞİŞİM</div><div class="price-value" id="price-change-24h">-</div></div>
                    <div class="price-item"><div class="price-label">24s HACİM</div><div class="price-value" id="volume-24h">-</div></div>
                    <div class="price-item"><div class="price-label">VOLATİLİTE (ATR)</div><div class="price-value" id="atr-value">-</div></div>
                    <div class="price-item countdown"><span id="candle-countdown">--:--</span></div>
                </div>
            </div>
        </header>

        <main class="main-grid">
            <section class="center-panel panel">
                <div class="data-container">
                    <div class="data-grid" id="chart-container-view">
                        <div id="live-chart"></div>
                        <div class="chart-zoom-controls"> 
                            <button id="chart-zoom-in" class="btn btn-tiny">+</button>
                            <button id="chart-zoom-out" class="btn btn-tiny">-</button>
                            <button id="chart-zoom-reset" class="btn btn-tiny">Sıfırla</button>
                        </div>
                        <button id="exit-fullscreen-btn" class="btn btn-tiny hidden-view" title="Tam Ekrandan Çık">&times;</button>
                        <div id="chart-countdown-overlay" class="hidden-view">--:--</div>
                    </div>
                    <div class="heatmap-container" id="heatmap-container-view">
                        <div class="panel-title" style="border-top: 1px solid var(--border-color); border-bottom: none;">EMİR DEFTERİ ISI HARİTASI</div>
                        <canvas id="orderbook-heatmap"></canvas>
                    </div>
                </div>
                <div class="resize-handle"></div>
            </section>
        </main>
    </div>
    
    <div id="notifications-container" class="notifications"></div>

    <!-- AYARLAR MODAL -->
    <div id="settings-modal-overlay">
        <div class="settings-modal-content">
            <div class="settings-modal-header">
                <span>AYARLAR & OPTİMİZASYON</span>
                <button class="close-btn" id="close-settings-modal-btn">&times;</button>
            </div>
            <div class="settings-modal-body">
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Temel Parametreler</div>
                    <div class="form-group"><label class="form-label">Min. Uyum Skoru (1-10)</label><input type="range" id="modal-confluence-threshold" class="form-control" min="1" max="10" value="3" step="1"></div>
                    <div class="form-group"><label class="form-label">RSI Periyodu</label><input type="number" id="modal-param-rsi-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">ATR Periyodu</label><input type="number" id="modal-param-atr-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">Duvar Tespiti (BTC Miktarı)</label><input type="number" id="modal-param-wall-btc" class="form-control" value="20"></div>
                    <div class="form-group"><label class="form-label">Risk/Ödül Oranı (R/R)</label><input type="number" id="modal-param-rr-ratio" class="form-control" value="1.5" step="0.1"></div>
                </div>
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Cooldown Ayarları</div>
                    <div class="form-group"><label class="form-label">Genel Sinyal Cooldown (ms)</label><input type="number" id="modal-signal-cooldown-ms" class="form-control" value="15000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Aynı Yön Sinyal Cooldown (ms)</label><input type="number" id="modal-same-direction-cooldown-ms" class="form-control" value="30000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Yön Cooldown (ms)</label><input type="number" id="modal-opposite-direction-cooldown-ms" class="form-control" value="20000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Yön Histerezis (+Puan)</label><input type="number" id="modal-reverse-hysteresis-points" class="form-control" value="2" min="0" step="1"></div>
                    <div class="form-group"><label class="form-label">Proposal Timeout (ms)</label><input type="number" id="modal-proposal-timeout-ms" class="form-control" value="3000" min="500" step="100"></div>
                    <div class="form-group"><label class="form-label">Strateji Teklifi Cooldown (ms)</label><input type="number" id="modal-strategy-proposal-cooldown-ms" class="form-control" value="10000" min="0" step="100"></div>
                </div>
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Gelişmiş Özellikler</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-spoof-detection" class="feature-toggle" checked> Spoof Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-cusum-drift" class="feature-toggle" checked> CUSUM Sapma Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-risk-guardian" class="feature-toggle" checked> Risk Koruyucu (Kill Switch)</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-optimize" class="feature-toggle" checked> Oto-Optimizasyon</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-toggle-strat" class="feature-toggle" checked> Stratejileri Oto-Ayarla</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-breakeven-trail" class="feature-toggle" checked> Maliyete Çek/Takip Eden SL</label></div>
                    <div class="form-group"><label class="form-label">BE R Oranı</label><input type="number" id="modal-be-at-r" class="form-control" value="0.8" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing Başlangıç R Oranı</label><input type="number" id="modal-trail-after-r" class="form-control" value="1.5" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing Kârı R Oranı</label><input type="number" id="modal-trail-to-r" class="form-control" value="0.5" step="0.1"></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-tts" class="feature-toggle" checked> Sesli Bildirimler</label></div>
                    <div class="form-group">
                        <label class="form-label">Ses Seçimi</label>
                        <select id="modal-tts-voice-select" class="form-control"></select>
                    </div>
                </div>
                 <!-- YENİ AYARLAR GRUBU -->
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Sinyal Teyit & Filtreleme</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-candle-confirm" checked> Sinyal için Mum Kapanışını Bekle</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-mtf-confirm" checked> Üst Zaman Dilimi Trend Teyidi</label></div>
                     <div class="form-group">
                        <label class="form-label">MTF Zaman Dilimi</label>
                        <select id="modal-mtf-timeframe-select" class="form-control">
                            <option value="15m">15m</option>
                            <option value="1h" selected>1h</option>
                            <option value="4h">4h</option>
                        </select>
                    </div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-dynamic-sizing" checked> Dinamik Pozisyon Boyutlandırma</label></div>
                </div>
                <div class="settings-group" style="grid-column: 1 / -1;">
                    <div class="panel-title" style="margin-bottom: 10px;">Aktif Stratejiler</div>
                    <div id="modal-strategy-toggles" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 5px;"></div>
                </div>
                <div class="settings-group" style="grid-column: 1 / -1;">
                    <div class="panel-title" style="margin-bottom: 10px;">Sinyal Geçmişi ve Analiz</div>
                    <div class="data-table-container" style="max-height: 300px;">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Zaman</th><th>Tip</th><th>Fiyat</th><th>TP</th><th>SL</th><th>Skor</th><th>Boyut</th><th>Katkı</th><th>Durum</th><th>Not</th>
                                </tr>
                            </thead>
                            <tbody id="modal-signals-body"></tbody>
                        </table>
                    </div>
                    <button id="modal-clear-signals-btn" class="btn btn-danger btn-sm" style="margin-top: 10px;">Tüm Sinyalleri Sil</button>
                    <div id="modal-stats-container" style="margin-top: 15px;"></div>
                </div>
            </div>
            <div class="settings-modal-footer">
                <button id="reset-all-settings-btn" class="btn btn-danger">AYARLARI SIFIRLA</button>
                <button id="save-settings-btn" class="btn btn-success">AYARLARI KAYDET</button>
            </div>
        </div>
    </div>

    <!-- ŞEREF TABLOSU MODAL -->
    <div id="honor-modal-overlay" style="position:fixed; inset:0; background:rgba(0,0,0,0.7); display:none; z-index:2600; align-items:center; justify-content:center;">
      <div style="background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; width:90%; max-width:900px; max-height:90%; overflow:auto;">
        <div style="padding:10px; border-bottom:1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700; color:var(--primary)">Şeref Tablosu</div>
          <button id="close-honor-modal" class="btn btn-tiny">Kapat</button>
        </div>
        <div id="honor-modal-body" style="padding:12px;"></div>
      </div>
    </div>

<script>
    // Sinyal sesleri
    function playSignal(type) {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            if (type === 'buy') {
                oscillator.type = 'triangle'; oscillator.frequency.value = 1000;
            } else if (type === 'sell') {
                oscillator.type = 'square'; oscillator.frequency.value = 400;
            } else if (type === 'combat') {
                oscillator.type = 'sawtooth'; oscillator.frequency.value = 800; 
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);
                oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 1);
                return;
            }
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5);
        } catch (error) { console.log('Ses çalınamadı:', error); }
    }

    /* =========================
       GÖRSELLEŞTİRME YÖNETİCİLERİ
       ========================= */
    class ChartManager {
        constructor(chartContainerId) {
            this.chartContainer = document.getElementById(chartContainerId);
            if (!this.chartContainer) throw new Error("Chart container bulunamadı!");
            this.chart = null; this.series = {}; this.signalMarkers = [];
            this._initChart();
        }
        _initChart() {
            this.chart = LightweightCharts.createChart(this.chartContainer, this._getChartOptions());
            this.series.candles = this.chart.addCandlestickSeries(this._getCandlestickOptions());
            this.series.volume = this.chart.addHistogramSeries(this._getVolumeOptions());
            window.addEventListener('resize', () => { 
                if (this.chart && this.chartContainer.clientWidth > 0 && this.chartContainer.clientHeight > 0) {
                    this.chart.resize(this.chartContainer.clientWidth, this.chartContainer.clientHeight);
                }
            });
        }
        updateTheme() {
            if(!this.chart) return;
            this.chart.applyOptions(this._getChartOptions());
            this.series.candles.applyOptions(this._getCandlestickOptions());
            this.series.volume.applyOptions(this._getVolumeOptions());
        }
        setData(candles) {
            if (!this.series.candles) return;
            const candleData = candles.map(c => ({ time: c.time / 1000, open: c.open, high: c.high, low: c.low, close: c.close }));
            const volumeData = candles.map(c => ({ time: c.time / 1000, value: c.volume, color: c.close >= c.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' }));
            this.series.candles.setData(candleData);
            this.series.volume.setData(volumeData);
            if(candleData.length > 0) this.chart.timeScale().fitContent();
        }
        updateRealtime(kline) {
             if (!this.series.candles) return;
             const candle = { time: kline.t / 1000, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c) };
             const volume = { time: kline.t / 1000, value: parseFloat(kline.v), color: candle.close >= candle.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' };
             this.series.candles.update(candle);
             this.series.volume.update(volume);
        }
        addSignalMarker(signal) {
            if (!this.series.candles) return;
            const styles = getComputedStyle(document.body);
            let text = `Skor: ${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score}`;
            if(signal.recommendedSize) text += ` | ${signal.recommendedSize}`;
            const marker = {
                time: signal.timestamp / 1000,
                position: signal.direction === 'buy' ? 'belowBar' : 'aboveBar',
                color: signal.direction === 'buy' ? styles.getPropertyValue('--positive').trim() : styles.getPropertyValue('--negative').trim(),
                shape: signal.direction === 'buy' ? 'arrowUp' : 'arrowDown',
                text: text
            };
            this.signalMarkers.push(marker);
            this.series.candles.setMarkers(this.signalMarkers);
        }
        clearMarkers() { if (!this.series.candles) return; this.signalMarkers = []; this.series.candles.setMarkers([]); }
        zoom(factor) {
            if (!this.chart) return;
            const timeScale = this.chart.timeScale();
            const currentLogicalRange = timeScale.getVisibleLogicalRange();
            if (!currentLogicalRange) return;
            const newLogicalRange = { from: currentLogicalRange.from * factor, to: currentLogicalRange.to * factor };
            timeScale.setVisibleLogicalRange(newLogicalRange);
        }
        zoomIn() { this.zoom(0.9); }
        zoomOut() { this.zoom(1.1); }
        resetZoom() { if (this.chart) this.chart.timeScale().fitContent(); }

        _getDecimalPlacesBasedOnPrice(price) { if(!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _formatMarkerPrice(price) { const d = this._getDecimalPlacesBasedOnPrice(price); return price.toFixed(d); }
        _getChartOptions() {
            const styles = getComputedStyle(document.body);
            return {
                width: this.chartContainer.clientWidth, height: this.chartContainer.clientHeight,
                layout: { backgroundColor: 'transparent', textColor: styles.getPropertyValue('--text-main').trim(), fontFamily: "'Roboto Mono', monospace" },
                grid: { vertLines: { color: styles.getPropertyValue('--border-color').trim() }, horzLines: { color: styles.getPropertyValue('--border-color').trim() } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { borderColor: styles.getPropertyValue('--border-color').trim(), timeVisible: true, secondsVisible: false, rightOffset: 10 }
            };
        }
        _getCandlestickOptions() {
             const styles = getComputedStyle(document.body);
             return { 
                upColor: styles.getPropertyValue('--positive').trim(), downColor: styles.getPropertyValue('--negative').trim(),
                borderVisible: false, wickUpColor: styles.getPropertyValue('--positive').trim(), wickDownColor: styles.getPropertyValue('--negative').trim(),
                priceFormat: { type: 'price', precision: 6, minMove: 0.000001 }
             };
        }
        _getVolumeOptions() { return { priceFormat: { type: 'volume' }, priceScaleId: '', scaleMargins: { top: 0.8, bottom: 0 } }; }
    }

    class HeatmapManager {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            if (!this.canvas) throw new Error("Heatmap canvas bulunamadı!");
            this.ctx = this.canvas.getContext('2d');
            this._resizeCanvas();
            window.addEventListener('resize', () => this._resizeCanvas());
        }
        draw(orderBook, symbolPrice) {
            if (!orderBook.bids || !Array.isArray(orderBook.bids) || orderBook.bids.length === 0 || !orderBook.asks || !Array.isArray(orderBook.asks) || orderBook.asks.length === 0) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                return;
            }
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            const asks = orderBook.asks.slice().reverse(); const bids = orderBook.bids;
            const allLevels = [...bids, ...asks]; const maxQty = Math.max(...allLevels.map(l => l[1]));
            this._drawSection(asks, 'asks', maxQty, symbolPrice); this._drawSection(bids, 'bids', maxQty, symbolPrice);
        }
        updateTheme() { this._resizeCanvas(); }
        _drawSection(levels, type, maxQty, symbolPrice) {
            const styles = getComputedStyle(document.body);
            const baseColor = type === 'asks' ? styles.getPropertyValue('--negative').trim() : styles.getPropertyValue('--positive').trim();
            if (levels.length === 0) return;
            const heightPerLevel = (this.canvas.height / 2) / levels.length;
            const priceDecimals = this._getDecimalPlaces(symbolPrice);
            const labelSkipInterval = heightPerLevel < 12 ? Math.ceil(12 / heightPerLevel) : 1;
            levels.forEach((level, index) => {
                const [price, qty] = level;
                const intensity = Math.min(Math.sqrt(qty / maxQty), 1.0);
                this.ctx.fillStyle = this._hexToRgba(baseColor, intensity * 0.6 + 0.1);
                const y = type === 'asks' ? index * heightPerLevel : (this.canvas.height / 2) + (index * heightPerLevel);
                const barWidth = this.canvas.width * intensity;
                this.ctx.fillRect(0, y, barWidth, heightPerLevel);
                if (index % labelSkipInterval === 0) {
                    this.ctx.fillStyle = intensity > 0.5 ? '#FFFFFF' : styles.getPropertyValue('--text-secondary').trim();
                    this.ctx.font = '10px "Roboto Mono"'; this.ctx.textAlign = 'left';
                    this.ctx.fillText(`${(qty).toFixed(2)} @ ${price.toFixed(priceDecimals)}`, 10, y + heightPerLevel - 3);
                }
            });
        }
        _getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _hexToRgba(hex, alpha) {
            if(!hex.startsWith('#')) return `rgba(120,120,120,${alpha})`;
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        _resizeCanvas() { 
            if(this.canvas.parentElement) {
                this.canvas.width = this.canvas.parentElement.clientWidth; 
                this.canvas.height = this.canvas.parentElement.clientHeight; 
            }
        }
    }

    /* =========================
       GELİŞMİŞ ÖZELLİK YÖNETİCİLERİ
       ========================= */

    class MultiTimeframeManager {
        constructor(bot) {
            this.bot = bot;
            this.higherTimeframe = '1h';
            this.candles = [];
            this.indicators = { ema20: null };
            this.socket = null;
            this.isReady = false;
        }

        async initialize(symbol, higherTimeframe) {
            this.cleanup();
            this.higherTimeframe = higherTimeframe;
            this.isReady = false;
            this.bot.logToJournal(`MTF Yöneticisi [${this.higherTimeframe}] için başlatılıyor...`);
            await this.fetchHistoricalData(symbol);
            this.connectWebSocketStream(symbol);
        }

        async fetchHistoricalData(symbol) {
            try {
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${this.higherTimeframe}&limit=100`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`MTF API Hatası: ${response.statusText}`);
                const data = await response.json();
                this.candles = data.map(d => ({ time: d[0], open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]) }));
                this.calculateIndicators();
                this.isReady = true;
                this.bot.logToJournal(`MTF için ${this.candles.length} adet [${this.higherTimeframe}] mumu yüklendi.`);
            } catch (error) {
                this.bot.showNotification(`MTF verisi alınamadı: ${error.message}`, 'danger');
            }
        }

        connectWebSocketStream(symbol) {
            const streamName = `${symbol.toLowerCase()}@kline_${this.higherTimeframe}`;
            this.socket = new WebSocket(`wss://fstream.binance.com/stream?streams=${streamName}`);

            this.socket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                if (message.data && message.data.k) {
                    this.handleKlineData(message.data.k);
                }
            };
            this.socket.onclose = () => {
                if (this.bot.isRunning) {
                    this.bot.logToJournal(`MTF [${this.higherTimeframe}] bağlantısı kapandı, yeniden deneniyor...`);
                    setTimeout(() => this.connectWebSocketStream(symbol), 5000);
                }
            };
        }
        
        handleKlineData(kline) {
            const newCandle = { time: kline.t, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c), volume: parseFloat(kline.v) };
            const lastCandle = this.candles[this.candles.length - 1];

            if (lastCandle && lastCandle.time === kline.t) {
                this.candles[this.candles.length - 1] = newCandle;
            } else if (kline.x) { // Sadece kapanmış yeni mumu ekle
                this.candles.push(newCandle);
                if (this.candles.length > 100) this.candles.shift();
            }
             this.calculateIndicators();
        }
        
        calculateIndicators() {
            if (this.candles.length < 20) return;
            const closes = this.candles.map(c => c.close);
            this.indicators.ema20 = this.calculateEMA(closes, 20);
        }

        calculateEMA(data, period) {
            const k = 2 / (period + 1);
            let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < data.length; i++) {
                ema = (data[i] * k) + (ema * (1 - k));
            }
            return ema;
        }

        getTrendDirection() {
            if (!this.isReady || !this.indicators.ema20) return 'neutral';
            const price = this.bot.marketData.price;
            if (price > this.indicators.ema20) return 'up';
            if (price < this.indicators.ema20) return 'down';
            return 'neutral';
        }

        cleanup() {
            if (this.socket) {
                this.socket.onclose = null;
                this.socket.close();
                this.socket = null;
            }
            this.candles = [];
            this.isReady = false;
        }
    }

    // Sahte Emir Tespiti (Spoof Detector)
    class SpoofDetector {
        constructor(bot) {
            this.bot = bot;
            this.largeOrderThreshold = 10;
            this.recentOrders = [];
            this.CHECK_WINDOW_MS = 5000;
        }
        trackOrderBook(orderBook) {
            const now = Date.now();
            this.recentOrders = this.recentOrders.filter(o => now - o.timestamp < this.CHECK_WINDOW_MS);
            orderBook.bids.forEach(([price, qty]) => {
                const usdValue = qty * price;
                if (this.bot.currentSymbol === 'BTCUSDT' && qty > this.largeOrderThreshold) {
                    this.recentOrders.push({ type: 'bid', price, qty, timestamp: now });
                } else if (this.bot.currentSymbol !== 'BTCUSDT' && usdValue / (this.bot.marketData.btcPrice || 70000) > this.largeOrderThreshold) {
                    this.recentOrders.push({ type: 'bid', price, qty, timestamp: now });
                }
            });
            orderBook.asks.forEach(([price, qty]) => {
                const usdValue = qty * price;
                 if (this.bot.currentSymbol === 'BTCUSDT' && qty > this.largeOrderThreshold) {
                    this.recentOrders.push({ type: 'ask', price, qty, timestamp: now });
                } else if (this.bot.currentSymbol !== 'BTCUSDT' && usdValue / (this.bot.marketData.btcPrice || 70000) > this.largeOrderThreshold) {
                    this.recentOrders.push({ type: 'ask', price, qty, timestamp: now });
                }
            });
            this._detectSpoofing();
        }
        _detectSpoofing() {
            const now = Date.now();
            const minTimeDiff = 1000;
            this.recentOrders.forEach(order => {
                if (now - order.timestamp > minTimeDiff) {
                    const exists = (order.type === 'bid' ? this.bot.orderBook.bids : this.bot.orderBook.asks)
                        .some(([p, q]) => p === order.price && q === order.qty);
                    if (!exists) {
                        this.bot.showNotification(`Sahte Emir Tespiti: ${order.type.toUpperCase()} ${order.qty.toFixed(2)} @ ${order.price.toFixed(this.bot.getDecimalPlaces(order.price))} aniden kayboldu!`, 'warning');
                    }
                }
            });
            this.recentOrders = this.recentOrders.filter(o => now - o.timestamp < this.CHECK_WINDOW_MS);
        }
    }

    // CUSUM Sapma Tespiti (CUSUM Drift Detector)
    class CUSUMDriftDetector {
        constructor() {
            this.K = 0.5;
            this.H = 3;
            this.Cp = 0;
            this.Cn = 0;
            this.dataPoints = 0; 
        }
        update(isWin) {
            this.dataPoints++;
            const Xn = isWin ? 1 : 0;
            this.Cp = Math.max(0, this.Cp + (Xn - this.K));
            this.Cn = Math.max(0, this.Cn + ((1 - Xn) - this.K));
            let driftDetected = false;
            if (this.Cp > this.H) { driftDetected = false; this.reset(); } // If positive CUSUM exceeds threshold, reset it. No specific action for win-drift here.
            if (this.Cn > this.H) { driftDetected = true; this.reset(); } // If negative CUSUM exceeds threshold, signal drift.
            return driftDetected;
        }
        reset() { this.Cp = 0; this.Cn = 0; this.dataPoints = 0; }
    }

    // Piyasa Seans Profilleri (Session Profiler)
    class SessionProfiler {
        constructor() {
            this.sessions = {
                'asia': { start: 0, end: 8, name: 'Asya' },
                'europe': { start: 8, end: 13, name: 'Avrupa' },
                'america': { start: 13, end: 22, name: 'Amerika' },
                'overlap': { start: 13, end: 16, name: 'Avr-Ame Çakışması' },
                'transition': { start: 22, end: 24, name: 'Geçiş' }
            };
        }
        getCurrentSession() {
            const now = new Date();
            const utcHour = now.getUTCHours();
            if (utcHour >= this.sessions.overlap.start && utcHour < this.sessions.overlap.end) return this.sessions.overlap.name;
            else if (utcHour >= this.sessions.america.start && utcHour < this.sessions.america.end) return this.sessions.america.name;
            else if (utcHour >= this.sessions.europe.start && utcHour < this.sessions.europe.end) return this.sessions.europe.name;
            else if (utcHour >= this.sessions.asia.start && utcHour < this.sessions.asia.end) return this.sessions.asia.name;
            else return this.sessions.transition.name;
        }
    }

    // Risk Koruyucu (Risk Guardian - Kill Switch)
    class RiskGuardian {
        constructor(bot) {
            this.bot = bot;
            this.killSwitchActivated = false;
        }
        checkKillSwitch() {
            if (!this.bot.settings.features.enableRiskGuardian) {
                this.killSwitchActivated = false; return;
            }
            const totalSignals = this.bot.stats.total;
            const tpSignals = this.bot.stats.tp;
            const slSignals = this.bot.stats.sl;
            const winRate = totalSignals > 0 ? (tpSignals / totalSignals) * 100 : 0;
            const drawdownWinRateThreshold = this.bot.settings.riskGuardian.killSwitchWinRate;
            if (totalSignals >= 5 && winRate < drawdownWinRateThreshold && !this.killSwitchActivated) {
                this.killSwitchActivated = true;
                this.bot.showNotification(`!!! ACİL DURDURMA !!! Kazanma oranı ${winRate.toFixed(1)}% (${drawdownWinRateThreshold}% altı). Sistem durduruldu.`, 'danger');
                this.bot.speak(`Uyarı! Acil durdurma Protokolü aktif edildi. Kazanma oranı eşiğin altında. Sistemi acilen kontrol edin.`);
                this.bot.stop();
                return true;
            }
            return false;
        }
    }

    /* =========================
       STRATEJİLER
       ========================= */
    class Strategy {
        constructor(bot, name) { 
            this.bot = bot; this.name = name; this.displayName = this._getDisplayName(name); 
            this.lastProposalTime = {};
            this.DEFAULT_PROPOSAL_COOLDOWN_MS = 10000;
            this._isLive = false;
        }
        setIsLive(status) { this._isLive = status; }
        propose(symbol, direction, reason, score) {
            const s = this.bot.strategyStats[this.name] || this.bot.createDefaultStatEntry();
            s.proposals = (s.proposals || 0) + 1; 
            s.lastUpdate = Date.now();
            this.bot.strategyStats[this.name] = s;
            this.bot.saveStrategyStats();

            // Gölge mod: canlı değilse shadow havuzuna yaz, sinyal motoruna geçme
            if (!this._isLive) {
                this.bot.recordShadowProposal(this.name, direction, reason, score);
                return;
            }
            if (this.bot.settings.features.enableRiskGuardian && this.bot.riskGuardian.killSwitchActivated) return;

            const now = Date.now(); 
            const key = `${symbol}-${direction}`;
            const cooldown = (this.DEFAULT_PROPOSAL_COOLDOWN_MS ?? 10000);
            if (now - (this.lastProposalTime[key] || 0) < cooldown) return;
            this.bot.confluenceEngine.propose(this.name, direction, reason, score);
            this.lastProposalTime[key] = now;
        }
        _getDisplayName(name) { return name.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()); }
        analyzeOrderBook(orderBook) {}
        processTrade(trade) {}
        periodicAnalyze() {}
    }

    class WallBounceStrategy extends Strategy {
        constructor(bot) { super(bot, 'wallBounce'); this.DISTANCE_THRESHOLD_PERCENT = 0.05 / 100; }
        analyzeOrderBook(orderBook) {
            const currentPrice = this.bot.marketData.price; if (!currentPrice) return;
            const btcPrice = this.bot.marketData.btcPrice || 70000;
            const wallQuantityThreshold = (this.bot.settings.params.wallBtc * btcPrice) / currentPrice;
            for (const [price, qty] of orderBook.asks) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (price - currentPrice) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'sell', `Satış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
            for (const [price, qty] of orderBook.bids) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (currentPrice - price) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'buy', `Alış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
        }
    }
    class VelocityScalpingStrategy extends Strategy {
        constructor(bot) { super(bot, 'velocityScalping'); this.pricePoints = []; this.VELOCITY_WINDOW_MS = 2000; this.MIN_POINTS = 20; this.VELOCITY_THRESHOLD_PERCENT = 0.10 / 100; }
        processTrade(trade) {
            const now = Date.now(); 
            this.pricePoints.push({ time: now, price: trade.price }); 
            this.pricePoints = this.pricePoints.filter(p => now - p.time < this.VELOCITY_WINDOW_MS); 
            if (this.pricePoints.length < this.MIN_POINTS) return;
            const firstPoint = this.pricePoints[0]; const lastPoint = this.pricePoints[this.pricePoints.length - 1]; 
            const priceChange = (lastPoint.price - firstPoint.price) / firstPoint.price;
            if (priceChange > this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'buy', `Fiyat Hızı: +${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            } else if (priceChange < -this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'sell', `Fiyat Hızı: ${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            }
        }
    }
    class RsiDivergenceStrategy extends Strategy {
        constructor(bot) { super(bot, 'rsiDivergence'); }
        periodicAnalyze() {
            const candles = this.bot.candles; const rsiValues = this.bot.indicators.rsi; const lookback = this.bot.settings.params.rsiPeriod;
            if (!rsiValues || rsiValues.length < lookback || !candles || candles.length < lookback) return;
            const recentCandles = candles.slice(-lookback);
            const recentRsi = rsiValues.slice(-lookback);
            if(recentCandles.length < lookback) return;
            
            const lastCandle = recentCandles[recentCandles.length - 1]; 
            const prevCandle = recentCandles[0]; 
            const lastRsi = recentRsi[recentRsi.length - 1]; 
            const prevRsi = recentRsi[0];

            if (!lastCandle || !prevCandle || !isFinite(lastRsi) || !isFinite(prevRsi)) return;
            if (lastCandle.high > prevCandle.high && lastRsi < prevRsi) { 
                this.propose(this.bot.currentSymbol, 'sell', 'RSI Ayı Uyuşmazlığı', 5); 
            }
            if (lastCandle.low < prevCandle.low && lastRsi > prevRsi) { 
                this.propose(this.bot.currentSymbol, 'buy', 'RSI Boğa Uyuşmazlığı', 5); 
            }
        }
    }
    class OrderFlowMomentumStrategy extends Strategy {
        constructor(bot) { super(bot, 'orderFlowMomentum'); this.trades = []; this.WINDOW_MS = 5000; }
        processTrade(trade) {
            const now = Date.now(); 
            this.trades.push(trade); 
            this.trades = this.trades.filter(t => now - t.timestamp < this.WINDOW_MS); 
            if (this.trades.length < 50) return;
            const buys = this.trades.filter(t => !t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0); 
            const sells = this.trades.filter(t => t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0);
            const total = buys + sells; if (total === 0) return; 
            if (buys / total > 0.7) { this.propose(this.bot.currentSymbol, 'buy', `Alıcı Akışı: %${(buys / total * 100).toFixed(0)}`, 4); this.trades = []; }
            else if (sells / total > 0.7) { this.propose(this.bot.currentSymbol, 'sell', `Satıcı Akışı: %${(sells / total * 100).toFixed(0)}`, 4); this.trades = []; }
        }
    }
    class LiquidityGapsStrategy extends Strategy {
        constructor(bot) { super(bot, 'liquidityGaps'); this.GAP_THRESHOLD_PERCENT = 0.1 / 100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.asks || orderBook.asks.length < 2 || !orderBook.bids || orderBook.bids.length < 2) return;
            for (let i = 0; i < orderBook.asks.length - 1; i++) { 
                const gap = orderBook.asks[i + 1][0] - orderBook.asks[i][0]; 
                if ((gap / orderBook.asks[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'buy', `Likidite Boşluğu ${orderBook.asks[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.asks[i][0]))}`, 3); return; 
                } 
            }
            for (let i = 0; i < orderBook.bids.length - 1; i++) { 
                const gap = orderBook.bids[i][0] - orderBook.bids[i + 1][0]; 
                if ((gap / orderBook.bids[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'sell', `Likidite Boşluğu ${orderBook.bids[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.bids[i][0]))}`, 3); return; 
                } 
            }
        }
    }
    class BreakoutPatternStrategy extends Strategy {
        constructor(bot) { super(bot, 'breakoutPattern'); this.LOOKBACK = 30; this.VOL_SPIKE = 1.4; this.BREAK_PCT = 0.03/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK + 1) return;
            const recent = c.slice(-this.LOOKBACK-1);
            const highs = recent.map(x=>x.high), lows = recent.map(x=>x.low), vols = recent.map(x=>x.volume);
            const last = recent[recent.length-1]; 
            const maxH = Math.max(...highs.slice(0, -1)); const minL = Math.min(...lows.slice(0, -1));
            const volSma = vols.slice(0,-1).reduce((a,b)=>a+b,0) / (vols.length-1);
            if (last.close > maxH * (1 + this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'buy', 'Aralık Üstü Hacimli Kırılım', 4);
            } else if (last.close < minL * (1 - this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'sell', 'Aralık Altı Hacimli Kırılım', 4);
            }
        }
    }
    class SupportResistanceStrategy extends Strategy {
        constructor(bot) { super(bot, 'supportResistance'); this.LOOKBACK = 60; this.THRESH = 0.15/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            const last = slice[slice.length-1];
            const maxH = Math.max(...slice.slice(0, -1).map(x=>x.high)); const minL = Math.min(...slice.slice(0,-1).map(x=>x.low));
            const distTop = (maxH - last.close)/last.close; const distBot = (last.close - minL)/last.close;
            if (distTop >= 0 && distTop < this.THRESH && last.close < last.open) {
                this.propose(this.bot.currentSymbol, 'sell', 'Direnç Bölgesi Reddi', 3);
            }
            if (distBot >= 0 && distBot < this.THRESH && last.close > last.open) {
                this.propose(this.bot.currentSymbol, 'buy', 'Destek Bölgesi Tepkisi', 3);
            }
        }
    }
    class FibonacciRetracementStrategy extends Strategy {
        constructor(bot) { super(bot, 'fibonacciRetracement'); this.LOOKBACK = 120; this.TOL = 0.2/100; this.levels = [0.382, 0.5, 0.618]; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            let high = -Infinity, low = Infinity, hT=0, lT=0;
            slice.forEach(k => { if(k.high > high){high=k.high; hT=k.time;} if(k.low < low){low=k.low; lT=k.time;} });
            if (!isFinite(high) || !isFinite(low) || high===low) return;
            const last = slice[slice.length-1];
            if (hT > lT) {
                const retr = (high - last.close) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'buy', `Fibo ${Math.round(L*100)}% Bölgesi`, 3); break; }
                }
            } else {
                const retr = (last.close - low) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'sell', `Fibo ${Math.round(L*100)}% Bölgesi`, 3); break; }
                }
            }
        }
    }
    class VolumeProfileStrategy extends Strategy {
        constructor(bot) { super(bot, 'volumeProfile'); this.PERIOD = 20; this.SPIKE = 2.0; this.CLOSE_POS = 0.7; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.PERIOD + 1) return;
            const last = c[c.length-1];
            const vols = c.slice(-this.PERIOD-1, -1).map(x=>x.volume);
            const volSma = vols.reduce((a,b)=>a+b,0)/vols.length;
            if (last.volume > volSma * this.SPIKE && (last.close - last.low) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'buy', 'Hacim Spike - Üst Kapanış', 3);
            } else if (last.volume > volSma * this.SPIKE && (last.high - last.close) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'sell', 'Hacim Spike - Alt Kapanış', 3);
            }
        }
    }
    class SmartMoneyConceptsStrategy extends Strategy {
        constructor(bot) { super(bot, 'smartMoneyConcepts'); this.GAP_MIN_PCT = 0.05/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 3) return;
            const a = c[c.length-3], b = c[c.length-2], d = c[c.length-1];
            if ((d.low - b.high > 0) && (b.low - a.high > 0) && ((d.low - a.high)/Math.max(1e-8, d.low) > this.GAP_MIN_PCT)) {
                 this.propose(this.bot.currentSymbol, 'buy', 'Bullish FVG (IMB)', 4);
            }
            if ((a.low - b.high > 0) && (b.low - d.high > 0) && ((a.low - d.high)/Math.max(1e-8, d.high) > this.GAP_MIN_PCT)) {
                this.propose(this.bot.currentSymbol, 'sell', 'Bearish FVG (IMB)', 4);
            }
        }
    }
    class DivergenceDetectionStrategy extends Strategy {
        constructor(bot) { super(bot, 'divergenceDetection'); this.LOOKBACK = 40; this.SWING_PERIOD = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; const rsi = this.bot.indicators.rsi; 
            if (!rsi || c.length < this.LOOKBACK || rsi.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK), r = rsi.slice(-this.LOOKBACK);
            const pivLows = []; const pivHighs = [];
            for (let i = this.SWING_PERIOD; i < slice.length - this.SWING_PERIOD; i++) {
                const isPivotLow = slice[i].low < Math.min(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.low)) && 
                                   slice[i].low < Math.min(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.low));
                const isPivotHigh = slice[i].high > Math.max(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.high)) && 
                                    slice[i].high > Math.max(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.high));
                if (isPivotLow) pivLows.push(i);
                if (isPivotHigh) pivHighs.push(i);
            }
            if (pivLows.length >= 2) {
                const i1 = pivLows[pivLows.length-2], i2 = pivLows[pivLows.length-1];
                if (slice[i2].low < slice[i1].low && r[i2] > r[i1]) {
                    this.propose(this.bot.currentSymbol, 'buy', 'Boğa Sapması (RSI)', 5);
                }
            }
            if (pivHighs.length >= 2) {
                const i1 = pivHighs[pivHighs.length-2], i2 = pivHighs[pivHighs.length-1];
                if (slice[i2].high > slice[i1].high && r[i2] < r[i1]) {
                    this.propose(this.bot.currentSymbol, 'sell', 'Ayı Sapması (RSI)', 5);
                }
            }
        }
    }
    class MarketStructureStrategy extends Strategy {
        constructor(bot) { super(bot, 'marketStructure'); this.SWING = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 2*this.SWING+5) return;
            const pivotHighs = [], pivotLows = [];
            for (let i = this.SWING; i < c.length - this.SWING; i++) {
                if (c[i].high > Math.max(...c.slice(i-this.SWING, i).map(x=>x.high)) && c[i].high > Math.max(...c.slice(i+1, i+1+this.SWING).map(x=>x.high))) pivotHighs.push({price: c[i].high, index: i});
                if (c[i].low < Math.min(...c.slice(i-this.SWING, i).map(x=>x.low)) && c[i].low < Math.min(...c.slice(i+1, i+1+this.SWING).map(x=>x.low))) pivotLows.push({price: c[i].low, index: i});
            }
            const last = c[c.length-1];
            if (pivotHighs.length) {
                const ph = pivotHighs[pivotHighs.length-1].price;
                if (last.close > ph) this.propose(this.bot.currentSymbol, 'buy', 'Yapı Kırılımı (BOS Up)', 4);
            }
            if (pivotLows.length) {
                const pl = pivotLows[pivotLows.length-1].price;
                if (last.close < pl) this.propose(this.bot.currentSymbol, 'sell', 'Yapı Kırılımı (BOS Down)', 4);
            }
        }
    }
    class InstitutionalOrderFlowStrategy extends Strategy {
        constructor(bot) { super(bot, 'institutionalOrderFlow'); this.TOP_N = 5; this.IMB_THRESHOLD = 2.0; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length < this.TOP_N || !orderBook.asks || orderBook.asks.length < this.TOP_N) return;
            const topB = orderBook.bids.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            const topA = orderBook.asks.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            if (topB / Math.max(1e-8, topA) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'buy', 'Orderbook İmbalansı (Bid Ağırlık)', 3);
            } else if (topA / Math.max(1e-8, topB) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'sell', 'Orderbook İmbalansı (Ask Ağırlık)', 3);
            }
        }
    }
    class MicroSpreadArbitrageStrategy extends Strategy {
        constructor(bot) { super(bot, 'microSpreadArbitrage'); this.SPREAD_PCT = 0.08/100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) return;
            const bestBid = orderBook.bids[0][0], bestAsk = orderBook.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            if (spreadPct > this.SPREAD_PCT) {
                const current = this.bot.marketData.price || mid;
                if (current < mid) this.propose(this.bot.currentSymbol, 'buy', 'Geniş Spread - Mean Reversion', 2);
                else this.propose(this.bot.currentSymbol, 'sell', 'Geniş Spread - Mean Reversion', 2);
            }
        }
    }
    class VWAPReversionStrategy extends Strategy {
        constructor(bot) { super(bot, 'vwapReversion'); this.MULT = 1.0; }
        periodicAnalyze() {
            const price = this.bot.marketData.price, vwap = this.bot.indicators.vwap, atr = this.bot.indicators.atr;
            if (!price || !vwap || !atr) return;
            const dev = atr;
            if (price > vwap + this.MULT * dev) this.propose(this.bot.currentSymbol, 'sell', 'VWAP Üstü Aşırı Sapma', 3);
            if (price < vwap - this.MULT * dev) this.propose(this.bot.currentSymbol, 'buy', 'VWAP Altı Aşırı Sapma', 3);
        }
    }
    class SuperTrendStrategy extends Strategy {
        constructor(bot) { super(bot, 'superTrend'); this.MULT = 3.0; this.PERIOD = 14; }
        periodicAnalyze() {
            const c = this.bot.candles; const atr = this.bot.indicators.atr;
            if (!atr || c.length < 2) return;
            const last = c[c.length-1];
            const m = (last.high + last.low) / 2;
            const upper = m + this.MULT * atr, lower = m - this.MULT * atr;
            if (last.close > upper) this.propose(this.bot.currentSymbol, 'buy', 'ATR Kanal Üstü Kırılım (SuperTrend)', 4);
            else if (last.close < lower) this.propose(this.bot.currentSymbol, 'sell', 'ATR Kanal Altı Kırılım (SuperTrend)', 4);
        }
    }

    // YENİ STRATEJİLER
    class VolatilityBreakoutStrategy extends Strategy {
        constructor(bot) {
            super(bot, 'volatilityBreakout');
            this.SQUEEZE_PERIOD = 20;
            this.VOL_SPIKE = 1.5;
        }
        periodicAnalyze() {
            const { candles, indicators } = this.bot;
            const { bb, volSma20 } = indicators;
            if (!bb || !bb.bandwidth || bb.bandwidth.length < this.SQUEEZE_PERIOD || !volSma20) return;

            const bandwidth = bb.bandwidth.slice(-this.SQUEEZE_PERIOD);
            const lastBandwidth = bandwidth[bandwidth.length - 1];
            const minBandwidth = Math.min(...bandwidth);
            const lastCandle = candles[candles.length-1];

            // Sıkışma Tespiti (Bollinger Bant genişliği son X mumun en düşük seviyesinde mi?)
            if (lastBandwidth <= minBandwidth * 1.05) { // %5 tolerans ile
                // Sıkışma sonrası patlama kontrolü
                if (lastCandle.close > bb.upper[bb.upper.length-1] && lastCandle.volume > volSma20 * this.VOL_SPIKE) {
                    this.propose(this.bot.currentSymbol, 'buy', 'Volatilite Patlaması (Yukarı)', 5);
                } else if (lastCandle.close < bb.lower[bb.lower.length-1] && lastCandle.volume > volSma20 * this.VOL_SPIKE) {
                     this.propose(this.bot.currentSymbol, 'sell', 'Volatilite Patlaması (Aşağı)', 5);
                }
            }
        }
    }
    class FundingRateReversalStrategy extends Strategy {
        constructor(bot) {
            super(bot, 'fundingRateReversal');
            this.FR_EXTREME_THRESHOLD = 0.001; // %0.1 fonlama oranı
            this.OI_INCREASE_THRESHOLD = 1.05; // %5 OI artışı
            this.priceHistory = [];
        }
        periodicAnalyze() {
            const { fundingRate, openInterest } = this.bot.marketData;
            const price = this.bot.marketData.price;
            if (typeof fundingRate === 'undefined' || typeof openInterest === 'undefined' || !price) return;
            
            // Son 10 periyodun fiyat ve OI verisini tut
            if(this.priceHistory.length > 10) this.priceHistory.shift();
            this.priceHistory.push({price, openInterest});

            if (this.priceHistory.length < 10) return;

            const firstRec = this.priceHistory[0];
            const priceChange = (price - firstRec.price) / firstRec.price;
            const oiChange = openInterest / firstRec.openInterest;
            
            // Short Squeeze Potansiyeli
            if (fundingRate < -this.FR_EXTREME_THRESHOLD && priceChange < -0.005 && oiChange > this.OI_INCREASE_THRESHOLD) {
                 this.propose(this.bot.currentSymbol, 'buy', 'Short Squeeze Potansiyeli (Negatif FR)', 4);
            }
            // Long Squeeze Potansiyeli
            if (fundingRate > this.FR_EXTREME_THRESHOLD && priceChange > 0.005 && oiChange > this.OI_INCREASE_THRESHOLD) {
                 this.propose(this.bot.currentSymbol, 'sell', 'Long Squeeze Potansiyeli (Pozitif FR)', 4);
            }
        }
    }
    class CandleCharacterStrategy extends Strategy {
        constructor(bot) {
            super(bot, 'candleCharacter');
            this.MIN_BODY_RATIO = 0.6; // Mumun en az %60'ı gövde olmalı
        }
        
        periodicAnalyze() {
            const candles = this.bot.candles;
            if (candles.length < 1) return;
            
            const lastCandle = candles[candles.length - 1];
            const { open, high, low, close } = lastCandle;
            
            const range = high - low;
            if (range === 0) return;
            
            const body = Math.abs(close - open);
            const bodyRatio = body / range;
            
            // Sadece güçlü gövdeli mumları dikkate al
            if (bodyRatio < this.MIN_BODY_RATIO) return;

            // Güçlü Alış Mumu
            const isBullish = close > open;
            const closePosition = (close - low) / range; // 0 (en dip) ile 1 (en tepe) arası
            if (isBullish && closePosition > 0.8) {
                this.propose(this.bot.currentSymbol, 'buy', 'Güçlü Alış Mumu Karakteri', 4);
            }
            
            // Güçlü Satış Mumu
            if (!isBullish && closePosition < 0.2) {
                this.propose(this.bot.currentSymbol, 'sell', 'Güçlü Satış Mumu Karakteri', 4);
            }
        }
    }


    /* =========================
       UYUM MOTORU (CONFLUENCE)
       ========================= */
    class ConfluenceEngine {
        constructor(bot) { 
            this.bot = bot; 
            this.proposals = []; 
            this.lastSignalTime = 0; 
            this.lastSignalTimeByDirection = { buy: 0, sell: 0 };
            this.lastDirection = null;
            this.buyScore = 0;
            this.sellScore = 0;
        }
        propose(strategy, direction, reason, score) {
            const now = Date.now();
            this.proposals = this.proposals.filter(p => !(p.strategy === strategy && p.direction === direction));
            this.proposals.push({ strategy, direction, reason, score, timestamp: now });
            this.checkConfluence();
        }
        _computeDirectional(direction) {
            const now = Date.now();
            const decaySec = this.bot.settings.optimization.timeDecaySec || 3;
            const groupSums = { trending: 0, meanReversion: 0, marketInternal: 0, neutral: 0 };
            const used = [];
            const groupsUsed = new Set();
            const activeProposals = this.proposals.filter(p => {
                const strategyInstance = this.bot.strategies[p.strategy];
                return strategyInstance && strategyInstance._isLive && p.direction === direction;
            });
            for (const p of activeProposals) {
                const w = this.bot.getStrategyWeight(p.strategy);
                const ageSec = (now - p.timestamp)/1000;
                const decay = Math.exp(-ageSec / decaySec);
                const eff = p.score * w * decay;
                const grp = this.bot.getStrategyGroup(p.strategy);
                groupsUsed.add(grp);
                groupSums[grp] = (groupSums[grp] || 0) + eff;
                used.push({ strategy: p.strategy, baseScore: p.score, weight: w, decay, effScore: eff });
            }
            const score = Object.values(groupSums).reduce((sum, val) => sum + val, 0); 
            return { score, contributors: used, groupSums, groupsCount: groupsUsed.size, contributorsCount: used.length };
        }
        checkConfluence() {
            const now = Date.now();
            const cd = this.bot.settings?.cooldowns || {};
            const proposalTimeout = cd.proposalTimeoutMs ?? 3000;
            const signalCooldown = cd.signalMs ?? 15000;
            const sameDirCooldown = cd.sameDirectionMs ?? 30000;
            const oppCooldown = cd.oppositeDirectionMs ?? 20000;
            const reverseHys = cd.reverseHysteresisPoints ?? 2;
            const dirMargin = this.bot.settings.optimization.dirMargin ?? 0.5;
            const minThreshold = this.bot.getEffectiveThreshold();
            if (now - this.lastSignalTime < signalCooldown) return;
            this.proposals = this.proposals.filter(p => now - p.timestamp < proposalTimeout);

            let buy = this._computeDirectional('buy');
            let sell = this._computeDirectional('sell');

            const mtfEnabled = this.bot.settings.confirmation.enableMtfConfirm;
            if (mtfEnabled) {
                const trend = this.bot.multiTimeframeManager.getTrendDirection();
                if (trend === 'up') {
                    buy.score *= 1.1; sell.score *= 0.7;
                } else if (trend === 'down') {
                    buy.score *= 0.7; sell.score *= 1.1;
                }
            }

            const buyPenalty = this.bot.settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('buy') : 0;
            const sellPenalty = this.bot.settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('sell') : 0;

            const q = this.bot.settings.optimization.signalQuality || { minContributors: 1, minGroups: 1 };
            const buyOk = (buy.contributorsCount >= q.minContributors) && (buy.groupsCount >= q.minGroups);
            const sellOk = (sell.contributorsCount >= q.minContributors) && (sell.groupsCount >= q.minGroups);

            const buyScoreAdj = buyOk ? (buy.score - buyPenalty) : -Infinity;
            const sellScoreAdj = sellOk ? (sell.score - sellPenalty) : -Infinity;

            this.buyScore = buyScoreAdj;
            this.sellScore = sellScoreAdj;

            if (buyScoreAdj >= minThreshold && (buyScoreAdj > sellScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.buy < sameDirCooldown) return;
                if (this.lastDirection === 'sell' && (now - this.lastSignalTime) < oppCooldown) {
                    if (buyScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('buy', buy.contributors, buyScoreAdj);
            } else if (sellScoreAdj >= minThreshold && (sellScoreAdj > buyScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.sell < sameDirCooldown) return;
                if (this.lastDirection === 'buy' && (now - this.lastSignalTime) < oppCooldown) {
                    if (sellScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('sell', sell.contributors, sellScoreAdj);
            }
        }
        generateFinalSignal(direction, contributors, finalScore) {
            const contributingStrats = contributors.map(c => this.bot.strategies[c.strategy]?.displayName || c.strategy).join(', ');
            const signal = { 
                id: `sig_${Date.now()}`, timestamp: Date.now(), symbol: this.bot.currentSymbol, 
                direction, price: this.bot.marketData.price, score: finalScore, 
                reason: contributingStrats, contributors, status: 'pending', note: '',
                mfeR: 0, beDone: false, trailingStage: 0, entrySlDistance: 0, entryTpDistance: 0
            };
            this.bot.calculateDynamicTpSl(signal);

            if(this.bot.settings.confirmation.enableCandleConfirm){
                this.bot.addPendingSignal(signal);
            } else {
                signal.status = 'active';
                this.bot.addFinalSignal(signal);
            }
            
            this.proposals = [];
            const now = Date.now();
            this.lastSignalTime = now;
            this.lastSignalTimeByDirection[direction] = now;
            this.lastDirection = direction;
        }
    }

    /* =========================
       ANA UYGULAMA
       ========================= */
    class UltimateTradingCommandCenter {
        constructor() {
            this.allStrategiesMap = {
                // Mevcut Stratejiler
                'wallBounce': WallBounceStrategy, 'velocityScalping': VelocityScalpingStrategy, 'rsiDivergence': RsiDivergenceStrategy, 
                'orderFlowMomentum': OrderFlowMomentumStrategy, 'liquidityGaps': LiquidityGapsStrategy, 'fibonacciRetracement': FibonacciRetracementStrategy, 
                'volumeProfile': VolumeProfileStrategy, 'smartMoneyConcepts': SmartMoneyConceptsStrategy, 'divergenceDetection': DivergenceDetectionStrategy, 
                'breakoutPattern': BreakoutPatternStrategy, 'supportResistance': SupportResistanceStrategy, 'marketStructure': MarketStructureStrategy, 
                'institutionalOrderFlow': InstitutionalOrderFlowStrategy, 'microSpreadArbitrage': MicroSpreadArbitrageStrategy,
                'vwapReversion': VWAPReversionStrategy, 'superTrend': SuperTrendStrategy,
                // YENİ STRATEJİLER
                'volatilityBreakout': VolatilityBreakoutStrategy,
                'fundingRateReversal': FundingRateReversalStrategy,
                'candleCharacter': CandleCharacterStrategy
            };
            this.allStrategyKeys = Object.keys(this.allStrategiesMap); 

            this.isRunning = false; 
            this.sockets = {}; 
            
            this.currentSymbol = this.loadData('utc_current_symbol') || 'BTCUSDT'; 
            this.currentTimeframe = this.loadData('utc_current_timeframe') || '5m';
            this.headerCollapsed = this.loadData('utc_header_collapsed') !== null ? (this.loadData('utc_header_collapsed') === 'true') : true; 
            this.currentMainView = this.loadData('utc_current_view') || 'chart';

            this.marketData = { price: 0, change24h: 0, volume24h: 0, symbol: this.currentSymbol, btcPrice: 70000, fundingRate: 0, openInterest: 0 }; 
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 

            this.aggTrades = []; 
            this.candles = [];
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null, bb: null }; 
            this.signals = this.loadData('utc_signals') || [];
            this.pendingSignals = [];
            this.stats = this.loadData('utc_stats') || { total: 0, tp: 0, sl: 0 };

            // Performans öğrenme
            this.strategyStats = this.loadData('utc_strategy_stats') || this.initDefaultStrategyStats();
            this.marketRegime = 'unknown'; // trend, range, transition, unknown
            this.sessionState = 'unknown'; 

            this.strategyGroups = {
                trending: ['breakoutPattern','orderFlowMomentum','marketStructure','volumeProfile','smartMoneyConcepts','superTrend', 'volatilityBreakout'],
                meanReversion: ['vwapReversion','wallBounce','liquidityGaps','fibonacciRetracement','supportResistance','microSpreadArbitrage','divergenceDetection','rsiDivergence'],
                marketInternal: ['institutionalOrderFlow', 'fundingRateReversal'],
                neutral: ['candleCharacter']
            };
            
            this.settings = this.loadSettings();
            this.strategies = {}; 
            
            this.combatModeActive = false;
            this.reconnectAttempts = 0;
            this.reconnectDelay = 3000;

            this.shadowProposals = [];

            this.chartManager = new ChartManager('live-chart');
            this.heatmapManager = new HeatmapManager('orderbook-heatmap');
            this.confluenceEngine = new ConfluenceEngine(this);
            this.multiTimeframeManager = new MultiTimeframeManager(this); 
            this.spoofDetector = new SpoofDetector(this);               
            this.cusumDetector = new CUSUMDriftDetector();               
            this.sessionProfiler = new SessionProfiler();                 
            this.riskGuardian = new RiskGuardian(this);                   
            
            this.renderInterval = null; 
            this.analysisInterval = null;
            this.cooldownTuneInterval = null;
            this.thresholdTuneInterval = null;
            this.paramTuneInterval = null;
            this.sessionUpdateInterval = null;
            this.countdownInterval = null; 
            this.premiumIndexInterval = null;

            this.lastAutoToggleTs = 0;
            this.runtimeThresholdOffset = 0; 

            this.synth = window.speechSynthesis || null; 
            this.speechQueue = [];
            this.isSpeaking = false;
            this.voices = []; 
            
            this.speechTexts = {
                 buy: [
                    "Harika bir fırsat! [Sembol] için alım sinyali geldi. Yeşil ışık yanıyor! Skor [Skor].",
                    "Piyasa nefes aldı, [Sembol] yükselişe geçiyor. Bu trene binmek ister misin? Skor [Skor].",
                    "Komutanım, hesaplamalar net: [Sembol] için güçlü bir alım. Devler uyanıyor! Skor [Skor].",
                    "Cüzdanlarınıza dikkat, [Sembol] için bir yükseliş trendi başlangıcı. Fırsat kapınızı çaldı! Skor [Skor].",
                    "Gözünü dört aç! [Sembol] için büyük bir potansiyel görüyorum. Roket kalkışa hazır! Skor [Skor].",
                    "Bugün şanslı günün olabilir! [Sembol] alım için çağırıyor. İç sesine kulak ver! Skor [Skor].",
                    "Duy sesimi Komutanım! [Sembol] için alım sinyali. Hadi, pazarın nabzını tutalım! Skor [Skor].",
                    "Piyasa dans etmeye başladı, [Sembol] yükselişle eşlik ediyor. Katılmak ister misin? Skor [Skor].",
                    "Bana güven, [Sembol] için enerji pozitif. Bu işlemi kaçırmak istemezsin. Skor [Skor].",
                    "Ulan [Sembol] için alım sinyali patladı, hala ne bekliyorsun lanet olası! Kalk ve parayı kap, yoksa pişmanlık seni yer bitirir! Skor [Skor]."
                ],
                sell: [
                    "Piyasa biraz yorulmuş gibi, [Sembol] için satış sinyali geldi. Karları garantiye alalım! Skor [Skor].",
                    "Komutanım, [Sembol] için aşağı yönlü bir hareketlilik bekliyorum. Tetikte ol! Skor [Skor].",
                    "Bazen geri çekilmek de kazanmaktır. [Sembol] için satış vakti. Parçaları topluyoruz! Skor [Skor].",
                    "Bir fırtına yaklaşıyor olabilir, [Sembol] için satış sinyali. Kendini güvende tut! Skor [Skor].",
                    "Akıllıca bir adım! [Sembol] için kazançları koruma zamanı. Hızlı ve isabetli olalım. Skor [Skor].",
                    "Piyasa nazikçe fısıldıyor: [Sembol] için biraz ara ver. Karını koru! Skor [Skor].",
                    "Riskleri minimize etmenin zamanı geldi. [Sembol] için satış önerisi. Gerekirse tekrar gireriz. Skor [Skor].",
                    "Satış sinyali geldi. Umarım boğalar çimlere basmamıştır! [Sembol] için. Skor [Skor].",
                    "Ulan [Sembol] düşüyor, hala mı tutuyorsun lanet olası aptal! Sat da kurtul, yoksa cebin boşalır sinirlenme bana! Skor [Skor].",
                    "Siktir et o umudunu, [Sembol] satış sinyali verdi! Sert ol, çık ve karı kap, motive ol lan yoksa kaybedersin! Skor [Skor]."
                ],
                combatModeActivate: [
                    "Kumandanım, Kırmızı Alarm! Savaş Modu aktive edildi! Piyasanın kalbi şimdi elimizde!",
                    "Sistem uyarısı: Ultra savaş modu devrede! Piyasa savaşı başlıyor! Her bir strateji tam kapasite!",
                    "Savaş Modu Başladı! İleri Komutanım! Tüm güçler hazır, her anı avantaja çevireceğiz!",
                    "Hazırlanın! Savaş Modu aktive edildi. Bu bir zihin oyunu ve biz kazanacağız! Odaklanma ve hız, anahtarımız!",
                    "Ulan savaş modu aktive! Piyasa seni ezmeye çalışıyor ama biz daha sertiz lan, kalk ayağa ve piyasayı sikert! Zafer bizim olacak!"
                ],
                combatModeDeactivate: [
                    "Savaş modu başarıyla sonlandırıldı. Piyasa koşulları normale dönüyor, normal operasyonlara geri dönüyoruz. İyi iş çıkardınız.",
                    "Operasyon sonu. Savaş modu kapatıldı. Şimdi piyasanın sakin sularında yüzme zamanı.",
                    "Savaş modu devre dışı. Riskler azaldı, piyasa sakinleşiyor. Sakin sularda bile fırsatlar vardır, unutmayın.",
                    "Kumandanım, savaş bitti. Kazanılmış bir zaferin ardından dinlenme vakti. Bir sonraki mücadeleye kadar hazırız.",
                    "Ulan savaş modu kapandı, hala mı sinirli duruyorsun lan? Rahatla Komutanım, zaferi kutla yoksa ben sinirlenirim sana da!"
                ],
                signalTP: [
                    "Hedef vuruldu! TP geldi, Komutanım! Bu başarı sizin stratejik dehanızın kanıtı!",
                    "Tebrikler! Kar realizasyonu gerçekleşti. Şimdi kahve içme zamanı, zafer sizin!",
                    "TP alarmı! Kazanç cebinizde, piyasa artık bizim kontrolümüzde. Harika iş!",
                    "Boom! TP hedefi tutturuldu. Strateji kusursuz, Komutanım lider!",
                    "Kar alındı! Zekânız ve disiplininizle piyasanın kalbini fethettiniz!",
                    "Ulan TP vuruldu, para cebinde lan! Sinirliydim piyasaya ama sen ezerdin, motive ol da kutla zaferi Komutanım!"
                ],
                signalSL: [
                    "SL tetiklendi! Savaş kaybedilmiş değil, ders alınmış! Komutanım, hazırlanın ve tekrar saldırın!",
                    "Stop Loss aktif. Kaybedilen bir savaş değil, bir sonraki zaferin başlangıcı!",
                    "SL geldi, ama moral bozulmasın. Bu sadece piyasanın egonuzu test etmesi!",
                    "Kaybı kabul et, ama pes etme. SL tetiklendi, stratejiyi yeniden şekillendiriyoruz!",
                    "SL alarmı! Hedefi kaybettik ama deneyim kazandık, Komutanım!",
                    "Ulan SL tetiklendi, para gitti lan! Sinirliyim piyasaya ama sen pes etme, motive ol da tekrar saldır Komutanım!"
                ],
                cusumDriftDetected: [
                    "CUSUM drift tespit edildi! Komutanım, piyasa dalgalanıyor ama biz her zaman hazırız!",
                    "Sinyal değişimi geldi, dikkat! Bu bir fırsat ya da ders, sizin kararınız!",
                    "CUSUM alarmı! Strateji tetikte, piyasa bizi test ediyor ama biz kazanmaya odaklıyız!",
                    "Drift detected! Piyasa kıvılcımları uçuşuyor, Komutanım, kontrol sizde!",
                    "Ulan CUSUM drift patladı, piyasa dalgalanıyor lan! Sinirliyim ulan, ama motive ol da hazır ol, fırsat mı ders mi sen karar ver!"
                ],
                autoToggleDeactivate: [
                    "Optimizasyon uyarısı: [Strateji Adı] stratejisi beklenen performansı göstermedi. Geçici olarak pasif edildi.",
                    "[Strateji Adı] stratejisi, performans testinden geçemedi. Geçici olarak emekli edildi. Dikkatli olalım.",
                    "Bir strateji daha devredışı. [Strateji Adı] şu an için dinlenmeye alındı. Daha iyi günler için bekliyoruz.",
                    "Ulan [Strateji Adı] performansı sıçtı, pasif edildi lan! Sinirliyim ulan, ama motive ol da bekle, en iyisi bu!"
                ],
                autoToggleActivate: [
                    "Optimizasyon başarıyla tamamlandı: [Strateji Adı] stratejisi tekrar aktif edildi. Yeni veriler çok umut verici!",
                    "Müjde! [Strateji Adı] stratejisi tekrar göreve hazır! Performansı yükselişte. Hadi bakalım, piyasayı sallayalım!",
                    "Hoş geldin geri [Strateji Adı]! Kendini toparlamışsın. Tekrar aktif edildi. Şimdi bize neler göstereceksin merak ediyorum.",
                    "Ulan [Strateji Adı] geri döndü, aktif edildi lan! Sinirliydim yokluğunda ama motive ol da sallayalım piyasayı, zafer yakın ulan!"
                ],
                cooldownOptimize: [
                    "Sistem, soğuma sürelerini başarıyla yeniden ayarladı. Piyasanın nabzına göre şimdiden optimize edildik Komutanım.",
                    "Cooldown ayarları güncellendi. Artık sinyaller arasında daha zeki bir denge kuruyoruz. Ben bu işi biliyorum!",
                    "Piyasa ritmini değiştirdi, biz de cooldown sürelerimizi. Tam senkronizasyon için her şey ayarlandı Komutanım.",
                    "Ulan cooldown süreleri ayarlandı lan! Sinirliydim piyasanın ritmine ama optimize ettik, motive ol da dans pistinde ezeriz hepsini Komutanım!"
                ],
                systemStart: [
                    "Sistem başlatıldı. Canlı veri akışı başlıyor. Gözlerim ve kulaklarım piyasada Komutanım.",
                    "Başlatma tamamlandı. Piyasa analizine başlıyorum. Bana güvenebilirsin.",
                    "Uyanıyorum... Tüm sensörler aktif. Piyasa maceramız şimdi başlıyor!",
                    "Ulan sistem başladı lan! Sinirliydim uykuda ama şimdi canlı veri akıyor, motive ol da piyasayı ezeriz Komutanım!"
                ],
                systemStop: [
                    "Sistem durduruldu. Operasyonlar askıya alındı. Bir mola verelim Komutanım.",
                    "Kapanış prosedürü aktif. Veri akışı durduruldu. Daha sonra görüşmek üzere!",
                    "Enerji tasarrufu modu. Sistem kapanıyor. İhtiyaç duyduğunuzda beni tekrar başlatabilirsiniz.",
                    "Ulan sistem durduruldu lan! Sinirliydim piyasaya ama şimdi mola ver, motive ol da dinlen Komutanım yoksa ezerim seni yorgunlukla!"
                ],
                symbolChange: [
                    "Sembol [Sembol] olarak değiştirildi. Yeni bir maceraya hazırız.",
                    "Hedef [Sembol] olarak güncellendi. Adaptasyon tamamlandı. Şimdi bu sembole odaklanıyoruz.",
                    "Sembol değişimi: [Sembol]. Her zaman yeni bir meydan okumaya açığım.",
                    "Ulan sembol [Sembol] oldu lan! Sinirliydim eskisine ama şimdi motive ol da yeni maceraya atıl, ezeriz piyasayı Komutanım!"
                ],
                timeframeChange: [
                    "Zaman aralığı [Timeframe] olarak değiştirildi. Daha büyük veya küçük resme odaklanıyoruz.",
                    "Mum çubuğu zaman dilimi [Timeframe] olarak ayarlandı. Bakış açımızı güncelledik.",
                    "[Timeframe] zaman dilimindeyiz. Piyasanın farklı bir yüzünü keşfediyoruz.",
                    "Ulan zaman aralığı [Timeframe] oldu lan! Sinirliydim eskisine ama şimdi motive ol da büyük resme odaklan, ezeriz piyasayı Komutanım!"
                ],
                resetAll: [
                    "Tüm ayarlar sıfırlandı. Sistem yeniden başlatılmaya hazır. Temiz bir sayfa açtık Komutanım.",
                    "Ulan tüm ayarlar sıfırlandı lan! Sinirliydim karmaşaya ama şimdi motive ol da temiz sayfaya atıl, ezeriz piyasayı Komutanım!"
                ],
                // Yeni TTS replikleri
                shadowBan: [
                    "[Strateji] gölgeye alındı. Uslan da gel!",
                    "Şşşt [Strateji], gölge moduna geç. Önce pistte kendini ispat et."
                ],
                shadowRehab: [
                    "Bravo! [Strateji] gölgede form tuttu, tekrar sahnede.",
                    "[Strateji] rehabilite edildi. Hadi bakalım, yüzümüzü kara çıkarma!"
                ],
                rogueOfDay: [
                    "Bugünün şerefsizi: [Strateji]! Kendine gel de adam gibi sinyal ver.",
                    "[Strateji], bugün gözüm üzerinde. Şerefsizlikte ısrar etme!"
                ]
            };

            this.init();
        }
        
        createDefaultStatEntry() {
            return {
                stats: {
                    global: { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0 },
                    trend: { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0 },
                    range: { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0 },
                    volatile: { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0 },
                },
                shadowStats: {
                    wins: 0, losses: 0, proposals: 0
                },
                lastUpdate: Date.now()
            };
        }
        initDefaultStrategyStats() {
            const stats = {};
            (this.allStrategyKeys || []).forEach(k => {
                stats[k] = this.createDefaultStatEntry();
            });
            return stats;
        }
        saveStrategyStats() { this.saveData('utc_strategy_stats', this.strategyStats); }

        loadSettings() {
            const savedSettings = JSON.parse(localStorage.getItem('utc_settings_v2') || '{}');
            const defaults = {
                confluenceThreshold: 3,
                params: { rsiPeriod: 14, atrPeriod: 14, wallBtc: 20, rrRatio: 1.5 },
                cooldowns: { signalMs: 15000, sameDirectionMs: 30000, oppositeDirectionMs: 20000, reverseHysteresisPoints: 2, proposalTimeoutMs: 3000, strategyProposalMs: 10000 },
                features: { enableSpoofDetection: true, enableCUSUMDrift: true, enableRiskGuardian: true, enableTTS: true, preferredVoiceName: null },
                confirmation: {
                    enableCandleConfirm: true,
                    enableMtfConfirm: true,
                    mtfTimeframe: '1h',
                    enableDynamicSizing: true
                },
                optimization: {
                    enabled: true,
                    autoToggle: true,
                    regimeSpecificLearning: true,
                    timeDecaySec: 3,
                    dirMargin: 0.5,
                    minWeightToStay: 0.60,
                    minContribForToggle: 30,
                    gating: { enabled: true, spreadMaxPct: 0.001, minDepthUsd: 50000 },
                    signalQuality: { minContributors: 2, minGroups: 2 }, 
                    breakeven: { enabled: true, beAtR: 0.8, trailAfterR: 1.5, trailToR: 0.5 }
                },
                penalties: {
                    shadowEnabled: true,
                    minWeightToShadow: 0.60,
                    minContribForShadow: 30,
                    rehabWinRate: 0.58,
                    minShadowProposals: 20,
                    coolOffMs: 30 * 60 * 1000
                },
                statusMaps: { shadowBanned: {}, hardBanned: {} },
                strategyParams: {
                    wallBounce: { DISTANCE_THRESHOLD_PERCENT: 0.0005 },
                    velocityScalping: { VELOCITY_WINDOW_MS: 2000, MIN_POINTS: 20, VELOCITY_THRESHOLD_PERCENT: 0.001 },
                    liquidityGaps: { GAP_THRESHOLD_PERCENT: 0.001 },
                    breakoutPattern: { LOOKBACK: 30, VOL_SPIKE: 1.4, BREAK_PCT: 0.0003 },
                    supportResistance: { LOOKBACK: 60, THRESH: 0.0015 },
                    fibonacciRetracement: { LOOKBACK: 120, TOL: 0.002 },
                    vwapReversion: { MULT: 1.0 },
                    superTrend: { MULT: 3.0, PERIOD: 14 },
                    marketStructure: { SWING: 3 },
                    institutionalOrderFlow: { TOP_N: 5, IMB_THRESHOLD: 2.0 },
                    microSpreadArbitrage: { SPREAD_PCT: 0.0008 },
                    volumeProfile: { PERIOD: 20, SPIKE: 2.0, CLOSE_POS: 0.7 },
                    divergenceDetection: { LOOKBACK: 40, SWING_PERIOD: 3 },
                    volatilityBreakout: { SQUEEZE_PERIOD: 20, VOL_SPIKE: 1.5 },
                    fundingRateReversal: { FR_EXTREME_THRESHOLD: 0.001, OI_INCREASE_THRESHOLD: 1.05 },
                    candleCharacter: { MIN_BODY_RATIO: 0.6 }
                },
                activeStrategies: {}
            };
            const currentSettings = { ...defaults, ...savedSettings };
            this.allStrategyKeys.forEach(key => {
                if (typeof currentSettings.activeStrategies[key] === 'undefined') {
                    currentSettings.activeStrategies[key] = true;
                }
                if (currentSettings.statusMaps.hardBanned[key] || currentSettings.statusMaps.shadowBanned[key]) {
                    currentSettings.activeStrategies[key] = false;
                }
            });
            return currentSettings;
        }

        saveSettings() {
            localStorage.setItem('utc_settings_v2', JSON.stringify(this.settings));
            this.applyStrategyParamOverrides(); 
        }
        loadData(key) { try { return JSON.parse(localStorage.getItem(key)); } catch { return null; } }
        saveData(key, data) { localStorage.setItem(key, JSON.stringify(data)); }

        getStrategyGroup(key) {
            for (const group in this.strategyGroups) {
                if(this.strategyGroups[group].includes(key)) return group;
            }
            return 'neutral';
        }
        getGroupBoost(key) {
            const grp = this.getStrategyGroup(key);
            let boost = 1.0;
            if (this.marketRegime === 'trend' && grp === 'trending') boost *= 1.15;
            if (this.marketRegime === 'range' && grp === 'meanReversion') boost *= 1.15;
            const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0;
            if (atrPct < 0.005) { if (grp === 'trending') boost *= 0.9; if (grp === 'meanReversion') boost *= 1.05; }
            else if (atrPct > 0.02) { if (grp === 'trending') boost *= 1.05; if (grp === 'meanReversion') boost *= 0.95; }
            return boost;
        }
        getStrategyWeight(name) {
            const s = this.strategyStats[name] || this.createDefaultStatEntry();
            
            const regime = (this.marketRegime in s.stats) ? this.marketRegime : 'global';
            let statSource = s.stats.global;

            if(this.settings.optimization.regimeSpecificLearning && s.stats[regime].contrib > 10){
                statSource = s.stats[regime]; // Eğer rejimde yeterli veri varsa onu kullan
            }
            
            const {alpha, beta, contrib} = statSource;
            const mean = alpha / (alpha + beta);
            const totalObservations = alpha + beta;
            const uncertaintyPenalty = totalObservations < 10 ? 0.5 + (totalObservations / 10) * 0.5 : 1.0; 
            let w = (0.5 + mean) * uncertaintyPenalty; 
            w *= this.getGroupBoost(name);
            w = Math.max(0.3, Math.min(2.0, w)); 
            return w;
        }

        init() {
            this.initStrategies(); 
            this.setupUI(); 
            this.setupEventListeners();
            this.renderSignals(true); 
            this.renderStats(true); 
            this.logToJournal('Sistem hazır. "SİSTEMİ BAŞLAT" butonuna tıklayın.');
            
            if (this.headerCollapsed) document.body.classList.add('header-collapsed'); else document.body.classList.remove('header-collapsed');
            this.switchMainView(this.currentMainView);
            this.sessionUpdateInterval = setInterval(() => this.updateSession(), 60000); 
            this.updateSession(); 

            this.countdownInterval = setInterval(() => this.updateCandleCountdown(), 1000);

            if (this.synth) {
                this.loadVoices();
                if (this.synth.onvoiceschanged !== undefined) {
                  this.synth.onvoiceschanged = () => this.loadVoices();
                }
            } else {
                console.warn('SpeechSynthesis API bu tarayıcı/cihazda desteklenmiyor.');
            }
            this.applyStrategyParamOverrides();
        }

        initStrategies() { 
            for (const key in this.allStrategiesMap) { 
                this.strategies[key] = new this.allStrategiesMap[key](this); 
            } 
            this.updateActiveStrategies(); 
        }
        updateActiveStrategies() { 
            for (const key in this.strategies) { 
                this.strategies[key].DEFAULT_PROPOSAL_COOLDOWN_MS = this.settings.cooldowns.strategyProposalMs; 
                const isActive = this.settings.activeStrategies[key] && 
                                 !this.settings.statusMaps.shadowBanned[key] && 
                                 !this.settings.statusMaps.hardBanned[key];
                this.strategies[key].setIsLive(isActive);
            } 
        }

        applyStrategyParamOverrides() {
            const p = this.settings.strategyParams || {};
            for (const key of Object.keys(this.strategies)) {
                if(!this.strategies[key]) continue;
                const inst = this.strategies[key];
                const ov = p[key] || {};
                for (const k of Object.keys(ov)) {
                    if (k in inst) inst[k] = ov[k];
                }
            }
        }

        setupUI() {
            document.getElementById('symbol-input').value = this.currentSymbol.replace('USDT', '');
            document.getElementById('timeframe-select').value = this.currentTimeframe;

            this.updateSettingsModalUI();
            const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme(); 
            this.heatmapManager.updateTheme();
            this.updateSuperTopTicker();
        }
        updateSuperTopTicker() { document.getElementById('ticker-bar-symbol').textContent = this.currentSymbol.replace('USDT', '/USDT'); }

        updateSettingsModalUI() {
            // Temel
            document.getElementById('modal-confluence-threshold').value = this.settings.confluenceThreshold;
            document.getElementById('modal-param-rsi-period').value = this.settings.params.rsiPeriod;
            document.getElementById('modal-param-atr-period').value = this.settings.params.atrPeriod;
            document.getElementById('modal-param-wall-btc').value = this.settings.params.wallBtc;
            document.getElementById('modal-param-rr-ratio').value = this.settings.params.rrRatio;
            // Cooldown
            document.getElementById('modal-signal-cooldown-ms').value = this.settings.cooldowns.signalMs;
            document.getElementById('modal-same-direction-cooldown-ms').value = this.settings.cooldowns.sameDirectionMs;
            document.getElementById('modal-opposite-direction-cooldown-ms').value = this.settings.cooldowns.oppositeDirectionMs;
            document.getElementById('modal-reverse-hysteresis-points').value = this.settings.cooldowns.reverseHysteresisPoints;
            document.getElementById('modal-proposal-timeout-ms').value = this.settings.cooldowns.proposalTimeoutMs;
            document.getElementById('modal-strategy-proposal-cooldown-ms').value = this.settings.cooldowns.strategyProposalMs;
            // Gelişmiş
            document.getElementById('modal-enable-spoof-detection').checked = this.settings.features.enableSpoofDetection;
            document.getElementById('modal-enable-cusum-drift').checked = this.settings.features.enableCUSUMDrift;
            document.getElementById('modal-enable-risk-guardian').checked = this.settings.features.enableRiskGuardian;
            document.getElementById('modal-enable-auto-optimize').checked = this.settings.optimization.enabled;
            document.getElementById('modal-enable-auto-toggle-strat').checked = this.settings.optimization.autoToggle;
            document.getElementById('modal-enable-breakeven-trail').checked = this.settings.optimization.breakeven.enabled;
            document.getElementById('modal-be-at-r').value = this.settings.optimization.breakeven.beAtR;
            document.getElementById('modal-trail-after-r').value = this.settings.optimization.breakeven.trailAfterR;
            document.getElementById('modal-trail-to-r').value = this.settings.optimization.breakeven.trailToR;
            document.getElementById('modal-enable-tts').checked = this.settings.features.enableTTS;

            // YENİ AYARLAR
            document.getElementById('modal-enable-candle-confirm').checked = this.settings.confirmation.enableCandleConfirm;
            document.getElementById('modal-enable-mtf-confirm').checked = this.settings.confirmation.enableMtfConfirm;
            document.getElementById('modal-mtf-timeframe-select').value = this.settings.confirmation.mtfTimeframe;
            document.getElementById('modal-enable-dynamic-sizing').checked = this.settings.confirmation.enableDynamicSizing;
            
            this.updateTTSVoiceSelectUI(); 

            const strategyModalContainer = document.getElementById('modal-strategy-toggles');
            strategyModalContainer.innerHTML = '';
            this.allStrategyKeys.sort().forEach(key => { 
                const strategy = this.strategies[key];
                if(!strategy) return;
                const isChecked = this.settings.activeStrategies[key];
                const isShadowBanned = this.settings.statusMaps.shadowBanned[key];
                const isHardBanned = this.settings.statusMaps.hardBanned[key];
                
                let statusText = '';
                if (isHardBanned) statusText = ' (HARDBAN)';
                else if (isShadowBanned) statusText = ' (GÖLGE)';

                const toggleHtml = `<div class="form-group"><label class="checkbox-label"><input type="checkbox" class="strategy-toggle" data-strategy-key="${key}" ${isChecked ? 'checked' : ''} ${isHardBanned || isShadowBanned ? 'disabled' : ''}> ${strategy.displayName}${statusText}</label></div>`;
                strategyModalContainer.innerHTML += toggleHtml;
            });
            this.renderSignals(true); 
            this.renderStats(true);   
        }

        setupEventListeners() {
            // Mevcut Event Listeners
            document.getElementById('start-btn').addEventListener('click', () => this.start());
            document.getElementById('stop-btn').addEventListener('click', () => this.stop());
            document.getElementById('theme-toggle-btn').addEventListener('click', () => this.toggleTheme());
            document.getElementById('symbol-input').addEventListener('change', async (e) => {
                let newSymbol = e.target.value.toUpperCase();
                if (!newSymbol.endsWith('USDT')) newSymbol += 'USDT';
                if(newSymbol !== this.currentSymbol) {
                    await this.changeSymbol(newSymbol);
                    this.saveData('utc_current_symbol', newSymbol);
                }
            });
            document.getElementById('timeframe-select').addEventListener('change', async (e) => {
                this.changeTimeframe(e.target.value);
                this.saveData('utc_current_timeframe', e.target.value);
            });
            document.getElementById('header-main-bar').addEventListener('dblclick', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('main-controls-btn').addEventListener('click', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
            document.getElementById('heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
            document.getElementById('fullscreen-chart-btn').addEventListener('click', () => this.enterFullscreenChart());
            document.getElementById('exit-fullscreen-btn').addEventListener('click', () => this.exitFullscreenChart());
            document.getElementById('open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
            document.getElementById('clear-markers-btn').addEventListener('click', () => this.clearChartMarkers()); 
            document.getElementById('chart-zoom-in').addEventListener('click', () => this.chartManager.zoomIn());
            document.getElementById('chart-zoom-out').addEventListener('click', () => this.chartManager.zoomOut());
            document.getElementById('chart-zoom-reset').addEventListener('click', () => this.chartManager.resetZoom());
            document.getElementById('close-settings-modal-btn').addEventListener('click', () => this.closeSettingsModal());
            document.getElementById('settings-modal-overlay').addEventListener('click', (e) => { if (e.target.id === 'settings-modal-overlay') this.closeSettingsModal(); });

            // Ayar Değişiklikleri
            document.getElementById('modal-confluence-threshold').addEventListener('input', (e) => this.settings.confluenceThreshold = parseInt(e.target.value));
            // ... diğer mevcut ayarlar
            document.getElementById('modal-param-rsi-period').addEventListener('change', (e) => this.settings.params.rsiPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-atr-period').addEventListener('change', (e) => this.settings.params.atrPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-wall-btc').addEventListener('change', (e) => this.settings.params.wallBtc = parseInt(e.target.value));
            document.getElementById('modal-param-rr-ratio').addEventListener('change', (e) => this.settings.params.rrRatio = parseFloat(e.target.value));
            document.getElementById('modal-signal-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.signalMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-same-direction-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.sameDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-opposite-direction-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.oppositeDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-reverse-hysteresis-points').addEventListener('change', (e) => this.settings.cooldowns.reverseHysteresisPoints = parseInt(e.target.value) || 0);
            document.getElementById('modal-proposal-timeout-ms').addEventListener('change', (e) => this.settings.cooldowns.proposalTimeoutMs = parseInt(e.target.value) || 1000);
            document.getElementById('modal-strategy-proposal-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.strategyProposalMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-enable-spoof-detection').addEventListener('change', (e) => this.settings.features.enableSpoofDetection = e.target.checked);
            document.getElementById('modal-enable-cusum-drift').addEventListener('change', (e) => this.settings.features.enableCUSUMDrift = e.target.checked);
            document.getElementById('modal-enable-risk-guardian').addEventListener('change', (e) => this.settings.features.enableRiskGuardian = e.target.checked);
            document.getElementById('modal-enable-auto-optimize').addEventListener('change', (e) => this.settings.optimization.enabled = e.target.checked);
            document.getElementById('modal-enable-auto-toggle-strat').addEventListener('change', (e) => this.settings.optimization.autoToggle = e.target.checked);
            document.getElementById('modal-enable-breakeven-trail').addEventListener('change', (e) => this.settings.optimization.breakeven.enabled = e.target.checked);
            document.getElementById('modal-be-at-r').addEventListener('change', (e) => this.settings.optimization.breakeven.beAtR = parseFloat(e.target.value));
            document.getElementById('modal-trail-after-r').addEventListener('change', (e) => this.settings.optimization.breakeven.trailAfterR = parseFloat(e.target.value));
            document.getElementById('modal-trail-to-r').addEventListener('change', (e) => this.settings.optimization.breakeven.trailToR = parseFloat(e.target.value));
            document.getElementById('modal-enable-tts').addEventListener('change', (e) => {
                this.settings.features.enableTTS = e.target.checked;
                this.updateTTSVoiceSelectUI();
            });
            document.getElementById('modal-tts-voice-select').addEventListener('change', (e) => {
                this.settings.features.preferredVoiceName = e.target.value === "" ? null : e.target.value;
            });
            
            // YENİ Event Listeners
            document.getElementById('modal-enable-candle-confirm').addEventListener('change', (e) => this.settings.confirmation.enableCandleConfirm = e.target.checked);
            document.getElementById('modal-enable-mtf-confirm').addEventListener('change', (e) => this.settings.confirmation.enableMtfConfirm = e.target.checked);
            document.getElementById('modal-mtf-timeframe-select').addEventListener('change', (e) => this.settings.confirmation.mtfTimeframe = e.target.value);
            document.getElementById('modal-enable-dynamic-sizing').addEventListener('change', (e) => this.settings.confirmation.enableDynamicSizing = e.target.checked);


            document.getElementById('modal-strategy-toggles').addEventListener('change', (e) => {
                if (e.target.classList.contains('strategy-toggle')) {
                    const key = e.target.dataset.strategyKey;
                    if (this.settings.statusMaps.hardBanned[key] || this.settings.statusMaps.shadowBanned[key]) {
                        e.target.checked = !e.target.checked;
                        return;
                    }
                    this.settings.activeStrategies[key] = e.target.checked;
                    this.updateActiveStrategies();
                    this.showNotification(`${this.strategies[key].displayName} ${e.target.checked ? 'aktif' : 'pasif'}.`, 'info');
                }
            });

            document.getElementById('modal-clear-signals-btn').addEventListener('click', () => this.clearAllSignals());
            document.getElementById('reset-all-settings-btn').addEventListener('click', () => this.resetAllSettings());
            document.getElementById('save-settings-btn').addEventListener('click', () => { this.saveSettings(); this.showNotification('Ayarlar kaydedildi!', 'success'); this.closeSettingsModal(); });

            document.getElementById('honor-board-btn').addEventListener('click', () => this.openHonorModal());
            document.getElementById('banned-board-btn').addEventListener('click', () => this.openHonorModal('banned'));
            document.getElementById('close-honor-modal').addEventListener('click', () => this.closeHonorModal());
            document.getElementById('honor-modal-overlay').addEventListener('click', (e)=>{ if(e.target.id==='honor-modal-overlay') this.closeHonorModal(); });

            const resizeHandle = document.querySelector('.resize-handle');
            if (resizeHandle) { /* ... resize logic ... */ }
        }

        toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('utc_theme', newTheme);
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
        }
        toggleControlsPanel() {
            document.body.classList.toggle('header-collapsed');
            this.headerCollapsed = document.body.classList.contains('header-collapsed'); 
            setTimeout(() => { window.dispatchEvent(new Event('resize')); }, 360);
        }
        switchMainView(viewName) {
            this.currentMainView = viewName;
            const chartView = document.getElementById('chart-container-view');
            const heatmapView = document.getElementById('heatmap-container-view');
            const chartCountdownOverlay = document.getElementById('chart-countdown-overlay');

            if (viewName === 'chart') {
                chartView.classList.remove('hidden-view');
                heatmapView.classList.add('hidden-view');
                chartCountdownOverlay.classList.remove('hidden-view');
                setTimeout(() => { if(this.chartManager.chart) {this.chartManager.chart.resize(chartView.clientWidth, chartView.clientHeight); this.chartManager.chart.timeScale().fitContent();} }, 0); 
            } else {
                chartView.classList.add('hidden-view');
                heatmapView.classList.remove('hidden-view');
                chartCountdownOverlay.classList.add('hidden-view');
                setTimeout(() => { this.heatmapManager._resizeCanvas(); }, 0); 
            }
        }
        enterFullscreenChart() {
            document.body.classList.add('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.remove('hidden-view');
            document.getElementById('chart-countdown-overlay').classList.remove('hidden-view');
            setTimeout(() => this.chartManager.chart.resize(window.innerWidth, window.innerHeight), 0);
        }
        exitFullscreenChart() {
            document.body.classList.remove('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.add('hidden-view');
            if (this.currentMainView !== 'chart') {
                document.getElementById('chart-countdown-overlay').classList.add('hidden-view');
            }
            setTimeout(() => window.dispatchEvent(new Event('resize')), 50);
        }

        openSettingsModal() { this.updateSettingsModalUI(); document.getElementById('settings-modal-overlay').classList.add('visible'); }
        closeSettingsModal() { 
            document.getElementById('settings-modal-overlay').classList.remove('visible'); 
            this.updateActiveStrategies(); 
            this.calculateAllIndicators(); 
            window.dispatchEvent(new Event('resize')); 
            // Eğer MTF zaman dilimi değiştiyse yeniden başlat
            if(this.isRunning && this.settings.confirmation.mtfTimeframe !== this.multiTimeframeManager.higherTimeframe){
                this.multiTimeframeManager.initialize(this.currentSymbol, this.settings.confirmation.mtfTimeframe);
            }
        }

        resetAllSettings() {
            if (confirm('Tüm ayarları ve sinyal geçmişini sıfırlamak istediğinizden emin misiniz? Bu işlem geri alınamaz.')) {
                localStorage.removeItem('utc_settings_v2');
                localStorage.removeItem('utc_signals');
                localStorage.removeItem('utc_stats');
                localStorage.removeItem('utc_strategy_stats');
                localStorage.removeItem('utc_current_symbol'); 
                localStorage.removeItem('utc_current_timeframe'); 
                localStorage.removeItem('utc_header_collapsed'); 
                localStorage.removeItem('utc_current_view'); 
                
                this.settings = this.loadSettings(); 
                this.signals = []; 
                this.pendingSignals = [];
                this.stats = { total: 0, tp: 0, sl: 0 }; 
                this.strategyStats = this.initDefaultStrategyStats();
                this.currentSymbol = 'BTCUSDT'; 
                this.currentTimeframe = '5m'; 
                this.headerCollapsed = true;
                this.currentMainView = 'chart'; 

                this.initStrategies(); 
                this.applyStrategyParamOverrides();
                this.updateSettingsModalUI(); 
                this.renderSignals(true); 
                this.renderStats(true);   
                this.chartManager.clearMarkers(); 
                this.showNotification('Tüm ayarlar ve veriler sıfırlandı!', 'info');
                this.speak(this.getRandomMessage('resetAll'));
                this.stop(); 
                document.body.classList.add('header-collapsed'); 
                this.switchMainView('chart');
            }
        }

        async start() {
            if (this.isRunning) return;
            this.isRunning = true; 
            document.getElementById('start-btn').disabled = true; 
            document.getElementById('stop-btn').disabled = false;
            
            this.showNotification('Sistem Başlatıldı: Canlı veri akışı başlatılıyor...', 'success');
            this.speak(this.getRandomMessage('systemStart'));
            
            this.multiTimeframeManager.initialize(this.currentSymbol, this.settings.confirmation.mtfTimeframe);
            await this.fetchInitialData(); 
            this.connectWebSockets();
            
            this.renderInterval = setInterval(() => this.render(), 250);
            this.analysisInterval = setInterval(() => this.runPeriodicAnalysis(), 5000);
            this.premiumIndexInterval = setInterval(() => this.fetchPremiumIndexData(), 60000);
            this.fetchPremiumIndexData();

            if (this.settings.optimization.enabled) {
                this.cooldownTuneInterval = setInterval(() => this.autoTuneCooldowns(), 30000); 
                this.thresholdTuneInterval = setInterval(() => this.autoTuneThresholds(), 30000); 
                this.paramTuneInterval = setInterval(() => this.autoTuneStrategyParams(), 5 * 60 * 1000);
                this.autoToggleStrategiesInterval = setInterval(() => this.autoToggleStrategies(), 5 * 60 * 1000);
            }
        }

        stop() {
            if (!this.isRunning) return;
            this.isRunning = false; 
            document.getElementById('start-btn').disabled = false; 
            document.getElementById('stop-btn').disabled = true; 
            this.disconnectWebSockets();
            if (this.renderInterval) clearInterval(this.renderInterval); 
            if (this.analysisInterval) clearInterval(this.analysisInterval);
            if (this.cooldownTuneInterval) clearInterval(this.cooldownTuneInterval);
            if (this.thresholdTuneInterval) clearInterval(this.thresholdTuneInterval);
            if (this.paramTuneInterval) clearInterval(this.paramTuneInterval);
            if (this.autoToggleStrategiesInterval) clearInterval(this.autoToggleStrategiesInterval);
            if (this.premiumIndexInterval) clearInterval(this.premiumIndexInterval);
            
            this.multiTimeframeManager.cleanup();
            this.updateConnectionStatus(false, "BAĞLANTI KESİLDİ"); 
            if (this.combatModeActive) this.deactivateCombatMode();
            this.showNotification('Sistem Durduruldu.', 'danger');
            this.speak(this.getRandomMessage('systemStop'));
        }

        async changeSymbol(newSymbol) {
            if (this.currentSymbol === newSymbol) return;
            this.currentSymbol = newSymbol; 
            this.showNotification(`${this.currentSymbol.replace('USDT', '/USDT')} sembolüne geçildi.`, 'info');
            this.speak(this.getRandomMessage('symbolChange', { 'Sembol': this.currentSymbol.replace('USDT', '') }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); }
            this.updateSuperTopTicker(); 
        }
        async changeTimeframe(newTimeframe) {
            this.currentTimeframe = newTimeframe; 
            this.showNotification(`Zaman aralığı ${this.currentTimeframe} olarak değiştirildi.`, 'info');
            this.speak(this.getRandomMessage('timeframeChange', { 'Timeframe': this.currentTimeframe }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); }
        }
        resetDataForNewSymbol() {
            this.candles = []; this.aggTrades = []; this.marketData.price = 0; 
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null, bb: null };
            this.pendingSignals = [];
            this.chartManager.setData([]); this.chartManager.clearMarkers(); this.render();
            this.heatmapManager.draw({bids:[], asks:[]}, 0);
        }

        async fetchInitialData() {
            try {
                this.logToJournal(`${this.currentSymbol} için geçmiş mum verileri çekiliyor...`);
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=${this.currentTimeframe}&limit=500`;
                const response = await fetch(url); if (!response.ok) throw new Error(`API Hatası: ${response.statusText}`);
                const data = await response.json();
                this.candles = data.map(d => ({ time: d[0], open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]), }));
                this.chartManager.setData(this.candles); this.logToJournal(`${this.candles.length} adet mum yüklendi.`);
                this.calculateAllIndicators();
            } catch (error) { this.showNotification(`Geçmiş veri alınamadı: ${error.message}`, 'danger'); console.error("Geçmiş veri hatası:", error); }
        }

        async fetchPremiumIndexData(){
            if(!this.isRunning) return;
            try {
                const url = `https://fapi.binance.com/fapi/v1/premiumIndex?symbol=${this.currentSymbol}`;
                const response = await fetch(url); if (!response.ok) return;
                const data = await response.json();
                this.marketData.fundingRate = parseFloat(data.lastFundingRate) || 0;
                this.marketData.openInterest = parseFloat(data.openInterest) || 0;
            } catch(e) { /* ignore */ }
        }

        connectWebSockets() {
            this.disconnectWebSockets(); 
            this.reconnectAttempts = 0;
            const symbolLower = this.currentSymbol.toLowerCase();
            const streams = [`${symbolLower}@ticker`, `${symbolLower}@depth20@100ms`, `${symbolLower}@aggTrade`, `${symbolLower}@kline_${this.currentTimeframe}`];
            const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams.join('/')}`); 
            this.sockets['main'] = ws;
            
            ws.onopen = () => { this.updateConnectionStatus(true); this.reconnectAttempts = 0; this.logToJournal("WebSocket bağlantısı başarıyla kuruldu."); };
            ws.onmessage = (event) => { const message = JSON.parse(event.data); this.handleMarketData(message.stream, message.data); };
            ws.onerror = (error) => console.error('WebSocket Hatası:', error);
            ws.onclose = () => { 
                if (this.isRunning) { 
                    this.reconnectAttempts++;
                    this.reconnectDelay = Math.min(30000, 3000 * Math.pow(2, this.reconnectAttempts - 1));
                    const message = `YENİDEN BAĞLANILIYOR... (${this.reconnectDelay / 1000}s)`;
                    this.updateConnectionStatus(false, message); 
                    this.logToJournal(`Bağlantı kapandı. ${this.reconnectDelay/1000} saniye sonra yeniden denenecek. (Deneme: ${this.reconnectAttempts})`);
                    setTimeout(() => this.connectWebSockets(), this.reconnectDelay); 
                } 
            };
        }
        disconnectWebSockets() { 
            if (this.sockets['main']) { 
                this.sockets['main'].onclose = null;
                this.sockets['main'].close(1000, "İstemci tarafından kapatıldı"); 
                delete this.sockets['main'];
            }
        }

        handleMarketData(stream, data) {
            const streamType = stream.split('@')[1];
            if (streamType === 'ticker') {
                this.marketData.price = parseFloat(data.c);
                this.marketData.change24h = parseFloat(data.P);
                this.marketData.volume24h = parseFloat(data.q);
                this.marketData.symbol = data.s;
                if (data.s === 'BTCUSDT') this.marketData.btcPrice = parseFloat(data.c);
                this.manageOpenPositions();
                this.checkAutoCloseSignals();
            } 
            else if (streamType.startsWith('depth')) {
                this.orderBook = { 
                    bids: data.b.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    asks: data.a.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    lastUpdateId: data.u 
                };
                this.heatmapManager.draw(this.orderBook, this.marketData.price);
                if(this.settings.features.enableSpoofDetection) this.spoofDetector.trackOrderBook(this.orderBook);
                for (const key in this.strategies) {
                    if (typeof this.strategies[key].analyzeOrderBook === 'function') {
                        this.strategies[key].analyzeOrderBook(this.orderBook);
                    }
                }
            } else if (streamType.startsWith('kline')) {
                if (this.candles.length > 0) {
                    const kline = data.k; 
                    this.chartManager.updateRealtime(kline);
                    const newCandle = { time: kline.t, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c), volume: parseFloat(kline.v) };
                    
                    if (kline.x) { // Mum kapandı
                        const lastCandle = this.candles[this.candles.length - 1];
                        if (lastCandle && lastCandle.time === kline.t) this.candles[this.candles.length - 1] = newCandle; 
                        else this.candles.push(newCandle);
                        if (this.candles.length > 500) this.candles.shift(); 
                        this.calculateAllIndicators(); 
                        this.processPendingSignalsOnCandleClose(newCandle);
                    } else { // Mum içi güncelleme
                        const lastCandle = this.candles[this.candles.length - 1];
                        if (lastCandle && lastCandle.time === kline.t) {
                            this.candles[this.candles.length - 1] = newCandle;
                        }
                    }
                    this.manageOpenPositions();
                    this.checkAutoCloseSignals();
                }
            } else if (streamType === 'aggTrade') {
                const trade = { price: parseFloat(data.p), quantity: parseFloat(data.q), isBuyerMaker: data.m, timestamp: data.T };
                for (const key in this.strategies) {
                    if (typeof this.strategies[key].processTrade === 'function') {
                        this.strategies[key].processTrade(trade);
                    }
                }
            }
        }
        
        runPeriodicAnalysis() { 
            if (!this.isRunning) return; 
            for (const key in this.strategies) {
                if(this.strategies[key]._isLive && typeof this.strategies[key].periodicAnalyze === 'function') {
                    this.strategies[key].periodicAnalyze(); 
                }
            }
            if (this.settings.features.enableRiskGuardian) this.riskGuardian.checkKillSwitch();
        }
        
        calculateAllIndicators() {
            if (this.candles.length === 0) return;
            const closes = this.candles.map(c => c.close);
            const highs = this.candles.map(c => c.high);
            const lows = this.candles.map(c => c.low);
            const volumes = this.candles.map(c => c.volume);

            // RSI, ATR, SMA, VWAP, ADX
            // ... (mevcut kodlar aynı kalıyor)...
             // RSI
            if (closes.length >= this.settings.params.rsiPeriod) { this.indicators.rsi = this.calculateRSI(closes, this.settings.params.rsiPeriod); } 
            else { this.indicators.rsi = []; }
            // ATR
            if (this.candles.length >= this.settings.params.atrPeriod) { this.indicators.atr = this.calculateATR(this.candles, this.settings.params.atrPeriod); }
             else { this.indicators.atr = null; }

            const sma = (arr, n) => arr.length < n ? null : arr.slice(-n).reduce((a,b)=>a+b,0)/n;
            this.indicators.sma20 = sma(closes, 20);
            this.indicators.sma50 = sma(closes, 50);
            this.indicators.volSma20 = sma(volumes, 20);

            let cumPV = 0, cumV = 0;
            const recentCandles = this.candles.slice(-100); // Son 100 mumluk VWAP
            for (const k of recentCandles) { const tp = (k.high + k.low + k.close)/3; cumPV += tp * k.volume; cumV += k.volume; }
            this.indicators.vwap = cumV ? (cumPV / cumV) : null;
            
            this.indicators.adx = this.calcADX(this.candles, this.settings.params.atrPeriod);
            const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price * 100) : 0;
            if (this.indicators.adx > 25) this.marketRegime = 'trend';
            else if (atrPct < 0.5 && this.indicators.adx < 20) this.marketRegime = 'range';
            else if(atrPct > 1.5) this.marketRegime = 'volatile';
            else this.marketRegime = 'transition';

            // Bollinger Bands
            this.indicators.bb = this.calculateBollingerBands(closes, 20, 2);
        }

        calculateRSI(data, period) {
            let gains = 0, losses = 0;
            for (let i = data.length - period; i < data.length; i++) {
                const diff = data[i] - data[i-1];
                if (diff > 0) gains += diff; else losses -= diff;
            }
            let avgGain = gains / period, avgLoss = losses / period;
            const rsi = [100 - (100 / (1 + (avgLoss === 0 ? 100 : avgGain / avgLoss)))];
            return rsi; // Sadece son değeri döndürmek yeterli
        }
        calculateATR(candles, period) {
            let trs = [];
            const relevantCandles = candles.slice(-(period+1));
            for (let i = 1; i < relevantCandles.length; i++) {
                const c = relevantCandles[i], p = relevantCandles[i - 1];
                trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
            }
            return trs.reduce((a, b) => a + b, 0) / period;
        }

        calculateBollingerBands(data, period, stdDev) {
            if (data.length < period) return null;
            const result = { upper: [], middle: [], lower: [], bandwidth: [] };
            for (let i = period - 1; i < data.length; i++) {
                const slice = data.slice(i - period + 1, i + 1);
                const sma = slice.reduce((a, b) => a + b, 0) / period;
                const std = Math.sqrt(slice.map(x => Math.pow(x - sma, 2)).reduce((a, b) => a + b, 0) / period);
                const upper = sma + stdDev * std;
                const lower = sma - stdDev * std;
                result.middle.push(sma);
                result.upper.push(upper);
                result.lower.push(lower);
                if (sma > 0) result.bandwidth.push((upper - lower) / sma);
            }
            return result;
        }

        calcADX(candles, period = 14) {
            if (!candles || candles.length < period * 2) return null; 
            const tr = [], plusDM = [], minusDM = [];
            for (let i = 1; i < candles.length; i++) {
                const c = candles[i], p = candles[i-1];
                const upMove = c.high - p.high;
                const downMove = p.low - c.low;
                tr.push(Math.max( c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close) ));
                plusDM.push((upMove > downMove && upMove > 0) ? upMove : 0);
                minusDM.push((downMove > upMove && downMove > 0) ? downMove : 0);
            }
            const wilderSmooth = (arr, n) => {
                let sum = arr.slice(0, n).reduce((a,b)=>a+b,0);
                const smoothed = [sum];
                for (let i = n; i < arr.length; i++) {
                    sum = sum - (sum/n) + arr[i];
                    smoothed.push(sum);
                }
                return smoothed;
            };
            const smoothedTR = wilderSmooth(tr, period);
            const smoothedPlusDM = wilderSmooth(plusDM, period);
            const smoothedMinusDM = wilderSmooth(minusDM, period);
            const plusDI = smoothedPlusDM.map((val, idx) => 100 * (val / Math.max(1e-8, smoothedTR[idx])));
            const minusDI = smoothedMinusDM.map((val, idx) => 100 * (val / Math.max(1e-8, smoothedTR[idx])));
            const dxValues = plusDI.map((pdi, idx) => 100 * Math.abs(pdi - minusDI[idx]) / Math.max(1e-8, (pdi + minusDI[idx])) );
            return dxValues.length >= period ? wilderSmooth(dxValues, period).pop() : null;
        }
        getOrderBookSnapshotInfo() {
            const ob = this.orderBook;
            if (!ob || !ob.bids || ob.bids.length === 0 || !ob.asks || ob.asks.length === 0) return null;
            const bestBid = ob.bids[0][0], bestAsk = ob.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            const topN = this.settings.optimization.gating.topN || 5;
            const sumUsd = (levels) => levels.slice(0, topN).reduce((s,[p,q])=> s + (p*q), 0);
            const topBidUsd = sumUsd(ob.bids);
            const topAskUsd = sumUsd(ob.asks);
            const minTopUsd = Math.min(topBidUsd, topAskUsd);
            return { spreadPct, minTopUsd };
        }
        marketGatingPenalty(direction) {
            const info = this.getOrderBookSnapshotInfo();
            if (!info || !this.settings.optimization.gating.enabled) return 0;
            const g = this.settings.optimization.gating;
            let penalty = 0;
            if (info.spreadPct > g.spreadMaxPct) penalty += 1.5; 
            if (info.minTopUsd < g.minDepthUsd) penalty += 1.5; 
            return penalty;
        }
        getEffectiveThreshold() { return (this.settings.confluenceThreshold || 3) + (this.runtimeThresholdOffset || 0); }

        calculateDynamicTpSl(signal) {
            const atr = this.indicators.atr;
            let rrRatioBase = this.settings.params.rrRatio;
            const minTh = this.getEffectiveThreshold();
            const over = Math.max(0, (signal.score - minTh));
            rrRatioBase *= (1 + Math.min(0.3, over / 10)); 

            if (this.marketRegime === 'trend') rrRatioBase *= 1.1;
            if (this.marketRegime === 'range') rrRatioBase *= 0.95;

            if (!atr || atr === 0) { 
                signal.tp = signal.direction === 'buy' ? signal.price * (1 + 0.01*rrRatioBase/1.5) : signal.price * (1 - 0.01*rrRatioBase/1.5);
                signal.sl = signal.direction === 'buy' ? signal.price * 0.995 : signal.price * 1.005;
            } else {
                const atrMultiplier = 1.5 - (Math.min(10, Math.max(0, signal.score)) / 10 * 0.5); 
                const slDistance = atr * atrMultiplier;
                const tpDistance = slDistance * rrRatioBase;
                if (signal.direction === 'buy') { signal.sl = signal.price - slDistance; signal.tp = signal.price + tpDistance; }
                else { signal.sl = signal.price + slDistance; signal.tp = signal.price - tpDistance; }
                signal.entrySlDistance = slDistance;
                signal.entryTpDistance = tpDistance;
            }

            if(this.settings.confirmation.enableDynamicSizing){
                if(signal.score >= minTh + 4) signal.recommendedSize = '2.0x';
                else if (signal.score >= minTh + 2) signal.recommendedSize = '1.5x';
                else if (signal.score >= minTh) signal.recommendedSize = '1.0x';
                else signal.recommendedSize = '0.5x';
            }
        }

        manageOpenPositions() { /* ... Mevcut kod aynı kalıyor ... */ }
        checkAutoCloseSignals() { /* ... Mevcut kod aynı kalıyor ... */ }
        render() { this.renderPriceDisplay(); this.updateSignalProgressBar(); }
        renderPriceDisplay() { /* ... Mevcut kod aynı kalıyor ... */ }
        updateCandleCountdown() { /* ... Mevcut kod aynı kalıyor ... */ }
        updateSignalProgressBar() { /* ... Mevcut kod aynı kalıyor ... */ }

        addPendingSignal(signal){
            this.pendingSignals.push(signal);
            this.showNotification(`ADAY SİNYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '')}. Mum kapanışı bekleniyor...`, 'warning', 3000);
        }

        processPendingSignalsOnCandleClose(closedCandle){
            if(this.pendingSignals.length === 0) return;
            
            this.pendingSignals.forEach(signal => {
                let isValid = false;
                if(signal.direction === 'buy'){
                    // Mum yeşil kapandıysa ve fiyat çok uzaklaşmadıysa onayla
                    if(closedCandle.close > closedCandle.open && closedCandle.close < signal.price * 1.005){
                        isValid = true;
                    }
                } else { // sell
                    // Mum kırmızı kapandıysa ve fiyat çok uzaklaşmadıysa onayla
                    if(closedCandle.close < closedCandle.open && closedCandle.close > signal.price * 0.995){
                        isValid = true;
                    }
                }

                if(isValid){
                    signal.status = 'active';
                    this.addFinalSignal(signal);
                } else {
                    this.showNotification(`Aday ${signal.direction.toUpperCase()} sinyali mum kapanışında geçersiz oldu.`, 'danger', 3000);
                }
            });
            this.pendingSignals = [];
        }

        addFinalSignal(signal) {
            this.signals.unshift(signal); if (this.signals.length > 200) this.signals.pop();
            this.saveData('utc_signals', this.signals);
            this.renderSignals(true); 
            this.renderStats(true); 
            this.chartManager.addSignalMarker(signal);
            let sizeText = signal.recommendedSize ? `| Boyut: ${signal.recommendedSize}` : '';
            this.showNotification(`YENİ SİNYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '')} | Skor: ${signal.score.toFixed(1)} ${sizeText}`, signal.direction === 'buy' ? 'success' : 'danger');
            playSignal(signal.direction); 
            if (this.settings.features.enableTTS) {
                const message = this.getRandomMessage(signal.direction, { Sembol: signal.symbol.replace('USDT', ''), Skor: signal.score.toFixed(1) });
                this.speak(message);
            }
            if (signal.score >= 8 && !this.combatModeActive) { this.activateCombatMode(); } 
        }

        updateSignalResult(signalId, result) {
            const signal = this.signals.find(s => s.id === signalId && s.status === 'active');
            if(!signal) return;

            signal.status = result;
            this.stats.total++;
            this.stats[result]++;
            this.updateStrategyStats(signal);
            this.updateStrategyShadowStats(signal);
            this.evaluateShadowRehab();

            if (this.settings.features.enableCUSUMDrift) {
                if (this.cusumDetector.update(result === 'tp')) {
                    this.showNotification('PERFORMANS SAPMASI!', 'Sinyal kazanma oranında sapma tespit edildi. Ayarlar optimize ediliyor...', 'warning');
                    if (this.settings.features.enableTTS) this.speak(this.getRandomMessage('cusumDriftDetected'));
                }
            }
            this.saveData('utc_signals', this.signals);
            this.saveData('utc_stats', this.stats);
            this.renderSignals(true); 
            this.renderStats(true);   
            this.showNotification(`Sinyal ${signal.id.substring(0,6)} - ${result.toUpperCase()} olarak sonuçlandı.`, 'info');
            if (this.settings.features.enableTTS) this.speak(this.getRandomMessage(result === 'tp' ? 'signalTP' : 'signalSL'));
        }

        updateStrategyStats(signal) {
            const isWin = signal.status === 'tp';
            const contributors = signal.contributors || [];
            const totalEff = contributors.reduce((s, c) => s + (c.effScore || 1), 0) || 1;
            const regime = (this.marketRegime in this.createDefaultStatEntry().stats) ? this.marketRegime : 'global';
            
            for (const c of contributors) {
                const stat = this.strategyStats[c.strategy] || this.createDefaultStatEntry();
                const credit = (c.effScore || (c.baseScore * (c.weight || 1))) / totalEff;

                const update = (obj) => {
                    obj.alpha *= 0.995; obj.beta *= 0.995;
                    obj.contrib += 1;
                    if(isWin) { obj.wins += credit; obj.alpha += credit; }
                    else { obj.losses += credit; obj.beta += credit; }
                };
                
                update(stat.stats.global);
                if(this.settings.optimization.regimeSpecificLearning) update(stat.stats[regime]);

                stat.lastUpdate = Date.now();
                this.strategyStats[c.strategy] = stat;
            }
            this.saveStrategyStats();
        }

        updateStrategyShadowStats(signal) {
            const windowMs = (this.settings.cooldowns?.proposalTimeoutMs || 3000) * 2;
            const relevantProposals = this.shadowProposals.filter(p => p.timestamp >= signal.timestamp - windowMs && p.timestamp <= signal.timestamp && p.direction === signal.direction);
            const creditedStrats = new Set();

            for(const p of relevantProposals.reverse()){
                if(creditedStrats.has(p.strategy)) continue;
                
                const st = this.strategyStats[p.strategy] || this.createDefaultStatEntry();
                st.shadowStats.proposals = (st.shadowStats.proposals || 0) + 1;
                if(signal.status === 'tp') st.shadowStats.wins = (st.shadowStats.wins || 0) + 1;
                else st.shadowStats.losses = (st.shadowStats.losses || 0) + 1;
                st.lastUpdate = Date.now();
                this.strategyStats[p.strategy] = st;
                creditedStrats.add(p.strategy);
            }
            this.saveStrategyStats();
        }

        evaluateShadowRehab() { /* ... Mevcut kod aynı kalıyor ... */ }
        autoToggleStrategies() { /* ... Mevcut kod aynı kalıyor ... */ }
        autoTuneCooldowns() { /* ... Mevcut kod aynı kalıyor ... */ }
        autoTuneThresholds() { /* ... Mevcut kod aynı kalıyor ... */ }
        autoTuneStrategyParams() { /* ... Mevcut kod aynı kalıyor ... */ }

        renderSignals(fullRender = false) {
            const tbody = document.getElementById('modal-signals-body');
            if (!tbody) return;
            if (fullRender) { tbody.innerHTML = ''; }
            
            const signalsToRender = fullRender ? this.signals.slice(0, 100) : this.signals.filter(s => ['active', 'pending'].includes(s.status));

            signalsToRender.forEach(signal => {
                const rowId = `signal-row-${signal.id}`;
                let row = document.getElementById(rowId);
                const className = signal.status === 'tp' ? 'signal-tp' : (signal.status === 'sl' ? 'signal-sl' : '');
                
                if (row) { // Update existing row
                    row.cells[6].textContent = signal.recommendedSize || '-';
                    row.cells[8].textContent = signal.status.toUpperCase();
                    row.cells[9].textContent = signal.note || '';
                    row.className = className;
                } else { // Create new row
                    row = tbody.insertRow(0);
                    row.id = rowId;
                    row.className = className;
                    row.insertCell().textContent = new Date(signal.timestamp).toLocaleTimeString();
                    row.insertCell().textContent = signal.direction.toUpperCase();
                    row.insertCell().textContent = this.formatPrice(signal.price);
                    row.insertCell().textContent = signal.tp ? this.formatPrice(signal.tp) : '-';
                    row.insertCell().textContent = signal.sl ? this.formatPrice(signal.sl) : '-';
                    row.insertCell().textContent = typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score;
                    row.insertCell().textContent = signal.recommendedSize || '-';
                    row.insertCell().textContent = signal.reason;
                    row.insertCell().textContent = signal.status.toUpperCase();
                    row.insertCell().textContent = signal.note || '';
                }
            });
        }
        
        renderStats(fullRender = false) {
            const statsContainer = document.getElementById('modal-stats-container');
            if (!statsContainer) return;
            // ... (renderStats içeriği güncellenmiş ve tam haliyle kalıyor) ...
            const total = this.stats.total, tp = this.stats.tp, sl = this.stats.sl;
            const winRate = total > 0 ? ((tp / total) * 100).toFixed(1) : 0;
            const lossRate = total > 0 ? ((sl / total) * 100).toFixed(1) : 0;

            const html = `
                <div class="panel-title" style="margin-bottom: 10px;">Genel Sinyal İstatistikleri</div>
                <div class="stat-item"><span class="stat-label">Toplam Sinyal:</span><span class="stat-value">${total}</span></div>
                <div class="stat-item"><span class="stat-label">TP (Kazanılan):</span><span class="stat-value" style="color:var(--positive);">${tp}</span></div>
                <div class="stat-item"><span class="stat-label">SL (Kaybedilen):</span><span class="stat-value" style="color:var(--negative);">${sl}</span></div>
                <div class="stat-item"><span class="stat-label">Kazanma Oranı:</span><span class="stat-value" style="color:${winRate >= 50 ? 'var(--positive)' : 'var(--negative)'};">${winRate}%</span></div>
                <div class="stat-item"><span class="stat-label">Kaybetme Oranı:</span><span class="stat-value" style="color:${lossRate <= 50 ? 'var(--positive)' : 'var(--negative)'};">${lossRate}%</span></div>
                <div class="panel-title" style="margin-top: 15px; margin-bottom: 10px;">Strateji Performansı</div>
                <div class="data-table-container" style="max-height: 250px;">
                    <table class="data-table">
                        <thead>
                            <tr><th>Strateji</th><th>Ağırlık</th><th>WR% (Global)</th><th>WR% (Rejim)</th><th>Katkı (Rejim)</th><th>Gölge WR%</th></tr>
                        </thead>
                        <tbody>
                            ${Object.keys(this.strategyStats).sort().map(key => {
                                const s = this.strategyStats[key];
                                if(!s) return '';
                                const global = s.stats.global;
                                const regimeKey = (this.marketRegime in s.stats) ? this.marketRegime : 'global';
                                const regime = s.stats[regimeKey];
                                const shadow = s.shadowStats;
                                
                                const globalWR = (global.wins + global.losses) > 0 ? ((global.wins / (global.wins + global.losses)) * 100).toFixed(0) : '-';
                                const regimeWR = (regime.wins + regime.losses) > 5 ? ((regime.wins / (regime.wins + regime.losses)) * 100).toFixed(0) : '-';
                                const shadowWR = (shadow.wins + shadow.losses) > 0 ? ((shadow.wins / (shadow.wins + shadow.losses)) * 100).toFixed(0) : '-';

                                return `
                                    <tr>
                                        <td>${this.strategies[key]?.displayName || key}</td>
                                        <td>${this.getStrategyWeight(key).toFixed(2)}</td>
                                        <td style="color:${globalWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${globalWR}</td>
                                        <td style="color:${regimeWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${regimeWR} (${regimeKey.charAt(0)})</td>
                                        <td>${regime.contrib.toFixed(0)}</td>
                                        <td style="color:${shadowWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${shadowWR}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>`;
            statsContainer.innerHTML = html;
        }

        clearAllSignals() { /* ... Mevcut kod aynı kalıyor ... */ }
        clearChartMarkers() { /* ... Mevcut kod aynı kalıyor ... */ }
        formatPrice(price) { return price.toLocaleString('en-US', { minimumFractionDigits: this.getDecimalPlaces(price), maximumFractionDigits: this.getDecimalPlaces(price) }); }
        formatVolume(volume) { if (volume >= 1e9) return (volume / 1e9).toFixed(2) + 'B'; if (volume >= 1e6) return (volume / 1e6).toFixed(2) + 'M'; if (volume >= 1e3) return (volume / 1e3).toFixed(2) + 'K'; return volume ? volume.toFixed(2) : '0.00'; }
        getDecimalPlaces(price) { if (!price || !isFinite(price)) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        showNotification(message, type = 'info', timeout = 5000) { /* ... Mevcut kod aynı kalıyor ... */ }
        logToJournal(message) { console.log(`[JOURNAL] ${new Date().toLocaleTimeString()} - ${message}`); }
        updateConnectionStatus(isConnected, message = '') { /* ... Mevcut kod aynı kalıyor ... */ }
        updateSession() { this.sessionState = this.sessionProfiler.getCurrentSession(); }
        activateCombatMode() { /* ... Mevcut kod aynı kalıyor ... */ }
        deactivateCombatMode() { /* ... Mevcut kod aynı kalıyor ... */ }
        loadVoices() { /* ... Mevcut kod aynı kalıyor ... */ }
        updateTTSVoiceSelectUI() { /* ... Mevcut kod aynı kalıyor ... */ }
        speak(text, options = {}) { /* ... Mevcut kod aynı kalıyor ... */ }
        processSpeechQueue() { /* ... Mevcut kod aynı kalıyor ... */ }
        getRandomMessage(key, replacements = {}) { /* ... Mevcut kod aynı kalıyor ... */ }
        openHonorModal(filter = 'all') { /* ... Mevcut kod (güncellenmiş statlarla çalışacak şekilde) aynı kalıyor ... */ }
        closeHonorModal() { /* ... Mevcut kod aynı kalıyor ... */ }
        toggleShadow(key) { /* ... Mevcut kod aynı kalıyor ... */ }
        toggleHardBan(key) { /* ... Mevcut kod aynı kalıyor ... */ }
        openStrategySurgery(key) { /* ... Mevcut kod aynı kalıyor ... */ }
        saveStrategySurgery(key) { /* ... Mevcut kod aynı kalıyor ... */ }
    }

    // Uygulamayı başlat
    document.addEventListener('DOMContentLoaded', () => {
        window.app = new UltimateTradingCommandCenter();
    });
</script>
</body>
</html>
