<!DOCTYPE html>
<html lang="tr" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ULTIMATE TRADING KOMUTA MERKEZİ</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    :root {
      --background-dark: #0d1117; --panel-bg-dark: #161b22; --text-main-dark: #c9d1d9; --text-secondary-dark: #8b949e; --border-color-dark: #30363d; --input-bg-dark: #010409; --hover-bg-dark: #21262d; --primary-dark: #58a6ff;
      --background-light: #ffffff; --panel-bg: #f6f8fa; --text-main: #24292f; --text-secondary: #57606a; --border-color: #d0d7de; --input-bg: #f0f2f5; --hover-bg: #e8eaed; --primary: #0969da;
      --war-mode-bg: linear-gradient(145deg, #4d0000 0%, #000000 75%); --war-mode-panel-bg: rgba(255, 0, 0, 0.08); --war-mode-border: #8B0000; --war-mode-text: #ff5858; --war-mode-primary: #ffc107;
      --positive: #28a745; --negative: #dc3545; --neutral: #ffc107;
      --ticker-height: 30px; 
      --header-min-height: 40px;
    }
    [data-theme="light"] { --background: var(--background-light); --panel-bg: var(--panel-bg-light); --text-main: var(--text-main-light); --text-secondary: var(--text-secondary-light); --border-color: var(--border-color-light); --input-bg: var(--input-bg-light); --hover-bg: var(--hover-bg-light); --primary: var(--primary-light); }
    [data-theme="dark"] { --background: var(--background-dark); --panel-bg: var(--panel-bg-dark); --text-main: var(--text-main-dark); --text-secondary: var(--text-secondary-dark); --border-color: var(--border-color-dark); --input-bg: var(--input-bg-dark); --hover-bg: var(--hover-bg-dark); --primary: var(--primary-dark); }
    [data-theme="war"] { --background: var(--war-mode-bg); --panel-bg: var(--war-mode-panel-bg); --text-main: var(--war-mode-text); --text-secondary: #ffaaaa; --border-color: var(--war-mode-border); --input-bg: rgba(255, 255, 255, 0.05); --hover-bg: rgba(255, 255, 255, 0.1); --primary: var(--war-mode-primary); }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Roboto Mono', monospace; font-size: 12px; background: var(--background); color: var(--text-main); overflow: hidden; transition: background 0.5s, color 0.5s; }
    
    #super-top-ticker { display: flex; position: fixed; top: 0; left: 0; width: 100%; background: var(--panel-bg); border-bottom: 1px solid var(--border-color); padding: 2px 10px; z-index: 1100; align-items: center; justify-content: space-between; font-size: 11px; font-weight: 700; height: var(--ticker-height); }
    .super-top-left { display: flex; align-items: center; gap: 10px; flex-shrink: 0;}
    #ticker-bar-symbol { color: var(--primary); }
    #ticker-bar-price { color: var(--text-main); font-size: 12px; }
    .super-top-right-buttons { display: flex; gap: 5px; }

    .container { display: flex; flex-direction: column; height: 100vh; padding-top: var(--ticker-height); }

    .header { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; flex-shrink: 0; box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 5px; position: relative; }
    .header-top-bar { display: flex; align-items: center; width: 100%; padding: 5px 15px; min-height: var(--header-min-height); justify-content: space-between; cursor: pointer; font-weight: 700; font-size: 16px; color: var(--primary); }
    .header-collapsible-content { transition: max-height 0.35s ease-in-out, opacity 0.3s ease, padding 0.35s ease, visibility 0.35s; max-height: 300px; opacity: 1; overflow: hidden; visibility: visible; padding: 0 15px 8px 15px; }
    body.header-collapsed .header-collapsible-content { max-height: 0; opacity: 0; visibility: hidden; padding-top: 0; padding-bottom: 0; }

    .main-controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; padding-bottom: 8px; }
    .form-control { background: var(--input-bg); color: var(--text-main); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-family: 'Roboto Mono', monospace; }
    
    .status { display: flex; align-items: center; gap: 5px; font-size: 11px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--negative); transition: background-color 0.5s; }
    .status-dot.online { background: var(--positive); animation: pulse 2s infinite; }
    @keyframes pulse { 0% { box-shadow: 0 0 0 0 #28a745b3; } 70% { box-shadow: 0 0 0 6px #28a74500; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
    [data-theme="war"] .status-dot.online { background: var(--war-mode-primary); animation: war-pulse 1s infinite; }
    @keyframes war-pulse { 0% { box-shadow: 0 0 0 0 #ffc107b3; } 70% { box-shadow: 0 0 0 6px #ffc10700; } 100% { box-shadow: 0 0 0 0 #ffc10700; } }
    .btn { padding: 4px 12px; border: 1px solid var(--border-color); background: var(--panel-bg); color: var(--text-main); border-radius: 4px; cursor: pointer; transition: all 0.2s; }
    .btn:hover { background: var(--hover-bg); border-color: var(--primary); }
    .btn-success { background: var(--positive); color: white; border-color: var(--positive); } .btn-danger { background: var(--negative); color: white; border-color: var(--negative); }
    .btn-tiny { padding: 2px 6px; font-size: 10px; line-height: 1; min-width: 0; white-space: nowrap; }
    
    .main-grid { display: grid; grid-template-columns: 1fr; gap: 5px; flex-grow: 1; margin: 5px; overflow: hidden; height: calc(100% - var(--header-min-height) - 10px - var(--ticker-height)); }
    body.header-collapsed .main-grid { height: calc(100vh - var(--ticker-height) - 10px); margin-top: 0; } 
    
    .panel { display: flex; flex-direction: column; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; overflow: hidden; }
    .panel-title { font-weight: 700; font-size: 13px; color: var(--primary); padding: 8px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; display: flex; justify-content: space-between; align-items: center;}
    .panel-content { padding: 10px; overflow-y: auto; flex-grow: 1; }
    .settings-group { margin-bottom: 15px; } .form-group { margin-bottom: 8px; } .form-label { display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px; }
    .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 12px; padding: 4px 0;}
    
    .price-display { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; width: 100%; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; font-size: 10px; margin-top: 8px; } 
    .price-item .price-label { color: var(--text-secondary); } 
    .price-item .price-value { font-size: 18px; font-weight: 700; }
    
    .center-panel { display: grid; grid-template-rows: 1fr; gap: 5px; padding: 0 !important; } 
    .data-container { display: grid; grid-template-rows: 1fr auto; overflow: hidden; height: 100%; } 
    .data-grid { position: relative; overflow: hidden; min-height: 0; } 

    #live-chart { width: 100%; height: 100%; } 
    .heatmap-container { display: grid; grid-template-rows: auto 1fr; border-top: 1px solid var(--border-color); }
    #orderbook-heatmap { width: 100%; height: 100%; display: block; }

    .chart-zoom-controls { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; z-index: 100; }
    .chart-zoom-controls .btn-tiny { background: rgba(1, 4, 9, 0.7); backdrop-filter: blur(2px); }

    .data-table-container { width: 100%; height: 100%; overflow: auto; }
    .data-table { width: 100%; border-collapse: collapse; font-size: 11px; }
    .data-table th, .data-table td { padding: 6px 8px; text-align: left; border-bottom: 1px solid var(--border-color); white-space: nowrap;}
    .data-table th { font-weight: 700; position: sticky; top: 0; background: var(--panel-bg); z-index: 10;}
    .data-table tr:hover { background: var(--hover-bg); }
    .signal-buy { background-color: #28a74514; } .signal-sell { background-color: #dc354514; }
    .signal-tp { background-color: #28a74533; } .signal-sl { background-color: #dc354533; }
    .stat-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border-color); font-size: 12px; }
    .stat-item:last-child { border-bottom: none; } .stat-label { color: var(--text-secondary); } .stat-value { font-weight: 700; }
    .btn-sm { padding: 1px 4px; font-size: 9px; margin-left: 4px; border-radius: 3px; cursor: pointer;}
    ::-webkit-scrollbar { width: 6px; height: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: var(--text-secondary); border-radius: 3px; }
    .notifications { position: fixed; bottom: 15px; right: 15px; z-index: 2000; width: 320px; }
    .notification { background: var(--panel-bg); border: 1px solid var(--border-color); border-left-width: 5px; border-radius: 4px; padding: 12px; font-size: 13px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); margin-top: 10px; }
    .notification.success { border-left-color: var(--positive); } .notification.danger { border-left-color: var(--negative); } .notification.warning { border-left-color: var(--neutral); }
    
    aside#settings-panel, aside#analytics-panel { display: none !important; }
    .hidden-view { display: none !important; } 

    #settings-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 2500; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
    #settings-modal-overlay.visible { opacity: 1; visibility: visible; }
    .settings-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 90%; max-width: 860px; max-height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); transform: translateY(20px); transition: transform 0.3s ease; }
    #settings-modal-overlay.visible .settings-modal-content { transform: translateY(0); }
    .settings-modal-header { padding: 12px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 15px; color: var(--primary); }
    .settings-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
    .settings-modal-header .close-btn:hover { color: var(--negative); }
    .settings-modal-body { padding: 15px; overflow-y: auto; flex-grow: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .settings-modal-footer { padding: 12px 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 10px; }

    /* ŞEREF PANOSU MODAL */
    #board-modal-overlay { 
      position: fixed; top:0; left:0; width:100%; height:100%; 
      background: rgba(0,0,0,0.7); display:flex; justify-content:center; align-items:center; 
      z-index: 2500; opacity:0; visibility:hidden; transition: opacity 0.3s ease, visibility 0.3s ease; 
    }
    #board-modal-overlay.visible { opacity:1; visibility:visible; }

    @media screen and (max-width: 768px) {
      .container { padding-top: var(--ticker-height); }
      .header { order: 2; position: sticky; bottom: 0; top: auto; width: 100%; z-index: 1000; margin: 0; border-radius: 0; border: none; border-top: 1px solid var(--border-color); }
      .header-top-bar { flex-direction: column; align-items: center; gap: 10px; padding: 10px 15px; }
      .header-collapsible-content { padding: 0; }
      .header-collapsible-content .main-controls { flex-direction: column; align-items: center; padding: 0; width: 100%; }
      .form-control, .btn, .status { width: 100%; text-align: center; padding: 8px 10px; font-size: 11px; }
      .status { justify-content: center; }
      .price-display { grid-template-columns: repeat(2, 1fr); margin-top: 10px; }
      .price-item .price-value { font-size: 14px; } 
      .main-grid { order: 1; flex-direction: column; margin: 5px; overflow: visible; padding-bottom: 5px; height: auto; }
      .center-panel { order: 1; flex-grow: 0; height: auto; border: 1px solid var(--border-color); border-radius: 6px; background: var(--panel-bg); box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 0; }
      .center-panel > .panel-title { display: none; }
      .data-container { flex-direction: column; height: auto; padding: 10px; }
      .data-grid { height: 50vh; flex-shrink: 0; }
      #live-chart { height: 100%; width: 100%; } 
      .heatmap-container { height: 150px; flex-shrink: 0; margin-top: 10px; border-top: 1px solid var(--border-color); padding-top: 10px; }
      .settings-modal-content { width: 95%; margin: 10px; }
      .settings-modal-body { grid-template-columns: 1fr; gap: 15px; }
      .super-top-right-buttons { display: none; }
    }
  </style>
</head>
<body class="header-collapsed"> 
  <div id="super-top-ticker">
    <div class="super-top-left">
      <span id="ticker-bar-symbol"></span>
      <span id="ticker-bar-price"></span>
    </div>
    <div class="super-top-right-buttons">
      <button id="main-controls-btn" class="btn btn-tiny">Komuta Merkezi</button>
      <button id="chart-view-btn" class="btn btn-tiny">Grafik</button>
      <button id="heatmap-view-btn" class="btn btn-tiny">Isı Haritası</button>
      <button id="open-settings-modal-btn" class="btn btn-tiny">Ayarlar</button>
      <!-- Yeni: Şeref Panosu butonları -->
      <button id="honor-btn" class="btn btn-tiny">Şerefli</button>
      <button id="dishonor-btn" class="btn btn-tiny">Şerefsizler</button>
      <button id="banned-btn" class="btn btn-tiny">Banlılar</button>
    </div>
  </div>

  <div class="container">
    <header class="header">
      <div id="header-main-bar" class="header-top-bar" title="Paneli aç/kapatmak için çift tıkla">
        <span>KOMUTA MERKEZİ KONTROLLERİ</span>
      </div>
      <div class="header-collapsible-content">
        <div class="main-controls">
          <input type="text" id="symbol-input" class="form-control" placeholder="Örn: BTC, ETH, SOL">
          <select id="timeframe-select" class="form-control">
            <option value="1m">1m</option><option value="5m">5m</option><option value="15m" selected>15m</option><option value="1h">1h</option><option value="4h">4h</option>
          </select>
          <div class="status">
            <div id="connection-status" class="status-dot"></div>
            <span id="connection-text">BAĞLANTI YOK</span>
          </div>
          <button id="theme-toggle-btn" class="btn">Tema</button>
          <button id="start-btn" class="btn btn-success">SİSTEMİ BAŞLAT</button>
          <button id="stop-btn" class="btn btn-danger" disabled>DURDUR</button>
          <button id="clear-markers-btn" class="btn">Grafik Sinyallerini Sil</button> 
        </div>
        <div class="price-display">
          <div class="price-item"><div class="price-label">FİYAT</div><div class="price-value" id="current-price">-</div></div>
          <div class="price-item"><div class="price-label">24s DEĞİŞİM</div><div class="price-value" id="price-change-24h">-</div></div>
          <div class="price-item"><div class="price-label">24s HACİM</div><div class="price-value" id="volume-24h">-</div></div>
          <div class="price-item"><div class="price-label">VOLATİLİTE (ATR)</div><div class="price-value" id="atr-value">-</div></div>
        </div>
      </div>
    </header>

    <main class="main-grid">
      <section class="center-panel panel">
        <div class="data-container">
          <div class="data-grid" id="chart-container-view">
            <div id="live-chart"></div>
            <div class="chart-zoom-controls"> 
              <button id="chart-zoom-in" class="btn btn-tiny">+</button>
              <button id="chart-zoom-out" class="btn btn-tiny">-</button>
              <button id="chart-zoom-reset" class="btn btn-tiny">Sıfırla</button>
            </div>
          </div>
          <div class="heatmap-container hidden-view" id="heatmap-container-view">
            <div class="panel-title" style="border-top: 1px solid var(--border-color); border-bottom: none;">EMİR DEFTERİ ISI HARİTASI</div>
            <canvas id="orderbook-heatmap"></canvas>
          </div>
        </div>
      </section>
    </main>
  </div>
  
  <div id="notifications-container" class="notifications"></div>

  <!-- AYARLAR MODAL -->
  <div id="settings-modal-overlay">
    <div class="settings-modal-content">
      <div class="settings-modal-header">
        <span>AYARLAR & OPTİMİZASYON</span>
        <button class="close-btn" id="close-settings-modal-btn">&times;</button>
      </div>
      <div class="settings-modal-body">
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">Temel Parametreler</div>
          <div class="form-group"><label class="form-label">Min. Uyum Skoru (1-10)</label><input type="range" id="modal-confluence-threshold" class="form-control" min="1" max="10" value="3" step="1"></div>
          <div class="form-group"><label class="form-label">RSI Periyodu</label><input type="number" id="modal-param-rsi-period" class="form-control" value="14"></div>
          <div class="form-group"><label class="form-label">ATR Periyodu</label><input type="number" id="modal-param-atr-period" class="form-control" value="14"></div>
          <div class="form-group"><label class="form-label">Duvar Tespiti (BTC Miktarı)</label><input type="number" id="modal-param-wall-btc" class="form-control" value="20"></div>
          <div class="form-group"><label class="form-label">Risk/Ödül Oranı (R/R)</label><input type="number" id="modal-param-rr-ratio" class="form-control" value="1.5" step="0.1"></div>
        </div>
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">Cooldown Ayarları</div>
          <div class="form-group"><label class="form-label">Genel Sinyal Cooldown (ms)</label><input type="number" id="modal-signal-cooldown-ms" class="form-control" value="15000" min="0" step="100"></div>
          <div class="form-group"><label class="form-label">Aynı Yön Sinyal Cooldown (ms)</label><input type="number" id="modal-same-direction-cooldown-ms" class="form-control" value="30000" min="0" step="100"></div>
          <div class="form-group"><label class="form-label">Ters Yön Cooldown (ms)</label><input type="number" id="modal-opposite-direction-cooldown-ms" class="form-control" value="20000" min="0" step="100"></div>
          <div class="form-group"><label class="form-label">Ters Yön Histerezis (+Puan)</label><input type="number" id="modal-reverse-hysteresis-points" class="form-control" value="2" min="0" step="1"></div>
          <div class="form-group"><label class="form-label">Proposal Timeout (ms)</label><input type="number" id="modal-proposal-timeout-ms" class="form-control" value="3000" min="500" step="100"></div>
          <div class="form-group"><label class="form-label">Strateji Teklifi Cooldown (ms)</label><input type="number" id="modal-strategy-proposal-cooldown-ms" class="form-control" value="10000" min="0" step="100"></div>
        </div>
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">Aktif Stratejiler</div>
          <div id="modal-strategy-toggles"></div>
        </div>
        <div class="settings-group" style="grid-column: 1 / -1;">
          <div class="panel-title" style="margin-bottom: 10px;">Sinyal Geçmişi ve Analiz</div>
          <div class="data-table-container" style="max-height: 300px;">
            <table class="data-table">
              <thead>
                <tr>
                  <th>Zaman</th><th>Tip</th><th>Fiyat</th><th>TP</th><th>SL</th><th>Skor</th><th>Katkı</th><th>Durum</th>
                </tr>
              </thead>
              <tbody id="modal-signals-body"></tbody>
            </table>
          </div>
          <button id="modal-clear-signals-btn" class="btn btn-danger btn-sm" style="margin-top: 10px;">Tüm Sinyalleri Sil</button>
          <div id="modal-stats-container" style="margin-top: 15px;"></div>
        </div>
      </div>
      <div class="settings-modal-footer">
        <button id="reset-all-settings-btn" class="btn btn-danger">AYARLARI SIFIRLA</button>
        <button id="save-settings-btn" class="btn btn-success">AYARLARI KAYDET</button>
      </div>
    </div>
  </div>

  <!-- ŞEREF PANOSU MODAL -->
  <div id="board-modal-overlay">
    <div class="settings-modal-content">
      <div class="settings-modal-header">
        <span>ŞEREF PANOSU</span>
        <button class="close-btn" id="close-board-modal-btn">&times;</button>
      </div>
      <div class="settings-modal-body" style="grid-template-columns: 1fr 1fr 1fr;">
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">Şerefli</div>
          <div id="honor-list" class="data-table-container"></div>
        </div>
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">Şerefsizler</div>
          <div id="dishonor-list" class="data-table-container"></div>
        </div>
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">Banlılar</div>
          <div id="banned-list" class="data-table-container"></div>
        </div>
      </div>
    </div>
  </div>

<script>
  // Sinyal sesleri
  function playSignal(type) {
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      if (type === 'buy') {
        oscillator.type = 'triangle'; oscillator.frequency.value = 1000;
      } else if (type === 'sell') {
        oscillator.type = 'square'; oscillator.frequency.value = 400;
      } else if (type === 'combat') {
        oscillator.type = 'sawtooth'; oscillator.frequency.value = 800; 
        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);
        oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 1);
        return;
      }
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
      oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5);
    } catch (error) { console.log('Ses çalınamadı:', error); }
  }

  /* =========================
     GÖRSELLEŞTİRME YÖNETİCİLERİ
     ========================= */
  class ChartManager {
    constructor(chartContainerId) {
      this.chartContainer = document.getElementById(chartContainerId);
      if (!this.chartContainer) throw new Error("Chart container bulunamadı!");
      this.chart = null; this.series = {}; this.signalMarkers = [];
      this._initChart();
    }
    _initChart() {
      this.chart = LightweightCharts.createChart(this.chartContainer, this._getChartOptions());
      this.series.candles = this.chart.addCandlestickSeries(this._getCandlestickOptions());
      this.series.volume = this.chart.addHistogramSeries(this._getVolumeOptions());
      window.addEventListener('resize', () => { 
        if (this.chart && this.chartContainer.clientWidth > 0 && this.chartContainer.clientHeight > 0) {
          this.chart.resize(this.chartContainer.clientWidth, this.chartContainer.clientHeight);
        }
      });
    }
    updateTheme() {
      if(!this.chart) return;
      this.chart.applyOptions(this._getChartOptions());
      this.series.candles.applyOptions(this._getCandlestickOptions());
      this.series.volume.applyOptions(this._getVolumeOptions());
    }
    setData(candles) {
      if (!this.series.candles) return;
      const candleData = candles.map(c => ({ time: c.time / 1000, open: c.open, high: c.high, low: c.low, close: c.close }));
      const volumeData = candles.map(c => ({ time: c.time / 1000, value: c.volume, color: c.close >= c.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' }));
      this.series.candles.setData(candleData);
      this.series.volume.setData(volumeData);
      this.chart.timeScale().fitContent();
    }
    updateRealtime(kline) {
      if (!this.series.candles) return;
      const candle = { time: kline.t / 1000, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c) };
      const volume = { time: kline.t / 1000, value: parseFloat(kline.v), color: candle.close >= candle.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' };
      this.series.candles.update(candle);
      this.series.volume.update(volume);
    }
    addSignalMarker(signal) {
      if (!this.series.candles) return;
      const styles = getComputedStyle(document.body);
      const marker = {
        time: signal.timestamp / 1000,
        position: signal.direction === 'buy' ? 'belowBar' : 'aboveBar',
        color: signal.direction === 'buy' ? styles.getPropertyValue('--positive').trim() : styles.getPropertyValue('--negative').trim(),
        shape: signal.direction === 'buy' ? 'arrowUp' : 'arrowDown',
        text: `Skor: ${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score} @ ${this._formatMarkerPrice(signal.price)}`
      };
      this.signalMarkers.push(marker);
      this.series.candles.setMarkers(this.signalMarkers);
    }
    clearMarkers() { if (!this.series.candles) return; this.signalMarkers = []; this.series.candles.setMarkers([]); }
    zoom(factor) {
      if (!this.chart) return;
      const timeScale = this.chart.timeScale();
      const currentLogicalRange = timeScale.getVisibleLogicalRange();
      if (!currentLogicalRange) return;
      const newLogicalRange = { from: currentLogicalRange.from * factor, to: currentLogicalRange.to * factor };
      timeScale.setVisibleLogicalRange(newLogicalRange);
    }
    zoomIn() { this.zoom(0.9); }
    zoomOut() { this.zoom(1.1); }
    resetZoom() { if (this.chart) this.chart.timeScale().fitContent(); }

    _getDecimalPlacesBasedOnPrice(price) { if(!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
    _formatMarkerPrice(price) { const d = this._getDecimalPlacesBasedOnPrice(price); return price.toFixed(d); }
    _getChartOptions() {
      const styles = getComputedStyle(document.body);
      return {
        width: this.chartContainer.clientWidth, height: this.chartContainer.clientHeight,
        layout: { backgroundColor: 'transparent', textColor: styles.getPropertyValue('--text-main').trim(), fontFamily: "'Roboto Mono', monospace" },
        grid: { vertLines: { color: styles.getPropertyValue('--border-color').trim() }, horzLines: { color: styles.getPropertyValue('--border-color').trim() } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        timeScale: { borderColor: styles.getPropertyValue('--border-color').trim(), timeVisible: true, secondsVisible: false, rightOffset: 10 }
      };
    }
    _getCandlestickOptions() {
      const styles = getComputedStyle(document.body);
      return { 
        upColor: styles.getPropertyValue('--positive').trim(), downColor: styles.getPropertyValue('--negative').trim(),
        borderVisible: false, wickUpColor: styles.getPropertyValue('--positive').trim(), wickDownColor: styles.getPropertyValue('--negative').trim(),
        priceFormat: { type: 'price', precision: 6, minMove: 0.000001 }
      };
    }
    _getVolumeOptions() { return { priceFormat: { type: 'volume' }, priceScaleId: '', scaleMargins: { top: 0.8, bottom: 0 } }; }
  }

  class HeatmapManager {
    constructor(canvasId) {
      this.canvas = document.getElementById(canvasId);
      if (!this.canvas) throw new Error("Heatmap canvas bulunamadı!");
      this.ctx = this.canvas.getContext('2d');
      this._resizeCanvas();
      window.addEventListener('resize', () => this._resizeCanvas());
    }
    draw(orderBook, symbolPrice) {
      if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); return; };
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      const asks = orderBook.asks.slice().reverse(); const bids = orderBook.bids;
      const allLevels = [...bids, ...asks]; const maxQty = Math.max(...allLevels.map(l => l[1]));
      this._drawSection(asks, 'asks', maxQty, symbolPrice); this._drawSection(bids, 'bids', maxQty, symbolPrice);
    }
    updateTheme() { this._resizeCanvas(); }
    _drawSection(levels, type, maxQty, symbolPrice) {
      const styles = getComputedStyle(document.body);
      const baseColor = type === 'asks' ? styles.getPropertyValue('--negative').trim() : styles.getPropertyValue('--positive').trim();
      if (levels.length === 0) return;
      const heightPerLevel = (this.canvas.height / 2) / levels.length;
      const priceDecimals = this._getDecimalPlaces(symbolPrice);
      const labelSkipInterval = heightPerLevel < 12 ? Math.ceil(12 / heightPerLevel) : 1;
      levels.forEach((level, index) => {
        const [price, qty] = level;
        const intensity = Math.min(Math.sqrt(qty / maxQty), 1.0);
        this.ctx.fillStyle = this._hexToRgba(baseColor, intensity * 0.6 + 0.1);
        const y = type === 'asks' ? index * heightPerLevel : (this.canvas.height / 2) + (index * heightPerLevel);
        const barWidth = this.canvas.width * intensity;
        this.ctx.fillRect(0, y, barWidth, heightPerLevel);
        if (index % labelSkipInterval === 0) {
          this.ctx.fillStyle = intensity > 0.5 ? '#FFFFFF' : styles.getPropertyValue('--text-secondary').trim();
          this.ctx.font = '10px "Roboto Mono"'; this.ctx.textAlign = 'left';
          this.ctx.fillText(`${(qty).toFixed(2)} @ ${price.toFixed(priceDecimals)}`, 10, y + heightPerLevel - 3);
        }
      });
    }
    _getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
    _hexToRgba(hex, alpha) {
      if(!hex.startsWith('#')) return `rgba(120,120,120,${alpha})`;
      let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    _resizeCanvas() { 
      if(this.canvas.parentElement) {
        this.canvas.width = this.canvas.parentElement.clientWidth; 
        this.canvas.height = this.canvas.parentElement.clientHeight; 
      }
    }
  }

  /* =========================
     STRATEJİLER (dinamik skorlu)
     ========================= */
  class Strategy {
    constructor(bot, name) { 
      this.bot = bot; this.name = name; this.displayName = this._getDisplayName(name); 
      this.lastProposalTime = {};
      this.DEFAULT_PROPOSAL_COOLDOWN_MS = 10000; // dynamic baseline
    }
    propose(symbol, direction, reason, score) {
      const now = Date.now(); 
      const key = `${symbol}-${direction}`;
      const cooldown = (this.DEFAULT_PROPOSAL_COOLDOWN_MS ?? 10000);
      if (now - (this.lastProposalTime[key] || 0) < cooldown) return;

      // Shadow: arkaplanda paper trade kaydı
      if (this.bot?.isShadowed?.(this.name) && this.bot.marketData?.price) {
        this.bot.recordPaperProposal(this.name, direction, this.bot.marketData.price);
      }

      this.bot.confluenceEngine.propose(this.name, direction, reason, score);
      this.lastProposalTime[key] = now;
    }
    _getDisplayName(name) { return name.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()); }
    analyzeOrderBook(orderBook) {}
    processTrade(trade) {}
    periodicAnalyze() {}
  }

  class WallBounceStrategy extends Strategy {
    constructor(bot) { super(bot, 'wallBounce'); this.DISTANCE_THRESHOLD_PERCENT = 0.05 / 100; }
    analyzeOrderBook(orderBook) {
      const currentPrice = this.bot.marketData.price; if (!currentPrice) return;
      const btcPrice = this.bot.marketData.btcPrice || 70000;
      const wallQuantityThreshold = (this.bot.settings.params.wallBtc * btcPrice) / currentPrice;
      for (const [price, qty] of orderBook.asks) { 
        if (qty > wallQuantityThreshold) { 
          const distance = (price - currentPrice) / currentPrice; 
          if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
            const strength = Math.min(10, 2 + (wallQuantityThreshold > 0 ? (qty / wallQuantityThreshold) : 0));
            this.propose(this.bot.currentSymbol, 'sell', `Satış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, strength); return; 
          } 
        } 
      }
      for (const [price, qty] of orderBook.bids) { 
        if (qty > wallQuantityThreshold) { 
          const distance = (currentPrice - price) / currentPrice; 
          if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
            const strength = Math.min(10, 2 + (wallQuantityThreshold > 0 ? (qty / wallQuantityThreshold) : 0));
            this.propose(this.bot.currentSymbol, 'buy', `Alış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, strength); return; 
          } 
        } 
      }
    }
  }
  class VelocityScalpingStrategy extends Strategy {
    constructor(bot) { super(bot, 'velocityScalping'); this.pricePoints = []; this.VELOCITY_WINDOW_MS = 2000; this.MIN_POINTS = 20; this.VELOCITY_THRESHOLD_PERCENT = 0.10 / 100; }
    processTrade(trade) {
      const now = Date.now(); 
      this.pricePoints.push({ time: now, price: trade.price }); 
      this.pricePoints = this.pricePoints.filter(p => now - p.time < this.VELOCITY_WINDOW_MS); 
      if (this.pricePoints.length < this.MIN_POINTS) return;
      const firstPoint = this.pricePoints[0]; const lastPoint = this.pricePoints[this.pricePoints.length - 1]; 
      const priceChange = (lastPoint.price - firstPoint.price) / firstPoint.price;
      const intensity = Math.min(1, Math.abs(priceChange) / this.VELOCITY_THRESHOLD_PERCENT);
      const strength = Math.min(10, 2 + intensity * 8);
      if (priceChange > this.VELOCITY_THRESHOLD_PERCENT) { 
        this.propose(this.bot.currentSymbol, 'buy', `Fiyat Hızı: +${(priceChange * 100).toFixed(2)}%`, strength); this.pricePoints = []; 
      } else if (priceChange < -this.VELOCITY_THRESHOLD_PERCENT) { 
        this.propose(this.bot.currentSymbol, 'sell', `Fiyat Hızı: ${(priceChange * 100).toFixed(2)}%`, strength); this.pricePoints = []; 
      }
    }
  }
  class RsiDivergenceStrategy extends Strategy {
    constructor(bot) { super(bot, 'rsiDivergence'); }
    periodicAnalyze() {
      const candles = this.bot.candles; const rsiValues = this.bot.indicators.rsi; const lookback = this.bot.settings.params.rsiPeriod;
      if (!rsiValues || rsiValues.length < lookback || !candles || candles.length < lookback) return;
      const lastCandle = candles[candles.length - 1]; const prevCandle = candles[candles.length - lookback]; 
      const lastRsi = rsiValues[rsiValues.length - 1]; const prevRsi = rsiValues[rsiValues.length - lookback];
      if (!lastCandle || !prevCandle || !isFinite(lastRsi) || !isFinite(prevRsi)) return;

      const swingPct = Math.abs((lastCandle.close - prevCandle.close) / Math.max(1e-8, prevCandle.close));
      const rsiGap = Math.abs((lastRsi - prevRsi) / 100);
      const strength = Math.max(0, Math.min(10, (rsiGap * 6 + swingPct * 50)));

      if (lastCandle.high > prevCandle.high && lastRsi < prevRsi) { this.propose(this.bot.currentSymbol, 'sell', 'RSI Ayı Uyuşmazlığı', strength); }
      if (lastCandle.low < prevCandle.low && lastRsi > prevRsi) { this.propose(this.bot.currentSymbol, 'buy', 'RSI Boğa Uyuşmazlığı', strength); }
    }
  }
  class OrderFlowMomentumStrategy extends Strategy {
    constructor(bot) { super(bot, 'orderFlowMomentum'); this.trades = []; this.WINDOW_MS = 5000; }
    processTrade(trade) {
      const now = Date.now(); 
      this.trades.push(trade); 
      this.trades = this.trades.filter(t => now - t.timestamp < this.WINDOW_MS); 
      if (this.trades.length < 50) return;
      const buys = this.trades.filter(t => !t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0); 
      const sells = this.trades.filter(t => t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0);
      const total = buys + sells; if (total === 0) return; 
      const ratio = Math.abs(buys - sells) / total; // 0..1
      const strength = Math.min(10, 2 + ratio * 8);
      if (buys / total > 0.7) { this.propose(this.bot.currentSymbol, 'buy', `Alıcı Akışı: %${(buys / total * 100).toFixed(0)}`, strength); this.trades = []; }
      else if (sells / total > 0.7) { this.propose(this.bot.currentSymbol, 'sell', `Satıcı Akışı: %${(sells / total * 100).toFixed(0)}`, strength); this.trades = []; }
    }
  }
  class LiquidityGapsStrategy extends Strategy {
    constructor(bot) { super(bot, 'liquidityGaps'); this.GAP_THRESHOLD_PERCENT = 0.1 / 100; }
    analyzeOrderBook(orderBook) {
      for (let i = 0; i < orderBook.asks.length - 1; i++) { 
        const gap = orderBook.asks[i + 1][0] - orderBook.asks[i][0]; 
        if ((gap / orderBook.asks[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
          const strength = Math.min(10, 2 + (gap / orderBook.asks[i][0]) * 300);
          this.propose(this.bot.currentSymbol, 'buy', `Likidite Boşluğu ${orderBook.asks[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.asks[i][0]))}`, strength); return; 
        } 
      }
      for (let i = 0; i < orderBook.bids.length - 1; i++) { 
        const gap = orderBook.bids[i][0] - orderBook.bids[i + 1][0]; 
        if ((gap / orderBook.bids[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
          const strength = Math.min(10, 2 + (gap / orderBook.bids[i][0]) * 300);
          this.propose(this.bot.currentSymbol, 'sell', `Likidite Boşluğu ${orderBook.bids[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.bids[i][0]))}`, strength); return; 
        } 
      }
    }
  }
  class BreakoutPatternStrategy extends Strategy {
    constructor(bot) { super(bot, 'breakoutPattern'); this.LOOKBACK = 30; this.VOL_SPIKE = 1.4; this.BREAK_PCT = 0.03/100; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < this.LOOKBACK + 1) return;
      const recent = c.slice(-this.LOOKBACK-1);
      const highs = recent.map(x=>x.high), lows = recent.map(x=>x.low), vols = recent.map(x=>x.volume);
      const last = recent[recent.length-1]; 
      const maxH = Math.max(...highs.slice(0, -1)); const minL = Math.min(...lows.slice(0, -1));
      const volSma = vols.slice(0, -1).reduce((a,b)=>a+b,0) / (vols.length-1);
      const volIntensity = Math.min(1.5, last.volume / Math.max(1e-8, volSma));
      const strength = Math.min(10, 2 + (volIntensity-1) * 10);
      if (last.close > maxH * (1 + this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
        this.propose(this.bot.currentSymbol, 'buy', 'Aralık Üstü Hacimli Kırılım', strength);
      } else if (last.close < minL * (1 - this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
        this.propose(this.bot.currentSymbol, 'sell', 'Aralık Altı Hacimli Kırılım', strength);
      }
    }
  }
  class SupportResistanceStrategy extends Strategy {
    constructor(bot) { super(bot, 'supportResistance'); this.LOOKBACK = 60; this.THRESH = 0.15/100; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
      const slice = c.slice(-this.LOOKBACK);
      const last = slice[slice.length-1];
      const maxH = Math.max(...slice.map(x=>x.high)); const minL = Math.min(...slice.map(x=>x.low));
      const distTop = (maxH - last.close)/last.close; const distBot = (last.close - minL)/last.close;
      const proximity = 1 - Math.min(1, Math.min(distTop, distBot) / this.THRESH);
      const strength = Math.min(10, 2 + Math.max(0, proximity) * 8);
      if (distTop >= 0 && distTop < this.THRESH && last.close < last.open) {
        this.propose(this.bot.currentSymbol, 'sell', 'Direnç Bölgesi Reddi', strength);
      }
      if (distBot >= 0 && distBot < this.THRESH && last.close > last.open) {
        this.propose(this.bot.currentSymbol, 'buy', 'Destek Bölgesi Tepkisi', strength);
      }
    }
  }
  class FibonacciRetracementStrategy extends Strategy {
    constructor(bot) { super(bot, 'fibonacciRetracement'); this.LOOKBACK = 120; this.TOL = 0.2/100; this.levels = [0.382, 0.5, 0.618]; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
      const slice = c.slice(-this.LOOKBACK);
      let high = -Infinity, low = Infinity, hT=0, lT=0;
      slice.forEach(k => { if(k.high > high){high=k.high; hT=k.time;} if(k.low < low){low=k.low; lT=k.time;} });
      if (!isFinite(high) || !isFinite(low) || high===low) return;
      const last = slice[slice.length-1];
      if (hT > lT) { // uptrend: low -> high
        const retr = (high - last.close) / (high - low);
        for (const L of this.levels) {
          if (Math.abs(retr - L) < this.TOL) { 
            const strength = Math.min(10, 2 + (this.TOL - Math.abs(retr - L)) * 2000);
            this.propose(this.bot.currentSymbol, 'buy', `Fibo ${Math.round(L*100)}% Bölgesi`, strength); break; 
          }
        }
      } else { // downtrend: high -> low
        const retr = (last.close - low) / (high - low);
        for (const L of this.levels) {
          if (Math.abs(retr - L) < this.TOL) { 
            const strength = Math.min(10, 2 + (this.TOL - Math.abs(retr - L)) * 2000);
            this.propose(this.bot.currentSymbol, 'sell', `Fibo ${Math.round(L*100)}% Bölgesi`, strength); break; 
          }
        }
      }
    }
  }
  class VolumeProfileStrategy extends Strategy {
    constructor(bot) { super(bot, 'volumeProfile'); this.PERIOD = 20; this.SPIKE = 2.0; this.CLOSE_POS = 0.7; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < this.PERIOD + 1) return;
      const last = c[c.length-1];
      const vols = c.slice(-this.PERIOD-1, -1).map(x=>x.volume);
      const volSma = vols.reduce((a,b)=>a+b,0)/vols.length;
      const posUp = (last.close - last.low) / Math.max(1e-8,(last.high - last.low));
      const posDn = (last.high - last.close) / Math.max(1e-8,(last.high - last.low));
      const intensity = Math.min(2, last.volume / Math.max(1e-8, volSma));
      const strength = Math.min(10, 2 + (intensity-1)*8);
      if (last.volume > volSma * this.SPIKE && posUp > this.CLOSE_POS) {
        this.propose(this.bot.currentSymbol, 'buy', 'Hacim Spike - Üst Kapanış', strength);
      } else if (last.volume > volSma * this.SPIKE && posDn > this.CLOSE_POS) {
        this.propose(this.bot.currentSymbol, 'sell', 'Hacim Spike - Alt Kapanış', strength);
      }
    }
  }
  class SmartMoneyConceptsStrategy extends Strategy {
    constructor(bot) { super(bot, 'smartMoneyConcepts'); this.GAP_MIN_PCT = 0.05/100; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < 3) return;
      const a = c[c.length-3], b = c[c.length-2], d = c[c.length-1];
      if ((d.low - a.high)/Math.max(1e-8, d.low) > this.GAP_MIN_PCT) this.propose(this.bot.currentSymbol, 'buy', 'Bullish FVG', 4);
      if ((a.low - d.high)/Math.max(1e-8, d.high) > this.GAP_MIN_PCT) this.propose(this.bot.currentSymbol, 'sell', 'Bearish FVG', 4);
    }
  }
  class DivergenceDetectionStrategy extends Strategy {
    constructor(bot) { super(bot, 'divergenceDetection'); this.LOOKBACK = 40; this.SWING = 3; }
    periodicAnalyze() {
      const c = this.bot.candles; const rsi = this.bot.indicators.rsi; 
      if (!rsi || c.length < this.LOOKBACK || rsi.length < this.LOOKBACK) return;
      const slice = c.slice(-this.LOOKBACK), r = rsi.slice(-this.LOOKBACK);
      const pivLows = []; const pivHighs = [];
      for (let i = this.SWING; i < slice.length - this.SWING; i++) {
        if (slice[i].low < Math.min(...slice.slice(i-this.SWING, i).map(x=>x.low)) && slice[i].low < Math.min(...slice.slice(i+1, i+1+this.SWING).map(x=>x.low))) pivLows.push(i);
        if (slice[i].high > Math.max(...slice.slice(i-this.SWING, i).map(x=>x.high)) && slice[i].high > Math.max(...slice.slice(i+1, i+1+this.SWING).map(x=>x.high))) pivHighs.push(i);
      }
      if (pivLows.length >= 2) {
        const i1 = pivLows[pivLows.length-2], i2 = pivLows[pivLows.length-1];
        const strength = Math.min(10, 2 + Math.abs(r[i2] - r[i1]) / 10);
        if (slice[i2].low < slice[i1].low && r[i2] > r[i1]) this.propose(this.bot.currentSymbol, 'buy', 'Bullish RSI Divergence (Pivot)', strength);
      }
      if (pivHighs.length >= 2) {
        const i1 = pivHighs[pivHighs.length-2], i2 = pivHighs[pivHighs.length-1];
        const strength = Math.min(10, 2 + Math.abs(r[i2] - r[i1]) / 10);
        if (slice[i2].high > slice[i1].high && r[i2] < r[i1]) this.propose(this.bot.currentSymbol, 'sell', 'Bearish RSI Divergence (Pivot)', strength);
      }
    }
  }
  class MarketStructureStrategy extends Strategy {
    constructor(bot) { super(bot, 'marketStructure'); this.SWING = 3; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < 2*this.SWING+5) return;
      const pivotHighs = [], pivotLows = [];
      for (let i = this.SWING; i < c.length - this.SWING; i++) {
        if (c[i].high > Math.max(...c.slice(i-this.SWING, i).map(x=>x.high)) && c[i].high > Math.max(...c.slice(i+1, i+1+this.SWING).map(x=>x.high))) pivotHighs.push(i);
        if (c[i].low < Math.min(...c.slice(i-this.SWING, i).map(x=>x.low)) && c[i].low < Math.min(...c.slice(i+1, i+1+this.SWING).map(x=>x.low))) pivotLows.push(i);
      }
      const last = c[c.length-1];
      const lastPH = pivotHighs.length ? c[pivotHighs[pivotHighs.length-1]].high : null;
      const lastPL = pivotLows.length ? c[pivotLows[pivotLows.length-1]].low : null;
      if (lastPH && last.close > lastPH) this.propose(this.bot.currentSymbol, 'buy', 'Yapı Kırılımı (BOS Up)', 4);
      if (lastPL && last.close < lastPL) this.propose(this.bot.currentSymbol, 'sell', 'Yapı Kırılımı (BOS Down)', 4);
    }
  }
  class InstitutionalOrderFlowStrategy extends Strategy {
    constructor(bot) { super(bot, 'institutionalOrderFlow'); this.TOP_N = 5; this.IMB_THRESHOLD = 2.0; }
    analyzeOrderBook(orderBook) {
      if (!orderBook.bids.length || !orderBook.asks.length) return;
      const topB = orderBook.bids.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
      const topA = orderBook.asks.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
      const ratio = Math.max(topB, topA) / Math.max(1e-8, Math.min(topB, topA));
      const strength = Math.min(10, 2 + (ratio-1) * 4);
      if (topB / Math.max(1e-8, topA) > this.IMB_THRESHOLD) {
        this.propose(this.bot.currentSymbol, 'buy', 'Orderbook İmbalansı (Bid Ağırlık)', strength);
      } else if (topA / Math.max(1e-8, topB) > this.IMB_THRESHOLD) {
        this.propose(this.bot.currentSymbol, 'sell', 'Orderbook İmbalansı (Ask Ağırlık)', strength);
      }
    }
  }
  class MicroSpreadArbitrageStrategy extends Strategy {
    constructor(bot) { super(bot, 'microSpreadArbitrage'); this.SPREAD_PCT = 0.08/100; }
    analyzeOrderBook(orderBook) {
      if (!orderBook.bids.length || !orderBook.asks.length) return;
      const bestBid = orderBook.bids[0][0], bestAsk = orderBook.asks[0][0];
      const mid = (bestAsk + bestBid)/2;
      const spreadPct = (bestAsk - bestBid) / mid;
      if (spreadPct > this.SPREAD_PCT) {
        const current = this.bot.marketData.price || mid;
        const strength = Math.min(10, 2 + (spreadPct / this.SPREAD_PCT - 1) * 3);
        if (current < mid) this.propose(this.bot.currentSymbol, 'buy', 'Geniş Spread - Mean Reversion', strength);
        else this.propose(this.bot.currentSymbol, 'sell', 'Geniş Spread - Mean Reversion', strength);
      }
    }
  }
  class VWAPReversionStrategy extends Strategy {
    constructor(bot) { super(bot, 'vwapReversion'); this.MULT = 1.0; }
    periodicAnalyze() {
      const price = this.bot.marketData.price, vwap = this.bot.indicators.vwap, atr = this.bot.indicators.atr;
      if (!price || !vwap || !atr) return;
      const dev = atr / price; 
      const diffPct = (price - vwap) / vwap;
      const intensity = Math.abs(diffPct) / Math.max(1e-8, this.MULT * dev);
      const strength = Math.min(10, 2 + Math.min(1, intensity) * 8);
      if (diffPct > this.MULT * dev) this.propose(this.bot.currentSymbol, 'sell', 'VWAP Üstü Aşırı Sapma', strength);
      if (diffPct < -this.MULT * dev) this.propose(this.bot.currentSymbol, 'buy', 'VWAP Altı Aşırı Sapma', strength);
    }
  }
  class SuperTrendStrategy extends Strategy {
    constructor(bot) { super(bot, 'superTrend'); this.MULT = 3.0; this.PERIOD = 14; }
    periodicAnalyze() {
      const c = this.bot.candles; const atr = this.bot.indicators.atr;
      if (!atr || c.length < 2) return;
      const last = c[c.length-1];
      const m = (last.high + last.low) / 2;
      const upper = m + this.MULT * atr, lower = m - this.MULT * atr;
      const delta = Math.abs(last.close - m) / Math.max(1e-8, atr * this.MULT);
      const strength = Math.min(10, 2 + Math.min(1, delta) * 8);
      if (last.close > upper) this.propose(this.bot.currentSymbol, 'buy', 'ATR Kanal Üstü Kırılım (SuperTrend)', strength);
      else if (last.close < lower) this.propose(this.bot.currentSymbol, 'sell', 'ATR Kanal Altı Kırılım (SuperTrend)', strength);
    }
  }

  /* =========================
     UYUM MOTORU (CONFLUENCE) + shadow/muted
     ========================= */
  class ConfluenceEngine {
    constructor(bot) { 
      this.bot = bot; 
      this.proposals = []; 
      this.lastSignalTime = 0; 
      this.lastSignalTimeByDirection = { buy: 0, sell: 0 };
      this.lastDirection = null;
    }
    propose(strategy, direction, reason, score) {
      const now = Date.now();
      this.proposals = this.proposals.filter(p => !(p.strategy === strategy));
      this.proposals.push({ strategy, direction, reason, score, timestamp: now, muted: this.bot.isShadowed(strategy) });
      const s = this.bot.strategyStats[strategy] || { alpha:3, beta:2, proposals:0, contrib:0, wins:0, losses:0, lastUpdate: now };
      s.proposals += 1; s.lastUpdate = now; this.bot.strategyStats[strategy] = s; this.bot.saveStrategyStats();
      this.checkConfluence();
    }

    _computeDirectional(direction) {
      const now = Date.now();
      const decaySec = this.bot.settings.optimization.timeDecaySec || 3;
      const groupSums = { trending: 0, meanReversion: 0, neutral: 0 };
      const used = [];
      const arr = this.proposals.filter(p => p.direction === direction);

      for (const p of arr) {
        const w = this.bot.getStrategyWeight(p.strategy);
        const ageSec = (now - p.timestamp)/1000;
        const decay = Math.exp(-ageSec / decaySec);
        let eff = (p.score || 0) * w * decay;

        if (p.muted) {
          const strong = (p.score || 0) >= (this.bot.shadowConfig?.strongScore || 7.5);
          const factor = strong ? 1.0 : (this.bot.shadowConfig?.factor || 0.15);
          eff *= factor;
        }

        const grp = this.bot.getStrategyGroup(p.strategy);
        groupSums[grp] = (groupSums[grp] || 0) + eff;
        used.push({ strategy: p.strategy, baseScore: p.score, weight: w, decay, effScore: eff, muted: !!p.muted });
      }
      const score = Math.sqrt(Math.max(0, groupSums.trending)**2 + Math.max(0, groupSums.meanReversion)**2 + Math.max(0, groupSums.neutral)**2);
      return { score, contributors: used, groupSums };
    }

    checkConfluence() {
      const now = Date.now();
      const cd = this.bot.settings?.cooldowns || {};
      const proposalTimeout = cd.proposalTimeoutMs ?? 3000;
      const signalCooldown = cd.signalMs ?? 15000;
      const sameDirCooldown = cd.sameDirectionMs ?? 30000;
      const oppCooldown = cd.oppositeDirectionMs ?? 20000;
      const reverseHys = cd.reverseHysteresisPoints ?? 2;
      const dirMargin = this.bot.settings.optimization.dirMargin ?? 0.5;
      const minThreshold = this.bot.getEffectiveThreshold();

      if (now - this.lastSignalTime < signalCooldown) return;
      this.proposals = this.proposals.filter(p => now - p.timestamp < proposalTimeout);

      const buy = this._computeDirectional('buy');
      const sell = this._computeDirectional('sell');

      // Penalties (market + HTF)
      const buyPenalty = this.bot.marketGatingPenalty('buy') + this.bot.getHTFPenalty('buy');
      const sellPenalty = this.bot.marketGatingPenalty('sell') + this.bot.getHTFPenalty('sell');

      // Probability gating via online logistic classifier
      const feats = this.bot.buildFeatures(buy, sell);
      const pTP = this.bot.classifier ? this.bot.classifier.predict(feats) : 0.55;
      const pThresh = this.bot.settings.optimization.probThreshold || 0.55;

      let chosen = null;
      if (buy.score >= (minThreshold + buyPenalty) && (buy.score > sell.score + dirMargin)) {
        if (now - this.lastSignalTimeByDirection.buy < sameDirCooldown) return;
        if (this.lastDirection === 'sell' && (now - this.lastSignalTime) < oppCooldown) {
          if (buy.score < (minThreshold + buyPenalty + reverseHys)) return;
        }
        chosen = { dir: 'buy', obj: buy };
      } else if (sell.score >= (minThreshold + sellPenalty) && (sell.score > buy.score + dirMargin)) {
        if (now - this.lastSignalTimeByDirection.sell < sameDirCooldown) return;
        if (this.lastDirection === 'buy' && (now - this.lastSignalTime) < oppCooldown) {
          if (sell.score < (minThreshold + sellPenalty + reverseHys)) return;
        }
        chosen = { dir: 'sell', obj: sell };
      } else {
        return;
      }

      // Probability threshold
      if (pTP < pThresh) return;

      this.generateFinalSignal(chosen.dir, chosen.obj.contributors, feats, pTP);
    }

    generateFinalSignal(direction, contributors, features, prob) {
      const contributingStrats = contributors.map(c => this.bot.strategies[c.strategy]?.displayName || c.strategy).join(', ');
      const weightedScore = contributors.reduce((s,c)=> s + c.effScore, 0);

      const signal = { 
        id: `sig_${Date.now()}`, timestamp: Date.now(), symbol: this.bot.currentSymbol, 
        direction, price: this.bot.marketData.price, score: weightedScore, 
        reason: contributingStrats, contributors, status: 'active', note: '',
        mfeR: 0, beDone: false, trailingStage: 0, features, prob: prob
      };
      this.bot.calculateDynamicTpSl(signal);
      this.bot.addFinalSignal(signal);

      this.proposals = [];
      const now = Date.now();
      this.lastSignalTime = now;
      this.lastSignalTimeByDirection[direction] = now;
      this.lastDirection = direction;
    }
  }

  /* =========================
     ÇEVRİM İÇİ LOJİSTİK SINIFLANDIRICI
     ========================= */
  class OnlineLogit {
    constructor(bot){ this.bot = bot; this.key='utc_logit'; this.model = this.bot.loadData(this.key) || { w: [] }; }
    sigmoid(z){ return 1/(1+Math.exp(-z)); }
    predict(feat){ const w=this.model.w; let z=0; for(let i=0;i<feat.length;i++){ z += (w[i]||0)*feat[i]; } return this.sigmoid(z); }
    update(y, feat, lr=0.05, l2=1e-4){
      const p = this.predict(feat);
      const w = this.model.w.length ? this.model.w : Array(feat.length).fill(0);
      for(let i=0;i<feat.length;i++){
        const grad = (p - y)*feat[i] + l2*w[i];
        w[i] = w[i] - lr*grad;
      }
      this.model.w = w; this.bot.saveData(this.key, this.model);
    }
  }

  /* =========================
     ANA UYGULAMA
     ========================= */
  class UltimateTradingCommandCenter {
    constructor() {
      this.allStrategiesMap = {
        'wallBounce': WallBounceStrategy, 'velocityScalping': VelocityScalpingStrategy, 'rsiDivergence': RsiDivergenceStrategy, 
        'orderFlowMomentum': OrderFlowMomentumStrategy, 'liquidityGaps': LiquidityGapsStrategy, 'fibonacciRetracement': FibonacciRetracementStrategy, 
        'volumeProfile': VolumeProfileStrategy, 'smartMoneyConcepts': SmartMoneyConceptsStrategy, 'divergenceDetection': DivergenceDetectionStrategy, 
        'breakoutPattern': BreakoutPatternStrategy, 'supportResistance': SupportResistanceStrategy, 'marketStructure': MarketStructureStrategy, 
        'institutionalOrderFlow': InstitutionalOrderFlowStrategy, 'microSpreadArbitrage': MicroSpreadArbitrageStrategy,
        'vwapReversion': VWAPReversionStrategy, 'superTrend': SuperTrendStrategy
      };
      this.allStrategyKeys = Object.keys(this.allStrategiesMap); 

      this.isRunning = false; 
      this.sockets = {}; 
      
      this.currentSymbol = this.loadData('utc_current_symbol') || 'BTCUSDT'; 
      this.currentTimeframe = this.loadData('utc_current_timeframe') || '15m';
      this.headerCollapsed = this.loadData('utc_header_collapsed') !== null ? (this.loadData('utc_header_collapsed') === 'true') : true; 
      this.currentMainView = this.loadData('utc_current_view') || 'chart';

      this.marketData = {}; 
      this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 
      this.aggTrades = []; 
      this.candles = [];
      this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null }; 
      this.signals = this.loadData('utc_signals') || [];
      this.stats = this.loadData('utc_stats') || { total: 0, tp: 0, sl: 0 };

      // Performans öğrenme
      this.strategyStats = this.loadData('utc_strategy_stats') || this.initDefaultStrategyStats();
      this.ctxStats = this.loadData('utc_ctx_stats') || {};
      this.marketRegime = 'unknown';
      this.strategyGroups = {
        trending: ['breakoutPattern','orderFlowMomentum','marketStructure','volumeProfile','smartMoneyConcepts','superTrend'],
        meanReversion: ['vwapReversion','wallBounce','liquidityGaps','fibonacciRetracement','supportResistance','microSpreadArbitrage','divergenceDetection','rsiDivergence','institutionalOrderFlow']
      };
      
      // Shadowban & paper eval
      this.shadow = this.loadData('utc_shadow') || { byStrategy: {} };
      this.paperEval = { queue: [] };
      this.shadowConfig = {
        factor: 0.15,
        strongScore: 7.5,
        probationWinsNeeded: 4,
        probationWindow: 8,
        lookaheadMs: 15*60*1000,
        paperR: 0.5,
        banDurMs: 60*60*1000
      };

      this.settings = this.loadSettings();
      this.strategies = {};
      
      this.combatModeActive = false;
      this.reconnectAttempts = 0;
      this.reconnectDelay = 3000;
      this.chartManager = new ChartManager('live-chart');
      this.heatmapManager = new HeatmapManager('orderbook-heatmap');
      this.confluenceEngine = new ConfluenceEngine(this);
      this.classifier = new OnlineLogit(this);

      this.renderInterval = null; 
      this.analysisInterval = null;
      this.cooldownTuneInterval = null;
      this.thresholdTuneInterval = null;
      this._paperTimer = null;
      this._honorTimer = null;
      this._htfTimer = null;
      this.lastAutoToggleTs = 0;
      this.runtimeThresholdOffset = 0;
      this.riskState = 'neutral';
      this.htfTrend = 'flat';

      this.init();
    }

    initDefaultStrategyStats() {
      const stats = {};
      (this.allStrategyKeys || []).forEach(k => {
        stats[k] = { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0, lastUpdate: Date.now() };
      });
      return stats;
    }
    saveStrategyStats() { this.saveData('utc_strategy_stats', this.strategyStats); }
    saveCtxStats() { this.saveData('utc_ctx_stats', this.ctxStats); }

    getStrategyGroup(key) {
      if (this.strategyGroups.trending.includes(key)) return 'trending';
      if (this.strategyGroups.meanReversion.includes(key)) return 'meanReversion';
      return 'neutral';
    }
    getGroupBoost(key) {
      const grp = this.getStrategyGroup(key);
      let boost = 1.0;
      // Rejim boost
      if (this.marketRegime === 'trend' && grp === 'trending') boost *= 1.15;
      if (this.marketRegime === 'range' && grp === 'meanReversion') boost *= 1.15;
      // ATR göre adaptif boost
      const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0;
      if (atrPct < 0.005) { // düşük vol
        if (grp === 'trending') boost *= 0.9;
        if (grp === 'meanReversion') boost *= 1.05;
      } else if (atrPct > 0.02) { // yüksek vol
        if (grp === 'trending') boost *= 1.05;
        if (grp === 'meanReversion') boost *= 0.95;
      }
      return boost;
    }

    // Bağlamsal anahtar
    getContextKey() {
      const regime = this.marketRegime || 'unknown';
      const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0;
      const volBucket = atrPct < 0.005 ? 'vlow' : atrPct < 0.012 ? 'low' : atrPct < 0.02 ? 'mid' : 'high';
      const ob = this.getOrderBookSnapshotInfo() || {};
      const liqBucket = (ob.minTopUsd || 0) < 5e4 ? 'thin' : (ob.minTopUsd < 2e5 ? 'mid' : 'deep');
      return `${regime}|${volBucket}|${liqBucket}|${this.currentTimeframe}`;
    }

    getStrategyWeight(name) {
      const global = this.strategyStats[name] || { alpha:3, beta:2 };
      const ctxKey = this.getContextKey();
      const ctxForStrat = (this.ctxStats[name] && this.ctxStats[name][ctxKey]) || null;
      const pick = ctxForStrat || global;
      const mean = pick.alpha / (pick.alpha + pick.beta);
      const variance = (pick.alpha * pick.beta) / (Math.pow(pick.alpha + pick.beta, 2) * (pick.alpha + pick.beta + 1));
      const uncertaintyPenalty = Math.max(0.75, 1 - Math.sqrt(variance) * 3);
      let w = (0.5 + mean) * uncertaintyPenalty;
      w *= this.getGroupBoost(name);
      w = Math.max(0.25, Math.min(2.2, w));
      return w;
    }

    init() {
      this.initStrategies(); 
      this.setupUI(); 
      this.setupEventListeners();
      this.renderSignals(true);
      this.renderStats(true);
      this.logToJournal('Sistem hazır. "SİSTEMİ BAŞLAT" butonuna tıklayın.');
      
      if (this.headerCollapsed) document.body.classList.add('header-collapsed'); else document.body.classList.remove('header-collapsed');
      this.switchMainView(this.currentMainView);
    }

    initStrategies() {
  this.strategies = {};
  for (const key in this.allStrategiesMap) {
    const StrategyClass = this.allStrategiesMap[key];  // sınıfı al
    this.strategies[key] = new StrategyClass(this);    // örnekle ve bot referansı ver
  }
  this.updateActiveStrategies();
}
    updateActiveStrategies() { 
      for (const key in this.strategies) { this.strategies[key].DEFAULT_PROPOSAL_COOLDOWN_MS = this.settings.cooldowns.strategyProposalMs; } 
      this.activeStrategies = {}; 
      for (const key in this.strategies) { if (this.settings.activeStrategies[key]) this.activeStrategies[key] = this.strategies[key]; } 
    }

    setupUI() {
      document.getElementById('symbol-input').value = this.currentSymbol.replace('USDT', '');
      document.getElementById('timeframe-select').value = this.currentTimeframe;

      this.updateSettingsModalUI();
      const savedTheme = localStorage.getItem('utc_theme') || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme);
      this.chartManager.updateTheme(); 
      this.heatmapManager.updateTheme();
      this.updateSuperTopTicker();
    }
    updateSuperTopTicker() { document.getElementById('ticker-bar-symbol').textContent = this.currentSymbol.replace('USDT', '/USDT'); }

    updateSettingsModalUI() {
      document.getElementById('modal-confluence-threshold').value = this.settings.confluenceThreshold;
      document.getElementById('modal-param-rsi-period').value = this.settings.params.rsiPeriod;
      document.getElementById('modal-param-atr-period').value = this.settings.params.atrPeriod;
      document.getElementById('modal-param-wall-btc').value = this.settings.params.wallBtc;
      document.getElementById('modal-param-rr-ratio').value = this.settings.params.rrRatio;
      document.getElementById('modal-signal-cooldown-ms').value = this.settings.cooldowns.signalMs;
      document.getElementById('modal-same-direction-cooldown-ms').value = this.settings.cooldowns.sameDirectionMs;
      document.getElementById('modal-opposite-direction-cooldown-ms').value = this.settings.cooldowns.oppositeDirectionMs;
      document.getElementById('modal-reverse-hysteresis-points').value = this.settings.cooldowns.reverseHysteresisPoints;
      document.getElementById('modal-proposal-timeout-ms').value = this.settings.cooldowns.proposalTimeoutMs;
      document.getElementById('modal-strategy-proposal-cooldown-ms').value = this.settings.cooldowns.strategyProposalMs;

      const strategyModalContainer = document.getElementById('modal-strategy-toggles');
      strategyModalContainer.innerHTML = '';
      this.allStrategyKeys.forEach(key => { 
        const strategy = this.strategies[key];
        const isChecked = this.settings.activeStrategies[key];
        const isShadow = this.isShadowed(key);
        const toggleHtml = `<div class="form-group"><label class="checkbox-label">
          <input type="checkbox" class="strategy-toggle" data-strategy-key="${key}" ${isChecked ? 'checked' : ''}> ${strategy.displayName}${isShadow ? ' <span style="color:#ffc107;font-size:10px;">[shadow]</span>' : ''}
        </label></div>`;
        strategyModalContainer.innerHTML += toggleHtml;
      });
      this.renderSignals(true); 
      this.renderStats(true);   
    }

    setupEventListeners() {
      document.getElementById('start-btn').addEventListener('click', () => this.start());
      document.getElementById('stop-btn').addEventListener('click', () => this.stop());
      document.getElementById('theme-toggle-btn').addEventListener('click', () => this.toggleTheme());
      document.getElementById('symbol-input').addEventListener('change', (e) => {
        let newSymbol = e.target.value.toUpperCase();
        if (!newSymbol.endsWith('USDT')) newSymbol += 'USDT';
        this.changeSymbol(newSymbol);
        this.saveData('utc_current_symbol', newSymbol);
      });
      document.getElementById('timeframe-select').addEventListener('change', (e) => {
        this.changeTimeframe(e.target.value);
        this.saveData('utc_current_timeframe', e.target.value);
      });
      document.getElementById('header-main-bar').addEventListener('dblclick', () => {
        this.toggleControlsPanel();
        this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
      });
      document.getElementById('main-controls-btn').addEventListener('click', () => {
        this.toggleControlsPanel();
        this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
      });
      document.getElementById('chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
      document.getElementById('heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
      document.getElementById('open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
      document.getElementById('clear-markers-btn').addEventListener('click', () => this.clearChartMarkers()); 
      document.getElementById('chart-zoom-in').addEventListener('click', () => this.chartManager.zoomIn());
      document.getElementById('chart-zoom-out').addEventListener('click', () => this.chartManager.zoomOut());
      document.getElementById('chart-zoom-reset').addEventListener('click', () => this.chartManager.resetZoom());
      document.getElementById('close-settings-modal-btn').addEventListener('click', () => this.closeSettingsModal());
      document.getElementById('settings-modal-overlay').addEventListener('click', (e) => { if (e.target.id === 'settings-modal-overlay') this.closeSettingsModal(); });

      document.getElementById('modal-confluence-threshold').addEventListener('input', (e) => this.settings.confluenceThreshold = parseInt(e.target.value));
      document.getElementById('modal-param-rsi-period').addEventListener('change', (e) => this.settings.params.rsiPeriod = parseInt(e.target.value));
      document.getElementById('modal-param-atr-period').addEventListener('change', (e) => this.settings.params.atrPeriod = parseInt(e.target.value));
      document.getElementById('modal-param-wall-btc').addEventListener('change', (e) => this.settings.params.wallBtc = parseInt(e.target.value));
      document.getElementById('modal-param-rr-ratio').addEventListener('change', (e) => this.settings.params.rrRatio = parseFloat(e.target.value));
      document.getElementById('modal-signal-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.signalMs = parseInt(e.target.value) || 0);
      document.getElementById('modal-same-direction-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.sameDirectionMs = parseInt(e.target.value) || 0);
      document.getElementById('modal-opposite-direction-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.oppositeDirectionMs = parseInt(e.target.value) || 0);
      document.getElementById('modal-reverse-hysteresis-points').addEventListener('change', (e) => this.settings.cooldowns.reverseHysteresisPoints = parseInt(e.target.value) || 0);
      document.getElementById('modal-proposal-timeout-ms').addEventListener('change', (e) => this.settings.cooldowns.proposalTimeoutMs = parseInt(e.target.value) || 1000);
      document.getElementById('modal-strategy-proposal-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.strategyProposalMs = parseInt(e.target.value) || 0);

      document.getElementById('modal-strategy-toggles').addEventListener('change', (e) => {
        if (e.target.classList.contains('strategy-toggle')) {
          const key = e.target.dataset.strategyKey;
          this.settings.activeStrategies[key] = e.target.checked;
          this.updateActiveStrategies(); 
          this.showNotification(`${this.strategies[key].displayName} ${e.target.checked ? 'aktif' : 'pasif'}.`, 'info');
          this.saveSettings();
        }
      });

      document.getElementById('modal-clear-signals-btn').addEventListener('click', () => this.clearAllSignals());
      document.getElementById('reset-all-settings-btn').addEventListener('click', () => this.resetAllSettings());
      document.getElementById('save-settings-btn').addEventListener('click', () => { this.saveSettings(); this.showNotification('Ayarlar kaydedildi!', 'success'); this.closeSettingsModal(); });

      // Şeref panosu
      document.getElementById('honor-btn').addEventListener('click', () => this.openBoardModal('honor'));
      document.getElementById('dishonor-btn').addEventListener('click', () => this.openBoardModal('dishonor'));
      document.getElementById('banned-btn').addEventListener('click', () => this.openBoardModal('banned'));
      document.getElementById('close-board-modal-btn').addEventListener('click', () => this.closeBoardModal());
      document.getElementById('board-modal-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'board-modal-overlay') this.closeBoardModal();
      });
    }

    toggleControlsPanel() {
      document.body.classList.toggle('header-collapsed');
      this.headerCollapsed = document.body.classList.contains('header-collapsed'); 
      setTimeout(() => { window.dispatchEvent(new Event('resize')); }, 360);
    }
    switchMainView(viewName) {
      this.currentMainView = viewName;
      const chartView = document.getElementById('chart-container-view');
      const heatmapView = document.getElementById('heatmap-container-view');
      if (viewName === 'chart') {
        chartView.classList.remove('hidden-view'); heatmapView.classList.add('hidden-view');
        setTimeout(() => { this.chartManager.chart.resize(chartView.clientWidth, chartView.clientHeight); this.chartManager.chart.timeScale().fitContent(); }, 0); 
      } else {
        chartView.classList.add('hidden-view'); heatmapView.classList.remove('hidden-view');
        setTimeout(() => { this.heatmapManager._resizeCanvas(); }, 0); 
      }
    }

    openSettingsModal() { this.updateSettingsModalUI(); document.getElementById('settings-modal-overlay').classList.add('visible'); }
    closeSettingsModal() { document.getElementById('settings-modal-overlay').classList.remove('visible'); this.updateActiveStrategies(); this.calculateAllIndicators(); window.dispatchEvent(new Event('resize')); }

    openBoardModal() { document.getElementById('board-modal-overlay').classList.add('visible'); this.renderHonorBoards(); }
    closeBoardModal() { document.getElementById('board-modal-overlay').classList.remove('visible'); }

    resetAllSettings() {
      if (confirm('Tüm ayarları ve sinyal geçmişini sıfırlamak istediğinizden emin misiniz? Bu işlem geri alınamaz.')) {
        localStorage.removeItem('utc_settings');
        localStorage.removeItem('utc_signals');
        localStorage.removeItem('utc_stats');
        localStorage.removeItem('utc_strategy_stats');
        localStorage.removeItem('utc_ctx_stats');
        localStorage.removeItem('utc_shadow');
        localStorage.removeItem('utc_logit');
        localStorage.removeItem('utc_current_symbol'); 
        localStorage.removeItem('utc_current_timeframe'); 
        localStorage.removeItem('utc_header_collapsed'); 
        localStorage.removeItem('utc_current_view'); 
        
        this.settings = this.loadSettings(); 
        this.signals = []; 
        this.stats = { total: 0, tp: 0, sl: 0 }; 
        this.strategyStats = this.initDefaultStrategyStats();
        this.ctxStats = {};
        this.shadow = { byStrategy: {} };
        this.currentSymbol = 'BTCUSDT'; 
        this.currentTimeframe = '15m'; 
        this.headerCollapsed = true;
        this.currentMainView = 'chart'; 

        this.initStrategies(); 
        this.updateSettingsModalUI(); 
        this.renderSignals(true); 
        this.renderStats(true);   
        this.chartManager.clearMarkers(); 
        this.showNotification('Tüm ayarlar ve veriler sıfırlandı!', 'info');
        this.stop(); 
        document.body.classList.add('header-collapsed'); 
        this.switchMainView('chart');
      }
    }

    async start() {
      if (this.isRunning) return;
      this.isRunning = true; 
      document.getElementById('start-btn').disabled = true; 
      document.getElementById('stop-btn').disabled = false;
      
      this.showNotification('Sistem Başlatıldı: Canlı veri akışı başlatılıyor...', 'success');
      await this.fetchInitialData(); 
      await this.fetchHTFTrend('1h', 120).catch(()=>{});
      this.connectWebSockets();
      this.renderInterval = setInterval(() => this.render(), 250);
      this.analysisInterval = setInterval(() => this.runPeriodicAnalysis(), 5000);
      this.cooldownTuneInterval = setInterval(() => this.autoTuneCooldowns(), 60000);
      this.thresholdTuneInterval = setInterval(() => this.autoTuneThresholds(), 60000);
      this._paperTimer = setInterval(() => this.evaluatePaperProposals(), 30000);
      this._honorTimer = setInterval(() => this.renderHonorBoards(), 5000);
      this._htfTimer = setInterval(()=> this.fetchHTFTrend('1h', 120).catch(()=>{}), 120000);
    }

    stop() {
      if (!this.isRunning) return;
      this.isRunning = false; 
      document.getElementById('start-btn').disabled = false; 
      document.getElementById('stop-btn').disabled = true; 
      this.disconnectWebSockets();
      if (this.renderInterval) clearInterval(this.renderInterval); 
      if (this.analysisInterval) clearInterval(this.analysisInterval);
      if (this.cooldownTuneInterval) clearInterval(this.cooldownTuneInterval);
      if (this.thresholdTuneInterval) clearInterval(this.thresholdTuneInterval);
      if (this._paperTimer) clearInterval(this._paperTimer);
      if (this._honorTimer) clearInterval(this._honorTimer);
      if (this._htfTimer) clearInterval(this._htfTimer);
      this.updateConnectionStatus(false, "BAĞLANTI KESİLDİ"); 
      if (this.combatModeActive) this.deactivateCombatMode();
      this.showNotification('Sistem Durduruldu.', 'danger');
    }

    async changeSymbol(newSymbol) {
      if (this.currentSymbol === newSymbol) return;
      this.currentSymbol = newSymbol; 
      this.showNotification(`${this.currentSymbol.replace('USDT', '/USDT')} sembolüne geçildi.`, 'info');
      this.resetDataForNewSymbol();
      this.updateSuperTopTicker(); 
      if (this.isRunning) { this.stop(); await this.start(); }
    }
    async changeTimeframe(newTimeframe) {
      this.currentTimeframe = newTimeframe; 
      this.showNotification(`Zaman aralığı ${this.currentTimeframe} olarak değiştirildi.`, 'info');
      this.resetDataForNewSymbol();
      if (this.isRunning) { this.stop(); await this.start(); }
    }
    resetDataForNewSymbol() {
      this.candles = []; this.aggTrades = []; this.marketData = {}; this.orderBook = { bids: [], asks: [], lastUpdateId: null };
      this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null };
      this.chartManager.setData([]); this.chartManager.clearMarkers(); this.render();
    }

    async fetchInitialData() {
      try {
        this.logToJournal(`${this.currentSymbol} için geçmiş mum verileri çekiliyor...`);
        const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=${this.currentTimeframe}&limit=500`;
        const response = await fetch(url); if (!response.ok) throw new Error(`API Hatası: ${response.statusText}`);
        const data = await response.json();
        this.candles = data.map(d => ({ time: d[0], open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]), }));
        this.chartManager.setData(this.candles); this.logToJournal(`${this.candles.length} adet mum yüklendi.`);
        this.calculateAllIndicators();
      } catch (error) { this.showNotification(`Geçmiş veri alınamadı: ${error.message}`, 'danger'); console.error("Geçmiş veri hatası:", error); }
    }

    connectWebSockets() {
      this.disconnectWebSockets(); 
      this.reconnectAttempts = 0;
      const symbolLower = this.currentSymbol.toLowerCase();
      const streams = [`${symbolLower}@ticker`, `${symbolLower}@depth20@100ms`, `${symbolLower}@aggTrade`, `${symbolLower}@kline_${this.currentTimeframe}`];
      const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams.join('/')}`); 
      this.sockets['main'] = ws;
      
      ws.onopen = () => { this.updateConnectionStatus(true); this.reconnectAttempts = 0; this.logToJournal("WebSocket bağlantısı başarıyla kuruldu."); };
      ws.onmessage = (event) => { const message = JSON.parse(event.data); this.handleMarketData(message.stream, message.data); };
      ws.onerror = (error) => console.error('WebSocket Hatası:', error);
      ws.onclose = () => { 
        if (this.isRunning) { 
          this.reconnectAttempts++;
          this.reconnectDelay = Math.min(30000, 3000 * Math.pow(2, this.reconnectAttempts - 1));
          const message = `YENİDEN BAĞLANILIYOR... (${this.reconnectDelay / 1000}s)`;
          this.updateConnectionStatus(false, message); 
          this.logToJournal(`Bağlantı kapandı. ${this.reconnectDelay/1000} saniye sonra yeniden denenecek. (Deneme: ${this.reconnectAttempts})`);
          setTimeout(() => this.connectWebSockets(), this.reconnectDelay); 
        } 
      };
    }
    disconnectWebSockets() { if (this.sockets['main']) { this.sockets['main'].onclose = null; this.sockets['main'].close(1000, "İstemci tarafından kapatıldı"); } }

    handleMarketData(stream, data) {
      const streamType = stream.split('@')[1];
      if (streamType === 'ticker') {
        this.marketData = { price: parseFloat(data.c), change24h: parseFloat(data.P), volume24h: parseFloat(data.q), symbol: data.s, btcPrice: (data.s==='BTCUSDT'?parseFloat(data.c):this.marketData.btcPrice) }; 
        // Pozisyon yönetimi + TP/SL kontrol
        this.manageOpenPositions();
        this.checkAutoCloseSignals();
      } 
      else if (streamType.startsWith('depth')) {
        this.orderBook = { bids: data.b.map(([p, q]) => [parseFloat(p), parseFloat(q)]), asks: data.a.map(([p, q]) => [parseFloat(p), parseFloat(q)]), lastUpdateId: data.u };
        this.heatmapManager.draw(this.orderBook, this.marketData.price);
        for (const key in this.activeStrategies) { this.activeStrategies[key].analyzeOrderBook(this.orderBook); }
      } else if (streamType.startsWith('kline')) {
        if (this.candles.length > 0) {
          const kline = data.k; this.chartManager.updateRealtime(kline);
          if (kline.x) {
            const newCandle = { time: kline.t, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c), volume: parseFloat(kline.v) };
            const lastCandle = this.candles[this.candles.length - 1];
            if (lastCandle.time === kline.t) this.candles[this.candles.length - 1] = newCandle; else this.candles.push(newCandle);
            if (this.candles.length > 500) this.candles.shift(); this.calculateAllIndicators();
          }
          // Kline kapanışlarında da pozisyon yönetimini kontrol edelim
          this.manageOpenPositions();
          this.checkAutoCloseSignals();
        }
      } else if (streamType === 'aggTrade') {
        const trade = { price: parseFloat(data.p), quantity: parseFloat(data.q), isBuyerMaker: data.m, timestamp: data.T };
        for (const key in this.activeStrategies) { if (typeof this.activeStrategies[key].processTrade === 'function') this.activeStrategies[key].processTrade(trade); }
      }
    }
    
    runPeriodicAnalysis() { if (!this.isRunning) return; for (const key in this.activeStrategies) { this.activeStrategies[key].periodicAnalyze(); } }
    
    calculateAllIndicators() {
      const rsiPeriod = this.settings.params.rsiPeriod;
      const closes = this.candles.map(c => c.close);
      if (closes.length < rsiPeriod) return;
      let avgGain = 0, avgLoss = 0;
      for (let i = 1; i <= rsiPeriod; i++) { const diff = closes[i] - closes[i - 1]; if (diff > 0) avgGain += diff; else avgLoss -= diff; }
      avgGain /= rsiPeriod; avgLoss /= rsiPeriod;
      const rsi = []; for (let i = 0; i < rsiPeriod; i++) rsi.push(NaN);
      rsi.push(100 - (100 / (1 + (avgGain / avgLoss))));
      for (let i = rsiPeriod + 1; i < closes.length; i++) {
        const diff = closes[i] - closes[i - 1];
        avgGain = (avgGain * (rsiPeriod - 1) + (diff > 0 ? diff : 0)) / rsiPeriod;
        avgLoss = (avgLoss * (rsiPeriod - 1) + (diff < 0 ? -diff : 0)) / rsiPeriod;
        rsi.push(100 - (100 / (1 + (avgLoss === 0 ? 100 : avgGain / avgLoss))));
      }
      this.indicators.rsi = rsi;

      const atrPeriod = this.settings.params.atrPeriod;
      if (this.candles.length < atrPeriod) return;
      let trs = [];
      for (let i = 1; i < this.candles.length; i++) {
        const c = this.candles[i], p = this.candles[i - 1];
        trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
      }
      if (trs.length === 0) return;
      let atrSum = trs.slice(0, atrPeriod).reduce((a, b) => a + b, 0);
      this.indicators.atr = atrSum / atrPeriod;

      const sma = (arr, n) => arr.slice(-n).reduce((a,b)=>a+b,0)/Math.max(1, Math.min(arr.length, n));
      if (closes.length >= 20) this.indicators.sma20 = sma(closes, 20);
      if (closes.length >= 50) this.indicators.sma50 = sma(closes, 50);
      const volumes = this.candles.map(x=>x.volume);
      if (volumes.length >= 20) this.indicators.volSma20 = sma(volumes, 20);
      let cumPV = 0, cumV = 0;
      for (const k of this.candles) { const tp = (k.high + k.low + k.close)/3; cumPV += tp * k.volume; cumV += k.volume; }
      this.indicators.vwap = cumV ? (cumPV / cumV) : null;

      // ADX (stabil): per-bar dx ve periodluk ortalama
      this.indicators.adx = this.calcADX(this.candles, this.settings.params.atrPeriod);
      this.marketRegime = (this.indicators.adx && this.indicators.adx > 22) ? 'trend' : 'range';
    }

    calcADX(candles, period = 14) {
      if (!candles || candles.length < period + 2) return null;
      const tr = [], plusDM = [], minusDM = [];
      for (let i = 1; i < candles.length; i++) {
        const c = candles[i], p = candles[i-1];
        const upMove = c.high - p.high;
        const downMove = p.low - c.low;
        const trueRange = Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close));
        tr.push(trueRange);
        plusDM.push((upMove > downMove && upMove > 0) ? upMove : 0);
        minusDM.push((downMove > upMove && downMove > 0) ? downMove : 0);
      }
      const smooth = (arr) => {
        let s = arr.slice(0, period).reduce((a,b)=>a+b,0);
        const out = [s];
        for (let i = period; i < arr.length; i++) { s = s - (s/period) + arr[i]; out.push(s); }
        return out;
      };
      const trS = smooth(tr), pS = smooth(plusDM), mS = smooth(minusDM);
      const pDI = [], mDI = [], dxArr = [];
      for (let i = 0; i < Math.min(trS.length, pS.length, mS.length); i++) {
        const atr = trS[i] / period;
        const pdi = 100 * ((pS[i] / period) / Math.max(1e-8, atr));
        const mdi = 100 * ((mS[i] / period) / Math.max(1e-8, atr));
        pDI.push(pdi); mDI.push(mdi);
        const dx = 100 * Math.abs(pdi - mdi) / Math.max(1, (pdi + mdi));
        dxArr.push(dx);
      }
      const last = dxArr.slice(-period);
      if (!last.length) return null;
      return last.reduce((a,b)=>a+b,0)/last.length;
    }

    getOrderBookSnapshotInfo() {
      const ob = this.orderBook;
      if (!ob || !ob.bids || !ob.asks || ob.bids.length === 0 || ob.asks.length === 0) return null;
      const bestBid = ob.bids[0][0], bestAsk = ob.asks[0][0];
      const mid = (bestAsk + bestBid)/2;
      const spreadPct = (bestAsk - bestBid) / mid;
      const topN = this.settings.optimization.gating.topN || 5;
      const price = this.marketData.price || mid || 1;
      const sumUsd = (levels) => levels.slice(0, topN).reduce((s,[p,q])=> s + (p*q), 0);
      const topBidUsd = sumUsd(ob.bids);
      const topAskUsd = sumUsd(ob.asks);
      const minTopUsd = Math.min(topBidUsd, topAskUsd);
      return { bestBid, bestAsk, spreadPct, topBidUsd, topAskUsd, minTopUsd, mid, price };
    }
    marketGatingPenalty(direction) {
      const info = this.getOrderBookSnapshotInfo();
      if (!info) return 0;
      const g = this.settings.optimization.gating;
      let penalty = 0;
      if (info.spreadPct > g.spreadMaxPct) penalty += 1;
      if (info.minTopUsd < g.minDepthUsd) penalty += 1;
      return penalty;
    }

    // HTF trend (1h)
    async fetchHTFTrend(interval='1h', len=120) {
      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=${interval}&limit=${len}`;
      const r = await fetch(url); const d = await r.json();
      const kl = d.map(x => ({ c: parseFloat(x[4]) }));
      const sma = (arr,n)=> arr.slice(-n).reduce((a,b)=>a+b,0)/Math.min(n,arr.length);
      const sma20 = sma(kl.map(k=>k.c), 20), sma50 = sma(kl.map(k=>k.c), 50);
      const last = kl[kl.length-1]?.c || 0;
      this.htfTrend = (last > sma50 && sma20 > sma50) ? 'up' : (last < sma50 && sma20 < sma50) ? 'down' : 'flat';
    }
    getHTFPenalty(direction) {
      if (!this.htfTrend || this.htfTrend === 'flat') return 0;
      if (direction === 'buy' && this.htfTrend === 'down') return 1;
      if (direction === 'sell' && this.htfTrend === 'up') return 1;
      return 0;
    }

    getEffectiveThreshold() { return (this.settings.confluenceThreshold || 3) + (this.runtimeThresholdOffset || 0); }

    buildFeatures(buyObj, sellObj) {
      const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr/this.marketData.price) : 0;
      const adx = this.indicators.adx || 0;
      const ob = this.getOrderBookSnapshotInfo() || {};
      const spread = ob.spreadPct || 0, depth = Math.min(3e5, ob.minTopUsd||0)/3e5;
      const dirDiff = (buyObj.score||0) - (sellObj.score||0);
      const top = (arr)=> (arr?.contributors||[]).map(c=>c.effScore||0).sort((a,b)=>b-a).slice(0,3);
      const topB = top(buyObj), topS = top(sellObj);
      return [
        dirDiff,
        buyObj.score||0, sellObj.score||0,
        (buyObj.groupSums?.trending||0), (buyObj.groupSums?.meanReversion||0),
        (sellObj.groupSums?.trending||0), (sellObj.groupSums?.meanReversion||0),
        atrPct, adx/100, spread, depth,
        (topB[0]||0), (topB[1]||0), (topB[2]||0),
        (topS[0]||0), (topS[1]||0), (topS[2]||0)
      ];
    }

    calculateDynamicTpSl(signal) {
      const atr = this.indicators.atr;
      const price = this.marketData.price || signal.price;
      let rrRatioBase = this.settings.params.rrRatio;

      // Kaliteye göre RR (lojistik olasılık)
      const p = (this.classifier && signal.features) ? this.classifier.predict(signal.features) : (signal.prob || 0.55);
      const grpBias = signal.reason?.toLowerCase().includes('trend') ? 1.15 : 1.0;
      let rr = Math.min(2.8, Math.max(1.1, rrRatioBase * (0.9 + p*0.6) * grpBias));

      // risk state adaptasyonu
      if (this.riskState === 'conservative') rr = Math.max(1.1, rr * 0.9);
      if (this.riskState === 'aggressive') rr = Math.min(3.0, rr * 1.1);

      if (!atr || atr === 0) {
        signal.sl = signal.direction === 'buy' ? price * 0.995 : price * 1.005;
        signal.tp = signal.direction === 'buy' ? price * (1 + 0.01*rr) : price * (1 - 0.01*rr);
      } else {
        const atrMultiplier = Math.max(0.8, 1.6 - p); 
        const slDistance = atr * atrMultiplier;
        const tpDistance = slDistance * rr;
        if (signal.direction === 'buy') { signal.sl = price - slDistance; signal.tp = price + tpDistance; }
        else { signal.sl = price + slDistance; signal.tp = price - tpDistance; }
        signal.entrySlDistance = slDistance;
        signal.entryTpDistance = tpDistance;
      }
    }

    manageOpenPositions() {
      const price = this.marketData.price;
      if (!price || this.signals.length === 0) return;
      const settings = this.settings.optimization.breakeven || {};
      if (!settings.enabled) return;
      let changed = false;

      const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
      for (const s of activeSignals) {
        if (!s.entrySlDistance || s.entrySlDistance <= 0) continue;
        const rNow = s.direction === 'buy' ? (price - s.price) / s.entrySlDistance : (s.price - price) / s.entrySlDistance;
        s.mfeR = Math.max(s.mfeR || 0, rNow);
        // Breakeven
        if (!s.beDone && s.mfeR >= (settings.beAtR || 0.8)) {
          s.sl = s.price; s.beDone = true;
          s.note = (s.note || '') + ' | SL->BE';
          changed = true;
        }
        // Trailing
        if (s.mfeR >= (settings.trailAfterR || 1.5) && (s.trailingStage || 0) < 1) {
          const addR = (settings.trailToR || 0.5) * s.entrySlDistance;
          if (s.direction === 'buy') s.sl = Math.min(s.tp, s.price + addR);
          else s.sl = Math.max(s.tp, s.price - addR);
          s.trailingStage = 1;
          s.note = (s.note || '') + ' | Trail1';
          changed = true;
        }
      }
      if (changed) this.saveData('utc_signals', this.signals);
    }

    checkAutoCloseSignals() {
      const price = this.marketData.price;
      if (!price || this.signals.length === 0) return;
      const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
      const now = Date.now();
      for (const s of activeSignals) {
        if (s.direction === 'buy') {
          if (price >= s.tp) { this.updateSignalResult(s.id, 'tp'); }
          else if (price <= s.sl) { this.updateSignalResult(s.id, 'sl'); }
        } else if (s.direction === 'sell') {
          if (price <= s.tp) { this.updateSignalResult(s.id, 'tp'); }
          else if (price >= s.sl) { this.updateSignalResult(s.id, 'sl'); }
        }
        // time stop: belirli sürede 0.3R görülmezse kapat
        if (s.entrySlDistance && (now - s.timestamp) > (this.settings.optimization.timeStopMs || 20*60*1000)) {
          const rNow = s.direction==='buy' ? (price - s.price)/s.entrySlDistance : (s.price - price)/s.entrySlDistance;
          if ((s.mfeR||0) < 0.3 && rNow < 0.1) this.updateSignalResult(s.id,'sl');
        }
      }
    }

    render() { this.renderPriceDisplay(); }
    renderPriceDisplay() {
      const priceEl = document.getElementById('current-price');
      const tickerPriceEl = document.getElementById('ticker-bar-price');
      const oldPriceText = tickerPriceEl ? tickerPriceEl.textContent : '0';
      const oldPrice = this.marketData.price ? parseFloat(oldPriceText.replace(/,/g, '')) : 0;
      
      if (this.marketData.price) {
        const formattedPrice = this.formatPrice(this.marketData.price);
        if (priceEl) priceEl.textContent = formattedPrice;
        if(tickerPriceEl) tickerPriceEl.textContent = formattedPrice;

        if (!isNaN(oldPrice) && oldPrice !== 0) { 
          const color = this.marketData.price > oldPrice ? 'var(--positive)' : (this.marketData.price < oldPrice ? 'var(--negative)' : '');
          if(color) { if (priceEl) priceEl.style.color = color; if(tickerPriceEl) tickerPriceEl.style.color = color; }
        }
      }
      const change = this.marketData.change24h || 0;
      const changeEl = document.getElementById('price-change-24h');
      if (changeEl) { changeEl.textContent = `${change.toFixed(2)}%`; changeEl.style.color = change >= 0 ? 'var(--positive)' : 'var(--negative)'; }
      const volumeEl = document.getElementById('volume-24h'); if(volumeEl) volumeEl.textContent = this.formatVolume(this.marketData.volume24h);
      const atrEl = document.getElementById('atr-value'); if(atrEl) atrEl.textContent = this.indicators.atr ? this.indicators.atr.toFixed(this.getDecimalPlaces(this.indicators.atr)) : '-';
    }

    addFinalSignal(signal) {
      this.signals.unshift(signal); if (this.signals.length > 200) this.signals.pop();
      this.saveData('utc_signals', this.signals);
      this.renderSignals(true); 
      this.renderStats(true); 
      this.chartManager.addSignalMarker(signal);
      this.showNotification(`YENİ SİNYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '/USDT')} | Skor: ${typeof signal.score==='number'?signal.score.toFixed(1):signal.score}`, signal.direction === 'buy' ? 'success' : 'danger');
      playSignal(signal.direction); 
      if (signal.score >= 8) { this.activateCombatMode(); }
    }

    updateSignalResult(signalId, result) {
      const signal = this.signals.find(s => s.id === signalId);
      if(signal && signal.status === 'active') {
        signal.status = result;
        this.stats.total++;
        this.stats[result]++;
        // Strateji performans güncelle
        this.updateStrategyStats(signal);

        // Model eğitimi
        const y = (signal.status === 'tp') ? 1 : 0;
        if (signal.features) { this.classifier.update(y, signal.features); }

        this.saveData('utc_signals', this.signals);
        this.saveData('utc_stats', this.stats);
        this.renderSignals(true); 
        this.renderStats(true);   
        this.showNotification(`Sinyal ${result.toUpperCase()} olarak işaretlendi.`, 'info');
      }
    }

    updateStrategyStats(signal) {
      const isWin = signal.status === 'tp';
      const contributors = signal.contributors || [];
      const totalEff = contributors.reduce((s, c) => s + (c.effScore || (c.baseScore * (c.weight||1))), 0) || 1;
      const decay = 0.995;
      const ctxKey = this.getContextKey();

      for (const c of contributors) {
        const credit = (c.effScore || (c.baseScore * (c.weight||1))) / totalEff;

        // global
        const stat = this.strategyStats[c.strategy] || { alpha:3, beta:2, proposals:0, contrib:0, wins:0, losses:0, lastUpdate: Date.now() };
        stat.alpha *= decay; stat.beta *= decay;
        if (isWin) { stat.wins += credit; stat.alpha += credit; }
        else { stat.losses += credit; stat.beta += credit; }
        stat.contrib += 1; stat.lastUpdate = Date.now();
        this.strategyStats[c.strategy] = stat;

        // context
        this.ctxStats[c.strategy] = this.ctxStats[c.strategy] || {};
        const cs = this.ctxStats[c.strategy][ctxKey] || { alpha:2, beta:2, contrib:0, wins:0, losses:0 };
        cs.alpha *= decay; cs.beta *= decay;
        if (isWin) { cs.wins += credit; cs.alpha += credit; } else { cs.losses += credit; cs.beta += credit; }
        cs.contrib += 1;
        this.ctxStats[c.strategy][ctxKey] = cs;
      }

      // Strateji proposal cooldown adaptasyonu
      for (const key of Object.keys(this.activeStrategies)) {
        const w = this.getStrategyWeight(key);
        const base = this.settings.cooldowns.strategyProposalMs || 10000;
        const factor = Math.max(0.5, Math.min(2.0, 1.2 / Math.max(0.01,w))); 
        const newCd = Math.max(500, Math.round(base * factor));
        this.strategies[key].DEFAULT_PROPOSAL_COOLDOWN_MS = newCd;
      }

      // Hızlı shadow tetikleyici (ağırlık ciddi düşerse)
      for (const c of contributors) {
        const w = this.getStrategyWeight(c.strategy);
        if (w < 0.5) this.shadowBan(c.strategy, `rapid decay w=${w.toFixed(2)}`);
      }

      this.saveStrategyStats();
      this.saveCtxStats();
      // Pano güncelle
      this.renderHonorBoards();
    }

    autoToggleStrategies() {
      if (!this.settings.optimization.autoToggle) return;
      const now = Date.now();
      if (now - this.lastAutoToggleTs < 15*60*1000) return;
      this.lastAutoToggleTs = now;
      const minW = this.settings.optimization.minWeightToStay || 0.6;
      const minContrib = this.settings.optimization.minContribForToggle || 30;

      for (const key of this.allStrategyKeys) {
        const w = this.getStrategyWeight(key);
        const stat = this.strategyStats[key] || {};
        const active = !!this.settings.activeStrategies[key];
        if (active && w < minW && (stat.contrib || 0) >= minContrib) {
          this.shadowBan(key, `low weight w=${w.toFixed(2)}`, this.shadowConfig.banDurMs);
        } else {
          if (this.isShadowed(key) && w >= 1.0) {
            this.liftShadow(key, `weight ${w.toFixed(2)}`);
          }
        }
      }
      this.updateActiveStrategies();
      this.saveSettings();
    }

    autoTuneCooldowns() {
      if (!this.isRunning) return;
      const now = Date.now();
      const WINDOW_MS = 5 * 60 * 1000;
      const recent = this.signals.filter(s => now - s.timestamp <= WINDOW_MS).slice(0, 100).sort((a,b)=> a.timestamp - b.timestamp);

      let quickFlips = 0, totalPairs = 0;
      for (let i = 1; i < recent.length; i++) {
        totalPairs++;
        const dt = recent[i].timestamp - recent[i-1].timestamp;
        if (recent[i-1].direction !== recent[i].direction && dt <= 15000) quickFlips++;
      }
      const flipRatio = totalPairs ? (quickFlips / totalPairs) : 0;
      const volPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0.001;

      const cd = this.settings.cooldowns;
      const baseSame = cd.sameDirectionMs || 30000;
      const baseOpp = cd.oppositeDirectionMs || 20000;
      const baseSignal = cd.signalMs || 15000;

      const newSame = Math.max(10000, Math.min(120000, Math.round(baseSame * (1 + flipRatio * 0.8))));
      const newOpp  = Math.max(5000, Math.min(120000, Math.round(baseOpp  * (1 + flipRatio * 1.2))));
      const volFactor = volPct < 0.005 ? 0.8 : (volPct > 0.02 ? 1.3 : 1.0);
      const newSignal = Math.max(3000, Math.min(60000, Math.round(baseSignal * volFactor)));
      const newProposalTimeout = Math.max(1500, Math.min(8000, Math.round(2000 + 6000 * volPct)));

      const changed = Math.abs(newSame - baseSame) / baseSame > 0.1 ||
                      Math.abs(newOpp - baseOpp) / baseOpp > 0.1 ||
                      Math.abs(newSignal - baseSignal) / baseSignal > 0.1 ||
                      Math.abs(newProposalTimeout - cd.proposalTimeoutMs) / Math.max(1, cd.proposalTimeoutMs) > 0.1;

      if (changed) {
        this.settings.cooldowns.sameDirectionMs = newSame;
        this.settings.cooldowns.oppositeDirectionMs = newOpp;
        this.settings.cooldowns.signalMs = newSignal;
        this.settings.cooldowns.proposalTimeoutMs = newProposalTimeout;
        this.saveSettings();
        this.showNotification(`Cooldown optimize (flip: ${(flipRatio*100).toFixed(0)}%, vol: ${(volPct*100).toFixed(2)}%).`, 'warning');
      }

      // Strateji auto-toggle (shadowban)
      this.autoToggleStrategies();
    }

    autoTuneThresholds() {
      if (!this.isRunning) return;
      const windowSignals = this.signals.filter(s => s.symbol === this.currentSymbol).slice(0, 40);
      const recent = windowSignals.slice(0, 20);
      const tp = recent.filter(s => s.status === 'tp').length;
      const sl = recent.filter(s => s.status === 'sl').length;
      const winRate = (tp + sl) > 0 ? tp / (tp + sl) : 0.5;

      // hızlı flip oranı
      let quickFlips = 0, pairs = 0;
      const ordered = recent.slice().sort((a,b)=> a.timestamp - b.timestamp);
      for (let i = 1; i < ordered.length; i++) {
        pairs++;
        if (ordered[i-1].direction !== ordered[i].direction && (ordered[i].timestamp - ordered[i-1].timestamp) <= 15000) quickFlips++;
      }
      const flipRatio = pairs ? quickFlips / pairs : 0;

      let targetOffset = 0;
      if (winRate <= 0.4 || flipRatio > 0.25) targetOffset = 1;
      if (winRate <= 0.3) targetOffset = 2;
      if (winRate >= 0.6 && flipRatio < 0.1) targetOffset = 0;

      // Risk state
      if (winRate <= 0.35) this.riskState = 'conservative';
      else if (winRate >= 0.65) this.riskState = 'aggressive';
      else this.riskState = 'neutral';

      // Yumuşak geçiş
      this.runtimeThresholdOffset = 0.7 * (this.runtimeThresholdOffset||0) + 0.3 * targetOffset;
    }

    // Shadow helpers
    isShadowed(name) {
      const s = this.shadow && this.shadow.byStrategy && this.shadow.byStrategy[name];
      if (!s) return false;
      if (s.until && Date.now() > s.until) {
        delete this.shadow.byStrategy[name];
        this.saveData('utc_shadow', this.shadow);
        return false;
      }
      return !!s.active;
    }
    shadowBan(name, reason = 'low performance', durMs) {
      const until = Date.now() + (durMs || this.shadowConfig.banDurMs);
      this.shadow.byStrategy[name] = {
        active: true, since: Date.now(), until, reason,
        paper: { wins: 0, losses: 0, last: [] }
      };
      this.saveData('utc_shadow', this.shadow);
      this.showNotification(`${this.strategies[name]?.displayName || name} shadowban: ${reason}`, 'warning');
    }
    liftShadow(name, why = 'probation pass') {
      if (this.shadow.byStrategy[name]) {
        delete this.shadow.byStrategy[name];
        this.saveData('utc_shadow', this.shadow);
        this.showNotification(`${this.strategies[name]?.displayName || name} shadowban kaldırıldı (${why}).`, 'success');
      }
    }
    recordPaperProposal(strategy, direction, price) {
      const atr = this.indicators.atr || (price * 0.005);
      const dist = Math.max(atr * this.shadowConfig.paperR, price * 0.002);
      const tp = direction === 'buy' ? price + dist : price - dist;
      const sl = direction === 'buy' ? price - dist : price + dist;
      this.paperEval.queue.push({ strategy, direction, price, tp, sl, t0: Date.now(), evaluated: false });
      if (this.paperEval.queue.length > 500) this.paperEval.queue.shift();
    }
    evaluatePaperProposals() {
      const now = Date.now();
      const c = this.candles || [];
      if (!c.length) return;

      const lookMs = this.shadowConfig.lookaheadMs;
      for (const p of this.paperEval.queue) {
        if (p.evaluated || (now - p.t0) < lookMs) continue;

        const seg = c.filter(k => k.time >= p.t0);
        if (!seg.length) continue;
        const maxH = Math.max(...seg.map(k => k.high));
        const minL = Math.min(...seg.map(k => k.low));

        let win = false, loss = false;
        if (p.direction === 'buy') { win = maxH >= p.tp; loss = minL <= p.sl; }
        else { win = minL <= p.tp; loss = maxH >= p.sl; }

        const sb = this.shadow.byStrategy[p.strategy];
        if (sb) {
          const paper = sb.paper || (sb.paper = { wins: 0, losses: 0, last: [] });
          if (win && !loss) { paper.wins += 1; paper.last.push(1); }
          else if (loss && !win) { paper.losses += 1; paper.last.push(0); }
          else { paper.losses += 0.5; paper.last.push(0); }

          const W = this.shadowConfig.probationWindow;
          while (paper.last.length > W) paper.last.shift();
          const winsInWindow = paper.last.reduce((a,b)=>a+b,0);
          if (paper.last.length >= W && winsInWindow >= this.shadowConfig.probationWinsNeeded) {
            this.liftShadow(p.strategy, `paper ${winsInWindow}/${paper.last.length}`);
          }
          this.saveData('utc_shadow', this.shadow);
        }
        p.evaluated = true;
      }
    }

    // Şeref Panosu
    getStratMetrics(key) {
      const s = this.strategyStats[key] || { wins:0, losses:0, contrib:0 };
      const wins = s.wins || 0, losses = s.losses || 0;
      const total = wins + losses;
      const wr = total > 0 ? wins / total : NaN;
      const w = this.getStrategyWeight(key);
      const banned = this.isShadowed(key);
      return { key, display: this.strategies[key]?.displayName || key, w, wr, contrib: s.contrib || 0, banned };
    }
    classifyStrategies() {
      const honor = [], dishonor = [], banned = [];
      const minContrib = 20;
      for (const key of this.allStrategyKeys) {
        const m = this.getStratMetrics(key);
        if (m.banned) { banned.push(m); continue; }
        if (m.contrib >= minContrib) {
          if (m.w >= 1.0 && (isNaN(m.wr) ? false : m.wr >= 0.55)) honor.push(m);
          else if (m.w < 0.6 || (isNaN(m.wr) ? false : m.wr <= 0.45)) dishonor.push(m);
        }
      }
      honor.sort((a,b)=> b.w - a.w); dishonor.sort((a,b)=> b.w - a.w);
      banned.sort((a,b)=> a.display.localeCompare(b.display));
      return { honor, dishonor, banned };
    }
    renderBoardTable(arr, kind='honor') {
      if (!arr || !arr.length) return '<div style="padding:8px;color:var(--text-secondary)">Kayıt yok.</div>';
      const head = `
        <table class="data-table">
          <thead>
            <tr><th>Strateji</th><th>w</th><th>WR</th><th>Contrib</th></tr>
          </thead><tbody>
      `;
      const rows = arr.map(m => {
        const w = (isFinite(m.w) ? m.w.toFixed(2) : '-');
        const wr = (isFinite(m.wr) ? (m.wr*100).toFixed(0)+'%' : '-');
        const color = kind==='honor' ? 'var(--positive)' : (kind==='dishonor' ? 'var(--negative)' : 'var(--text-main)');
        return `<tr>
          <td>${m.display}</td>
          <td style="color:${color}">${w}</td>
          <td>${wr}</td>
          <td>${m.contrib || 0}</td>
        </tr>`;
      }).join('');
      return head + rows + '</tbody></table>';
    }
    renderHonorBoards() {
      const cls = this.classifyStrategies();
      const honorEl = document.getElementById('honor-list');
      const dishEl  = document.getElementById('dishonor-list');
      const banEl   = document.getElementById('banned-list');
      if (honorEl) honorEl.innerHTML = this.renderBoardTable(cls.honor, 'honor');
      if (dishEl)  dishEl.innerHTML  = this.renderBoardTable(cls.dishonor, 'dishonor');
      if (banEl)   banEl.innerHTML   = this.renderBoardTable(cls.banned, 'banned');
    }

    activateCombatMode() {
      if (this.combatModeActive) return; this.combatModeActive = true; document.documentElement.setAttribute('data-theme', 'war');
      this.chartManager.updateTheme(); this.heatmapManager.updateTheme(); 
      playSignal('combat'); 
      this.showNotification('!!! SAVAŞ MODU AKTİF !!!', 'warning');
    }
    deactivateCombatMode() {
      this.combatModeActive = false; const savedTheme = localStorage.getItem('utc_theme') || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme);
      this.chartManager.updateTheme(); this.heatmapManager.updateTheme();
    }

    formatPrice(price) { if(!price && price !== 0) return '-'; return price.toLocaleString('en-US', { minimumFractionDigits: this.getDecimalPlaces(price), maximumFractionDigits: this.getDecimalPlaces(price) }); }
    getDecimalPlaces(price) { if(price === undefined || price === null) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
    formatVolume(volume) { if (!volume) return '-'; if (volume >= 1e9) return `${(volume / 1e9).toFixed(2)}B`; if (volume >= 1e6) return `${(volume / 1e6).toFixed(2)}M`; return `${(volume / 1e3).toFixed(1)}K`; }
    toggleTheme() { if (this.combatModeActive) { this.deactivateCombatMode(); return; } const ct = document.documentElement.getAttribute('data-theme'); const nt = (ct === 'dark') ? 'light' : 'dark'; document.documentElement.setAttribute('data-theme', nt); localStorage.setItem('utc_theme', nt); this.chartManager.updateTheme(); this.heatmapManager.updateTheme(); }
    
    updateConnectionStatus(isConnected, message = 'BAĞLANTI YOK') { 
      const sd = document.getElementById('connection-status');
      const st = document.getElementById('connection-text');
      const tickerSymbolEl = document.getElementById('ticker-bar-symbol');
      if(isConnected) { sd.classList.add('online'); st.textContent = `BAĞLI (${this.currentSymbol.replace('USDT', '/USDT')})`; if(tickerSymbolEl) tickerSymbolEl.textContent = this.currentSymbol.replace('USDT', '/USDT'); }
      else { sd.classList.remove('online'); st.textContent = message; } 
    }

    showNotification(message, type = 'info') { const c=document.getElementById('notifications-container'); if(!c) return; const n = document.createElement('div'); n.className=`notification ${type}`; n.textContent=message; c.prepend(n); setTimeout(() => { n.style.transition='opacity 0.5s ease'; n.style.opacity=0; setTimeout(()=>n.remove(), 500); }, 5000); }
    logToJournal(message) { console.log(`[LOG] ${new Date().toLocaleTimeString()} - ${message}`); }
    
    saveSettings() { localStorage.setItem('utc_settings', JSON.stringify(this.settings)); }
    loadSettings() {
      const defaultActive = {};
      this.allStrategyKeys.forEach((key, i) => defaultActive[key] = i < 5); 
      const defaults = {
        confluenceThreshold: 3,
        params: { rsiPeriod: 14, atrPeriod: 14, wallBtc: 20, rrRatio: 1.5 },
        cooldowns: { 
          signalMs: 15000, sameDirectionMs: 30000, proposalTimeoutMs: 3000, strategyProposalMs: 10000,
          oppositeDirectionMs: 20000, reverseHysteresisPoints: 2
        },
        optimization: {
          enabled: true,
          timeDecaySec: 3,
          dirMargin: 0.5,
          gating: { spreadMaxPct: 0.0015, minDepthUsd: 50000, topN: 5 },
          breakeven: { enabled: true, beAtR: 0.8, trailAfterR: 1.5, trailToR: 0.5 },
          autoToggle: true,
          minWeightToStay: 0.6,
          minContribForToggle: 30,
          probThreshold: 0.55,
          timeStopMs: 20*60*1000
        },
        activeStrategies: defaultActive
      };
      const saved = this.loadData('utc_settings');
      if(saved) {
        return {
          ...defaults,
          ...saved,
          params: { ...defaults.params, ...(saved.params||{}) },
          cooldowns: { ...defaults.cooldowns, ...(saved.cooldowns||{}) },
          optimization: { ...defaults.optimization, ...(saved.optimization||{}) },
          activeStrategies: { ...defaults.activeStrategies, ...(saved.activeStrategies||{}) }
        };
      }
      return defaults;
    }
    saveData(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); } catch(e) { console.error("Veri kaydedilemedi:", e); } }
    loadData(key) { try { const data = localStorage.getItem(key); return data ? JSON.parse(data) : null; } catch(e) { console.error("Veri okunamadı:", e); return null; } }
  }

  document.addEventListener('DOMContentLoaded', () => { 
    try { 
      window.app = new UltimateTradingCommandCenter(); 
      setTimeout(() => window.dispatchEvent(new Event('resize')), 100);
    } 
    catch(e) {
      console.error("Uygulama başlatılırken kritik bir hata oluştu:", e);
      document.body.innerHTML = `<div style="color: red; padding: 20px; font-family: monospace;">Uygulama başlatılamadı. Konsolu kontrol edin. Hata: ${e.message}</div>`;
    }
  });
</script>
</body>
</html>


birinci konular:
abi bu projenin tüm özellik ve fonksyonlarının kendi kendini optimize etmesi gerekiyor.fakat sadece cooldown optimiz oluyor.sitratejiler ve skor otomatik olarak optimize edilmesi gerekmezmi sencede? sinyallerin çogu başarısız oluyor. bu sorunu optimize ve geliştirmelerle çözebilirmisin.
programın mevcut özelliklerini bozmadan.

diğer konu:
abi ceza sisteminde cezalı stratijiler shadowban yesin arkaplanda çalışmaya devam etsin.güçlendiğinde katılım sağlasın.daha mantıklı değilmi sence?
ceza sistemini daha iyi hale getirecek düşüncelerin varsa bunları konuşalım.
diğer konu:


şerefli ve şerefsizler butonu koy en üsteki butonların yanına. buradaki stratejiler başarılı ve başarısızlar olarak sürekli güncellensin dinamik olarak.ban yiyenleride ayrı butona koy onarıda görelim. vatan hainleri ifşa olsunki kullanıcı kimn hain kimin dost olduğunu bilsin.
sorunlu stratejilerin iç dinamiklerindeki parametrelerde ameliyat edilebilsin. anbladınmı şerefsizler şerefsizlikte ısrar ederse optimizasyon iç dinamiklere sıçrayacak.
günün şerefsizi gibi birşeyler düşünüyorum.
 tts konuşmalarındada komik yada set şerefsizler için metinler ekleyebilirsin.senin yaratıcılığına kalmış.
bu kısım için farklı yaklaşımın varsa konuşalım.