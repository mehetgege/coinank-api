<!DOCTYPE html>
<html lang="tr" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ULTIMATE TRADING KOMUTA MERKEZÄ°</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    :root {
      --background-dark: #0d1117; --panel-bg-dark: #161b22; --text-main-dark: #c9d1d9; --text-secondary-dark: #8b949e; --border-color-dark: #30363d; --input-bg-dark: #010409; --hover-bg-dark: #21262d; --primary-dark: #58a6ff;
      --background-light: #ffffff; --panel-bg: #f6f8fa; --text-main: #24292f; --text-secondary: #57606a; --border-color: #d0d7de; --input-bg: #f0f2f5; --hover-bg: #e8eaed; --primary: #0969da;
      --war-mode-bg: linear-gradient(145deg, #4d0000 0%, #000000 75%); --war-mode-panel-bg: rgba(255, 0, 0, 0.08); --war-mode-border: #8B0000; --war-mode-text: #ff5858; --war-mode-primary: #ffc107;
      --positive: #28a745; --negative: #dc3545; --neutral: #ffc107;
      --ticker-height: 30px; 
      --header-min-height: 40px;
    }
    [data-theme="light"] { --background: var(--background-light); --panel-bg: var(--panel-bg-light); --text-main: var(--text-main-light); --text-secondary: var(--text-secondary-light); --border-color: var(--border-color-light); --input-bg: var(--input-bg-light); --hover-bg: var(--hover-bg-light); --primary: var(--primary-light); }
    [data-theme="dark"] { --background: var(--background-dark); --panel-bg: var(--panel-bg-dark); --text-main: var(--text-main-dark); --text-secondary: var(--text-secondary-dark); --border-color: var(--border-color-dark); --input-bg: var(--input-bg-dark); --hover-bg: var(--hover-bg-dark); --primary: var(--primary-dark); }
    [data-theme="war"] { --background: var(--war-mode-bg); --panel-bg: var(--war-mode-panel-bg); --text-main: var(--war-mode-text); --text-secondary: #ffaaaa; --border-color: var(--war-mode-border); --input-bg: rgba(255, 255, 255, 0.05); --hover-bg: rgba(255, 255, 255, 0.1); --primary: var(--war-mode-primary); }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Roboto Mono', monospace; font-size: 12px; background: var(--background); color: var(--text-main); overflow: hidden; transition: background 0.5s, color 0.5s; }
    
    #super-top-ticker { display: flex; position: fixed; top: 0; left: 0; width: 100%; background: var(--panel-bg); border-bottom: 1px solid var(--border-color); padding: 2px 10px; z-index: 1100; align-items: center; justify-content: space-between; font-size: 11px; font-weight: 700; height: var(--ticker-height); }
    .super-top-left { display: flex; align-items: center; gap: 10px; flex-shrink: 0;}
    #ticker-bar-symbol { color: var(--primary); }
    #ticker-bar-price { color: var(--text-main); font-size: 12px; }
    .super-top-right-buttons { display: flex; gap: 5px; }

    .container { display: flex; flex-direction: column; height: 100vh; padding-top: var(--ticker-height); }

    .header { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; flex-shrink: 0; box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 5px; position: relative; }
    .header-top-bar { display: flex; align-items: center; width: 100%; padding: 5px 15px; min-height: var(--header-min-height); justify-content: space-between; cursor: pointer; font-weight: 700; font-size: 16px; color: var(--primary); }
    .header-collapsible-content { transition: max-height 0.35s ease-in-out, opacity 0.3s ease, padding 0.35s ease, visibility 0.35s; max-height: 300px; opacity: 1; overflow: hidden; visibility: visible; padding: 0 15px 8px 15px; }
    body.header-collapsed .header-collapsible-content { max-height: 0; opacity: 0; visibility: hidden; padding-top: 0; padding-bottom: 0; }

    .main-controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; padding-bottom: 8px; }
    .form-control { background: var(--input-bg); color: var(--text-main); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-family: 'Roboto Mono', monospace; }
    
    .status { display: flex; align-items: center; gap: 5px; font-size: 11px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--negative); transition: background-color 0.5s; }
    .status-dot.online { background: var(--positive); animation: pulse 2s infinite; }
    @keyframes pulse { 0% { box-shadow: 0 0 0 0 #28a745b3; } 70% { box-shadow: 0 0 0 6px #28a74500; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
    [data-theme="war"] .status-dot.online { background: var(--war-mode-primary); animation: war-pulse 1s infinite; }
    @keyframes war-pulse { 0% { box-shadow: 0 0 0 0 #ffc107b3; } 70% { box-shadow: 0 0 0 6px #ffc10700; } 100% { box-shadow: 0 0 0 0 #ffc10700; } }
    .btn { padding: 4px 12px; border: 1px solid var(--border-color); background: var(--panel-bg); color: var(--text-main); border-radius: 4px; cursor: pointer; transition: all 0.2s; }
    .btn:hover { background: var(--hover-bg); border-color: var(--primary); }
    .btn-success { background: var(--positive); color: white; border-color: var(--positive); } .btn-danger { background: var(--negative); color: white; border-color: var(--negative); }
    .btn-tiny { padding: 2px 6px; font-size: 10px; line-height: 1; min-width: 0; white-space: nowrap; }
    
    .main-grid { display: grid; grid-template-columns: 1fr; gap: 5px; flex-grow: 1; margin: 5px; overflow: hidden; height: calc(100% - var(--header-min-height) - 10px - var(--ticker-height)); }
    body.header-collapsed .main-grid { height: calc(100vh - var(--ticker-height) - 10px); margin-top: 0; } 
    
    .panel { display: flex; flex-direction: column; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; overflow: hidden; }
    .panel-title { font-weight: 700; font-size: 13px; color: var(--primary); padding: 8px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; display: flex; justify-content: space-between; align-items: center;}
    .panel-content { padding: 10px; overflow-y: auto; flex-grow: 1; }
    .settings-group { margin-bottom: 15px; } .form-group { margin-bottom: 8px; } .form-label { display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px; }
    .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 12px; padding: 4px 0;}
    
    .price-display { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; width: 100%; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; font-size: 10px; margin-top: 8px; } 
    .price-item .price-label { color: var(--text-secondary); } 
    .price-item .price-value { font-size: 18px; font-weight: 700; }
    
    .center-panel { display: grid; grid-template-rows: 1fr; gap: 5px; padding: 0 !important; } 
    .data-container { display: grid; grid-template-rows: 1fr auto; overflow: hidden; height: 100%; } 
    .data-grid { position: relative; overflow: hidden; min-height: 0; } 

    #live-chart { width: 100%; height: 100%; } 
    .heatmap-container { display: grid; grid-template-rows: auto 1fr; border-top: 1px solid var(--border-color); }
    #orderbook-heatmap { width: 100%; height: 100%; display: block; }

    .chart-zoom-controls { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; z-index: 100; }
    .chart-zoom-controls .btn-tiny { background: rgba(1, 4, 9, 0.7); backdrop-filter: blur(2px); }

    .data-table-container { width: 100%; height: 100%; overflow: auto; }
    .data-table { width: 100%; border-collapse: collapse; font-size: 11px; }
    .data-table th, .data-table td { padding: 6px 8px; text-align: left; border-bottom: 1px solid var(--border-color); white-space: nowrap;}
    .data-table th { font-weight: 700; position: sticky; top: 0; background: var(--panel-bg); z-index: 10;}
    .data-table tr:hover { background: var(--hover-bg); }
    .signal-buy { background-color: #28a74514; } .signal-sell { background-color: #dc354514; }
    .signal-tp { background-color: #28a74533; } .signal-sl { background-color: #dc354533; }
    .stat-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border-color); font-size: 12px; }
    .stat-item:last-child { border-bottom: none; } .stat-label { color: var(--text-secondary); } .stat-value { font-weight: 700; }
    .btn-sm { padding: 1px 4px; font-size: 9px; margin-left: 4px; border-radius: 3px; cursor: pointer;}
    ::-webkit-scrollbar { width: 6px; height: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: var(--text-secondary); border-radius: 3px; }
    .notifications { position: fixed; bottom: 15px; right: 15px; z-index: 2000; width: 320px; }
    .notification { background: var(--panel-bg); border: 1px solid var(--border-color); border-left-width: 5px; border-radius: 4px; padding: 12px; font-size: 13px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); margin-top: 10px; }
    .notification.success { border-left-color: var(--positive); } .notification.danger { border-left-color: var(--negative); } .notification.warning { border-left-color: var(--neutral); }
    
    aside#settings-panel, aside#analytics-panel { display: none !important; }
    .hidden-view { display: none !important; } 

    #settings-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 2500; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
    #settings-modal-overlay.visible { opacity: 1; visibility: visible; }
    .settings-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 90%; max-width: 860px; max-height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); transform: translateY(20px); transition: transform 0.3s ease; }
    #settings-modal-overlay.visible .settings-modal-content { transform: translateY(0); }
    .settings-modal-header { padding: 12px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 15px; color: var(--primary); }
    .settings-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
    .settings-modal-header .close-btn:hover { color: var(--negative); }
    .settings-modal-body { padding: 15px; overflow-y: auto; flex-grow: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .settings-modal-footer { padding: 12px 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 10px; }

    /* ÅEREF PANOSU MODAL */
    #board-modal-overlay { 
      position: fixed; top:0; left:0; width:100%; height:100%; 
      background: rgba(0,0,0,0.7); display:flex; justify-content:center; align-items:center; 
      z-index: 2500; opacity:0; visibility:hidden; transition: opacity 0.3s ease, visibility 0.3s ease; 
    }
    #board-modal-overlay.visible { opacity:1; visibility:visible; }

    @media screen and (max-width: 768px) {
      .container { padding-top: var(--ticker-height); }
      .header { order: 2; position: sticky; bottom: 0; top: auto; width: 100%; z-index: 1000; margin: 0; border-radius: 0; border: none; border-top: 1px solid var(--border-color); }
      .header-top-bar { flex-direction: column; align-items: center; gap: 10px; padding: 10px 15px; }
      .header-collapsible-content { padding: 0; }
      .header-collapsible-content .main-controls { flex-direction: column; align-items: center; padding: 0; width: 100%; }
      .form-control, .btn, .status { width: 100%; text-align: center; padding: 8px 10px; font-size: 11px; }
      .status { justify-content: center; }
      .price-display { grid-template-columns: repeat(2, 1fr); margin-top: 10px; }
      .price-item .price-value { font-size: 14px; } 
      .main-grid { order: 1; flex-direction: column; margin: 5px; overflow: visible; padding-bottom: 5px; height: auto; }
      .center-panel { order: 1; flex-grow: 0; height: auto; border: 1px solid var(--border-color); border-radius: 6px; background: var(--panel-bg); box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 0; }
      .center-panel > .panel-title { display: none; }
      .data-container { flex-direction: column; height: auto; padding: 10px; }
      .data-grid { height: 50vh; flex-shrink: 0; }
      #live-chart { height: 100%; width: 100%; } 
      .heatmap-container { height: 150px; flex-shrink: 0; margin-top: 10px; border-top: 1px solid var(--border-color); padding-top: 10px; }
      .settings-modal-content { width: 95%; margin: 10px; }
      .settings-modal-body { grid-template-columns: 1fr; gap: 15px; }
      .super-top-right-buttons { display: none; }
    }
  </style>
</head>
<body class="header-collapsed"> 
  <div id="super-top-ticker">
    <div class="super-top-left">
      <span id="ticker-bar-symbol"></span>
      <span id="ticker-bar-price"></span>
    </div>
    <div class="super-top-right-buttons">
      <button id="main-controls-btn" class="btn btn-tiny">Komuta Merkezi</button>
      <button id="chart-view-btn" class="btn btn-tiny">Grafik</button>
      <button id="heatmap-view-btn" class="btn btn-tiny">IsÄ± HaritasÄ±</button>
      <button id="open-settings-modal-btn" class="btn btn-tiny">Ayarlar</button>
      <!-- Yeni: Åeref Panosu butonlarÄ± -->
      <button id="honor-btn" class="btn btn-tiny">Åerefli</button>
      <button id="dishonor-btn" class="btn btn-tiny">Åerefsizler</button>
      <button id="banned-btn" class="btn btn-tiny">BanlÄ±lar</button>
    </div>
  </div>

  <div class="container">
    <header class="header">
      <div id="header-main-bar" class="header-top-bar" title="Paneli aÃ§/kapatmak iÃ§in Ã§ift tÄ±kla">
        <span>KOMUTA MERKEZÄ° KONTROLLERÄ°</span>
      </div>
      <div class="header-collapsible-content">
        <div class="main-controls">
          <input type="text" id="symbol-input" class="form-control" placeholder="Ãrn: BTC, ETH, SOL">
          <select id="timeframe-select" class="form-control">
            <option value="1m">1m</option><option value="5m">5m</option><option value="15m" selected>15m</option><option value="1h">1h</option><option value="4h">4h</option>
          </select>
          <div class="status">
            <div id="connection-status" class="status-dot"></div>
            <span id="connection-text">BAÄLANTI YOK</span>
          </div>
          <button id="theme-toggle-btn" class="btn">Tema</button>
          <button id="start-btn" class="btn btn-success">SÄ°STEMÄ° BAÅLAT</button>
          <button id="stop-btn" class="btn btn-danger" disabled>DURDUR</button>
          <button id="clear-markers-btn" class="btn">Grafik Sinyallerini Sil</button> 
        </div>
        <div class="price-display">
          <div class="price-item"><div class="price-label">FÄ°YAT</div><div class="price-value" id="current-price">-</div></div>
          <div class="price-item"><div class="price-label">24s DEÄÄ°ÅÄ°M</div><div class="price-value" id="price-change-24h">-</div></div>
          <div class="price-item"><div class="price-label">24s HACÄ°M</div><div class="price-value" id="volume-24h">-</div></div>
          <div class="price-item"><div class="price-label">VOLATÄ°LÄ°TE (ATR)</div><div class="price-value" id="atr-value">-</div></div>
        </div>
      </div>
    </header>

    <main class="main-grid">
      <section class="center-panel panel">
        <div class="data-container">
          <div class="data-grid" id="chart-container-view">
            <div id="live-chart"></div>
            <div class="chart-zoom-controls"> 
              <button id="chart-zoom-in" class="btn btn-tiny">+</button>
              <button id="chart-zoom-out" class="btn btn-tiny">-</button>
              <button id="chart-zoom-reset" class="btn btn-tiny">SÄ±fÄ±rla</button>
            </div>
          </div>
          <div class="heatmap-container hidden-view" id="heatmap-container-view">
            <div class="panel-title" style="border-top: 1px solid var(--border-color); border-bottom: none;">EMÄ°R DEFTERÄ° ISI HARÄ°TASI</div>
            <canvas id="orderbook-heatmap"></canvas>
          </div>
        </div>
      </section>
    </main>
  </div>
  
  <div id="notifications-container" class="notifications"></div>

  <!-- AYARLAR MODAL -->
  <div id="settings-modal-overlay">
    <div class="settings-modal-content">
      <div class="settings-modal-header">
        <span>AYARLAR & OPTÄ°MÄ°ZASYON</span>
        <button class="close-btn" id="close-settings-modal-btn">&times;</button>
      </div>
      <div class="settings-modal-body">
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">Temel Parametreler</div>
          <div class="form-group"><label class="form-label">Min. Uyum Skoru (1-10)</label><input type="range" id="modal-confluence-threshold" class="form-control" min="1" max="10" value="3" step="1"></div>
          <div class="form-group"><label class="form-label">RSI Periyodu</label><input type="number" id="modal-param-rsi-period" class="form-control" value="14"></div>
          <div class="form-group"><label class="form-label">ATR Periyodu</label><input type="number" id="modal-param-atr-period" class="form-control" value="14"></div>
          <div class="form-group"><label class="form-label">Duvar Tespiti (BTC MiktarÄ±)</label><input type="number" id="modal-param-wall-btc" class="form-control" value="20"></div>
          <div class="form-group"><label class="form-label">Risk/ÃdÃ¼l OranÄ± (R/R)</label><input type="number" id="modal-param-rr-ratio" class="form-control" value="1.5" step="0.1"></div>
        </div>
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">Cooldown AyarlarÄ±</div>
          <div class="form-group"><label class="form-label">Genel Sinyal Cooldown (ms)</label><input type="number" id="modal-signal-cooldown-ms" class="form-control" value="15000" min="0" step="100"></div>
          <div class="form-group"><label class="form-label">AynÄ± YÃ¶n Sinyal Cooldown (ms)</label><input type="number" id="modal-same-direction-cooldown-ms" class="form-control" value="30000" min="0" step="100"></div>
          <div class="form-group"><label class="form-label">Ters YÃ¶n Cooldown (ms)</label><input type="number" id="modal-opposite-direction-cooldown-ms" class="form-control" value="20000" min="0" step="100"></div>
          <div class="form-group"><label class="form-label">Ters YÃ¶n Histerezis (+Puan)</label><input type="number" id="modal-reverse-hysteresis-points" class="form-control" value="2" min="0" step="1"></div>
          <div class="form-group"><label class="form-label">Proposal Timeout (ms)</label><input type="number" id="modal-proposal-timeout-ms" class="form-control" value="3000" min="500" step="100"></div>
          <div class="form-group"><label class="form-label">Strateji Teklifi Cooldown (ms)</label><input type="number" id="modal-strategy-proposal-cooldown-ms" class="form-control" value="10000" min="0" step="100"></div>
        </div>
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">Aktif Stratejiler</div>
          <div id="modal-strategy-toggles"></div>
        </div>
        <div class="settings-group" style="grid-column: 1 / -1;">
          <div class="panel-title" style="margin-bottom: 10px;">Sinyal GeÃ§miÅi ve Analiz</div>
          <div class="data-table-container" style="max-height: 300px;">
            <table class="data-table">
              <thead>
                <tr>
                  <th>Zaman</th><th>Tip</th><th>Fiyat</th><th>TP</th><th>SL</th><th>Skor</th><th>KatkÄ±</th><th>Durum</th>
                </tr>
              </thead>
              <tbody id="modal-signals-body"></tbody>
            </table>
          </div>
          <button id="modal-clear-signals-btn" class="btn btn-danger btn-sm" style="margin-top: 10px;">TÃ¼m Sinyalleri Sil</button>
          <div id="modal-stats-container" style="margin-top: 15px;"></div>
        </div>
      </div>
      <div class="settings-modal-footer">
        <button id="reset-all-settings-btn" class="btn btn-danger">AYARLARI SIFIRLA</button>
        <button id="save-settings-btn" class="btn btn-success">AYARLARI KAYDET</button>
      </div>
    </div>
  </div>

  <!-- ÅEREF PANOSU MODAL -->
  <div id="board-modal-overlay">
    <div class="settings-modal-content">
      <div class="settings-modal-header">
        <span>ÅEREF PANOSU</span>
        <button class="close-btn" id="close-board-modal-btn">&times;</button>
      </div>
      <div class="settings-modal-body" style="grid-template-columns: 1fr 1fr 1fr;">
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">Åerefli</div>
          <div id="honor-list" class="data-table-container"></div>
        </div>
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">Åerefsizler</div>
          <div id="dishonor-list" class="data-table-container"></div>
        </div>
        <div class="settings-group">
          <div class="panel-title" style="margin-bottom: 10px;">BanlÄ±lar</div>
          <div id="banned-list" class="data-table-container"></div>
        </div>
      </div>
    </div>
  </div>

<script>
  // Sinyal sesleri
  function playSignal(type) {
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      if (type === 'buy') {
        oscillator.type = 'triangle'; oscillator.frequency.value = 1000;
      } else if (type === 'sell') {
        oscillator.type = 'square'; oscillator.frequency.value = 400;
      } else if (type === 'combat') {
        oscillator.type = 'sawtooth'; oscillator.frequency.value = 800; 
        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);
        oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 1);
        return;
      }
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
      oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5);
    } catch (error) { console.log('Ses Ã§alÄ±namadÄ±:', error); }
  }

  /* =========================
     GÃRSELLEÅTÄ°RME YÃNETÄ°CÄ°LERÄ°
     ========================= */
  class ChartManager {
    constructor(chartContainerId) {
      this.chartContainer = document.getElementById(chartContainerId);
      if (!this.chartContainer) throw new Error("Chart container bulunamadÄ±!");
      this.chart = null; this.series = {}; this.signalMarkers = [];
      this._initChart();
    }
    _initChart() {
      this.chart = LightweightCharts.createChart(this.chartContainer, this._getChartOptions());
      this.series.candles = this.chart.addCandlestickSeries(this._getCandlestickOptions());
      this.series.volume = this.chart.addHistogramSeries(this._getVolumeOptions());
      window.addEventListener('resize', () => { 
        if (this.chart && this.chartContainer.clientWidth > 0 && this.chartContainer.clientHeight > 0) {
          this.chart.resize(this.chartContainer.clientWidth, this.chartContainer.clientHeight);
        }
      });
    }
    updateTheme() {
      if(!this.chart) return;
      this.chart.applyOptions(this._getChartOptions());
      this.series.candles.applyOptions(this._getCandlestickOptions());
      this.series.volume.applyOptions(this._getVolumeOptions());
    }
    setData(candles) {
      if (!this.series.candles) return;
      const candleData = candles.map(c => ({ time: c.time / 1000, open: c.open, high: c.high, low: c.low, close: c.close }));
      const volumeData = candles.map(c => ({ time: c.time / 1000, value: c.volume, color: c.close >= c.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' }));
      this.series.candles.setData(candleData);
      this.series.volume.setData(volumeData);
      this.chart.timeScale().fitContent();
    }
    updateRealtime(kline) {
      if (!this.series.candles) return;
      const candle = { time: kline.t / 1000, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c) };
      const volume = { time: kline.t / 1000, value: parseFloat(kline.v), color: candle.close >= candle.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' };
      this.series.candles.update(candle);
      this.series.volume.update(volume);
    }
    addSignalMarker(signal) {
      if (!this.series.candles) return;
      const styles = getComputedStyle(document.body);
      const marker = {
        time: signal.timestamp / 1000,
        position: signal.direction === 'buy' ? 'belowBar' : 'aboveBar',
        color: signal.direction === 'buy' ? styles.getPropertyValue('--positive').trim() : styles.getPropertyValue('--negative').trim(),
        shape: signal.direction === 'buy' ? 'arrowUp' : 'arrowDown',
        text: `Skor: ${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score} @ ${this._formatMarkerPrice(signal.price)}`
      };
      this.signalMarkers.push(marker);
      this.series.candles.setMarkers(this.signalMarkers);
    }
    clearMarkers() { if (!this.series.candles) return; this.signalMarkers = []; this.series.candles.setMarkers([]); }
    zoom(factor) {
      if (!this.chart) return;
      const timeScale = this.chart.timeScale();
      const currentLogicalRange = timeScale.getVisibleLogicalRange();
      if (!currentLogicalRange) return;
      const newLogicalRange = { from: currentLogicalRange.from * factor, to: currentLogicalRange.to * factor };
      timeScale.setVisibleLogicalRange(newLogicalRange);
    }
    zoomIn() { this.zoom(0.9); }
    zoomOut() { this.zoom(1.1); }
    resetZoom() { if (this.chart) this.chart.timeScale().fitContent(); }

    _getDecimalPlacesBasedOnPrice(price) { if(!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
    _formatMarkerPrice(price) { const d = this._getDecimalPlacesBasedOnPrice(price); return price.toFixed(d); }
    _getChartOptions() {
      const styles = getComputedStyle(document.body);
      return {
        width: this.chartContainer.clientWidth, height: this.chartContainer.clientHeight,
        layout: { backgroundColor: 'transparent', textColor: styles.getPropertyValue('--text-main').trim(), fontFamily: "'Roboto Mono', monospace" },
        grid: { vertLines: { color: styles.getPropertyValue('--border-color').trim() }, horzLines: { color: styles.getPropertyValue('--border-color').trim() } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        timeScale: { borderColor: styles.getPropertyValue('--border-color').trim(), timeVisible: true, secondsVisible: false, rightOffset: 10 }
      };
    }
    _getCandlestickOptions() {
      const styles = getComputedStyle(document.body);
      return { 
        upColor: styles.getPropertyValue('--positive').trim(), downColor: styles.getPropertyValue('--negative').trim(),
        borderVisible: false, wickUpColor: styles.getPropertyValue('--positive').trim(), wickDownColor: styles.getPropertyValue('--negative').trim(),
        priceFormat: { type: 'price', precision: 6, minMove: 0.000001 }
      };
    }
    _getVolumeOptions() { return { priceFormat: { type: 'volume' }, priceScaleId: '', scaleMargins: { top: 0.8, bottom: 0 } }; }
  }

  class HeatmapManager {
    constructor(canvasId) {
      this.canvas = document.getElementById(canvasId);
      if (!this.canvas) throw new Error("Heatmap canvas bulunamadÄ±!");
      this.ctx = this.canvas.getContext('2d');
      this._resizeCanvas();
      window.addEventListener('resize', () => this._resizeCanvas());
    }
    draw(orderBook, symbolPrice) {
      if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); return; };
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      const asks = orderBook.asks.slice().reverse(); const bids = orderBook.bids;
      const allLevels = [...bids, ...asks]; const maxQty = Math.max(...allLevels.map(l => l[1]));
      this._drawSection(asks, 'asks', maxQty, symbolPrice); this._drawSection(bids, 'bids', maxQty, symbolPrice);
    }
    updateTheme() { this._resizeCanvas(); }
    _drawSection(levels, type, maxQty, symbolPrice) {
      const styles = getComputedStyle(document.body);
      const baseColor = type === 'asks' ? styles.getPropertyValue('--negative').trim() : styles.getPropertyValue('--positive').trim();
      if (levels.length === 0) return;
      const heightPerLevel = (this.canvas.height / 2) / levels.length;
      const priceDecimals = this._getDecimalPlaces(symbolPrice);
      const labelSkipInterval = heightPerLevel < 12 ? Math.ceil(12 / heightPerLevel) : 1;
      levels.forEach((level, index) => {
        const [price, qty] = level;
        const intensity = Math.min(Math.sqrt(qty / maxQty), 1.0);
        this.ctx.fillStyle = this._hexToRgba(baseColor, intensity * 0.6 + 0.1);
        const y = type === 'asks' ? index * heightPerLevel : (this.canvas.height / 2) + (index * heightPerLevel);
        const barWidth = this.canvas.width * intensity;
        this.ctx.fillRect(0, y, barWidth, heightPerLevel);
        if (index % labelSkipInterval === 0) {
          this.ctx.fillStyle = intensity > 0.5 ? '#FFFFFF' : styles.getPropertyValue('--text-secondary').trim();
          this.ctx.font = '10px "Roboto Mono"'; this.ctx.textAlign = 'left';
          this.ctx.fillText(`${(qty).toFixed(2)} @ ${price.toFixed(priceDecimals)}`, 10, y + heightPerLevel - 3);
        }
      });
    }
    _getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
    _hexToRgba(hex, alpha) {
      if(!hex.startsWith('#')) return `rgba(120,120,120,${alpha})`;
      let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    _resizeCanvas() { 
      if(this.canvas.parentElement) {
        this.canvas.width = this.canvas.parentElement.clientWidth; 
        this.canvas.height = this.canvas.parentElement.clientHeight; 
      }
    }
  }

  /* =========================
     STRATEJÄ°LER (dinamik skorlu)
     ========================= */
  class Strategy {
    constructor(bot, name) { 
      this.bot = bot; this.name = name; this.displayName = this._getDisplayName(name); 
      this.lastProposalTime = {};
      this.DEFAULT_PROPOSAL_COOLDOWN_MS = 10000; // dynamic baseline
    }
    propose(symbol, direction, reason, score) {
      const now = Date.now(); 
      const key = `${symbol}-${direction}`;
      const cooldown = (this.DEFAULT_PROPOSAL_COOLDOWN_MS ?? 10000);
      if (now - (this.lastProposalTime[key] || 0) < cooldown) return;

      // Shadow: arkaplanda paper trade kaydÄ±
      if (this.bot?.isShadowed?.(this.name) && this.bot.marketData?.price) {
        this.bot.recordPaperProposal(this.name, direction, this.bot.marketData.price);
      }

      this.bot.confluenceEngine.propose(this.name, direction, reason, score);
      this.lastProposalTime[key] = now;
    }
    _getDisplayName(name) { return name.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()); }
    analyzeOrderBook(orderBook) {}
    processTrade(trade) {}
    periodicAnalyze() {}
  }

  class WallBounceStrategy extends Strategy {
    constructor(bot) { super(bot, 'wallBounce'); this.DISTANCE_THRESHOLD_PERCENT = 0.05 / 100; }
    analyzeOrderBook(orderBook) {
      const currentPrice = this.bot.marketData.price; if (!currentPrice) return;
      const btcPrice = this.bot.marketData.btcPrice || 70000;
      const wallQuantityThreshold = (this.bot.settings.params.wallBtc * btcPrice) / currentPrice;
      for (const [price, qty] of orderBook.asks) { 
        if (qty > wallQuantityThreshold) { 
          const distance = (price - currentPrice) / currentPrice; 
          if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
            const strength = Math.min(10, 2 + (wallQuantityThreshold > 0 ? (qty / wallQuantityThreshold) : 0));
            this.propose(this.bot.currentSymbol, 'sell', `SatÄ±Å DuvarÄ± ${price.toFixed(this.bot.getDecimalPlaces(price))}`, strength); return; 
          } 
        } 
      }
      for (const [price, qty] of orderBook.bids) { 
        if (qty > wallQuantityThreshold) { 
          const distance = (currentPrice - price) / currentPrice; 
          if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
            const strength = Math.min(10, 2 + (wallQuantityThreshold > 0 ? (qty / wallQuantityThreshold) : 0));
            this.propose(this.bot.currentSymbol, 'buy', `AlÄ±Å DuvarÄ± ${price.toFixed(this.bot.getDecimalPlaces(price))}`, strength); return; 
          } 
        } 
      }
    }
  }
  class VelocityScalpingStrategy extends Strategy {
    constructor(bot) { super(bot, 'velocityScalping'); this.pricePoints = []; this.VELOCITY_WINDOW_MS = 2000; this.MIN_POINTS = 20; this.VELOCITY_THRESHOLD_PERCENT = 0.10 / 100; }
    processTrade(trade) {
      const now = Date.now(); 
      this.pricePoints.push({ time: now, price: trade.price }); 
      this.pricePoints = this.pricePoints.filter(p => now - p.time < this.VELOCITY_WINDOW_MS); 
      if (this.pricePoints.length < this.MIN_POINTS) return;
      const firstPoint = this.pricePoints[0]; const lastPoint = this.pricePoints[this.pricePoints.length - 1]; 
      const priceChange = (lastPoint.price - firstPoint.price) / firstPoint.price;
      const intensity = Math.min(1, Math.abs(priceChange) / this.VELOCITY_THRESHOLD_PERCENT);
      const strength = Math.min(10, 2 + intensity * 8);
      if (priceChange > this.VELOCITY_THRESHOLD_PERCENT) { 
        this.propose(this.bot.currentSymbol, 'buy', `Fiyat HÄ±zÄ±: +${(priceChange * 100).toFixed(2)}%`, strength); this.pricePoints = []; 
      } else if (priceChange < -this.VELOCITY_THRESHOLD_PERCENT) { 
        this.propose(this.bot.currentSymbol, 'sell', `Fiyat HÄ±zÄ±: ${(priceChange * 100).toFixed(2)}%`, strength); this.pricePoints = []; 
      }
    }
  }
  class RsiDivergenceStrategy extends Strategy {
    constructor(bot) { super(bot, 'rsiDivergence'); }
    periodicAnalyze() {
      const candles = this.bot.candles; const rsiValues = this.bot.indicators.rsi; const lookback = this.bot.settings.params.rsiPeriod;
      if (!rsiValues || rsiValues.length < lookback || !candles || candles.length < lookback) return;
      const lastCandle = candles[candles.length - 1]; const prevCandle = candles[candles.length - lookback]; 
      const lastRsi = rsiValues[rsiValues.length - 1]; const prevRsi = rsiValues[rsiValues.length - lookback];
      if (!lastCandle || !prevCandle || !isFinite(lastRsi) || !isFinite(prevRsi)) return;

      const swingPct = Math.abs((lastCandle.close - prevCandle.close) / Math.max(1e-8, prevCandle.close));
      const rsiGap = Math.abs((lastRsi - prevRsi) / 100);
      const strength = Math.max(0, Math.min(10, (rsiGap * 6 + swingPct * 50)));

      if (lastCandle.high > prevCandle.high && lastRsi < prevRsi) { this.propose(this.bot.currentSymbol, 'sell', 'RSI AyÄ± UyuÅmazlÄ±ÄÄ±', strength); }
      if (lastCandle.low < prevCandle.low && lastRsi > prevRsi) { this.propose(this.bot.currentSymbol, 'buy', 'RSI BoÄa UyuÅmazlÄ±ÄÄ±', strength); }
    }
  }
  class OrderFlowMomentumStrategy extends Strategy {
    constructor(bot) { super(bot, 'orderFlowMomentum'); this.trades = []; this.WINDOW_MS = 5000; }
    processTrade(trade) {
      const now = Date.now(); 
      this.trades.push(trade); 
      this.trades = this.trades.filter(t => now - t.timestamp < this.WINDOW_MS); 
      if (this.trades.length < 50) return;
      const buys = this.trades.filter(t => !t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0); 
      const sells = this.trades.filter(t => t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0);
      const total = buys + sells; if (total === 0) return; 
      const ratio = Math.abs(buys - sells) / total; // 0..1
      const strength = Math.min(10, 2 + ratio * 8);
      if (buys / total > 0.7) { this.propose(this.bot.currentSymbol, 'buy', `AlÄ±cÄ± AkÄ±ÅÄ±: %${(buys / total * 100).toFixed(0)}`, strength); this.trades = []; }
      else if (sells / total > 0.7) { this.propose(this.bot.currentSymbol, 'sell', `SatÄ±cÄ± AkÄ±ÅÄ±: %${(sells / total * 100).toFixed(0)}`, strength); this.trades = []; }
    }
  }
  class LiquidityGapsStrategy extends Strategy {
    constructor(bot) { super(bot, 'liquidityGaps'); this.GAP_THRESHOLD_PERCENT = 0.1 / 100; }
    analyzeOrderBook(orderBook) {
      for (let i = 0; i < orderBook.asks.length - 1; i++) { 
        const gap = orderBook.asks[i + 1][0] - orderBook.asks[i][0]; 
        if ((gap / orderBook.asks[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
          const strength = Math.min(10, 2 + (gap / orderBook.asks[i][0]) * 300);
          this.propose(this.bot.currentSymbol, 'buy', `Likidite BoÅluÄu ${orderBook.asks[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.asks[i][0]))}`, strength); return; 
        } 
      }
      for (let i = 0; i < orderBook.bids.length - 1; i++) { 
        const gap = orderBook.bids[i][0] - orderBook.bids[i + 1][0]; 
        if ((gap / orderBook.bids[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
          const strength = Math.min(10, 2 + (gap / orderBook.bids[i][0]) * 300);
          this.propose(this.bot.currentSymbol, 'sell', `Likidite BoÅluÄu ${orderBook.bids[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.bids[i][0]))}`, strength); return; 
        } 
      }
    }
  }
  class BreakoutPatternStrategy extends Strategy {
    constructor(bot) { super(bot, 'breakoutPattern'); this.LOOKBACK = 30; this.VOL_SPIKE = 1.4; this.BREAK_PCT = 0.03/100; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < this.LOOKBACK + 1) return;
      const recent = c.slice(-this.LOOKBACK-1);
      const highs = recent.map(x=>x.high), lows = recent.map(x=>x.low), vols = recent.map(x=>x.volume);
      const last = recent[recent.length-1]; 
      const maxH = Math.max(...highs.slice(0, -1)); const minL = Math.min(...lows.slice(0, -1));
      const volSma = vols.slice(0, -1).reduce((a,b)=>a+b,0) / (vols.length-1);
      const volIntensity = Math.min(1.5, last.volume / Math.max(1e-8, volSma));
      const strength = Math.min(10, 2 + (volIntensity-1) * 10);
      if (last.close > maxH * (1 + this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
        this.propose(this.bot.currentSymbol, 'buy', 'AralÄ±k ÃstÃ¼ Hacimli KÄ±rÄ±lÄ±m', strength);
      } else if (last.close < minL * (1 - this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
        this.propose(this.bot.currentSymbol, 'sell', 'AralÄ±k AltÄ± Hacimli KÄ±rÄ±lÄ±m', strength);
      }
    }
  }
  class SupportResistanceStrategy extends Strategy {
    constructor(bot) { super(bot, 'supportResistance'); this.LOOKBACK = 60; this.THRESH = 0.15/100; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
      const slice = c.slice(-this.LOOKBACK);
      const last = slice[slice.length-1];
      const maxH = Math.max(...slice.map(x=>x.high)); const minL = Math.min(...slice.map(x=>x.low));
      const distTop = (maxH - last.close)/last.close; const distBot = (last.close - minL)/last.close;
      const proximity = 1 - Math.min(1, Math.min(distTop, distBot) / this.THRESH);
      const strength = Math.min(10, 2 + Math.max(0, proximity) * 8);
      if (distTop >= 0 && distTop < this.THRESH && last.close < last.open) {
        this.propose(this.bot.currentSymbol, 'sell', 'DirenÃ§ BÃ¶lgesi Reddi', strength);
      }
      if (distBot >= 0 && distBot < this.THRESH && last.close > last.open) {
        this.propose(this.bot.currentSymbol, 'buy', 'Destek BÃ¶lgesi Tepkisi', strength);
      }
    }
  }
  class FibonacciRetracementStrategy extends Strategy {
    constructor(bot) { super(bot, 'fibonacciRetracement'); this.LOOKBACK = 120; this.TOL = 0.2/100; this.levels = [0.382, 0.5, 0.618]; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
      const slice = c.slice(-this.LOOKBACK);
      let high = -Infinity, low = Infinity, hT=0, lT=0;
      slice.forEach(k => { if(k.high > high){high=k.high; hT=k.time;} if(k.low < low){low=k.low; lT=k.time;} });
      if (!isFinite(high) || !isFinite(low) || high===low) return;
      const last = slice[slice.length-1];
      if (hT > lT) { // uptrend: low -> high
        const retr = (high - last.close) / (high - low);
        for (const L of this.levels) {
          if (Math.abs(retr - L) < this.TOL) { 
            const strength = Math.min(10, 2 + (this.TOL - Math.abs(retr - L)) * 2000);
            this.propose(this.bot.currentSymbol, 'buy', `Fibo ${Math.round(L*100)}% BÃ¶lgesi`, strength); break; 
          }
        }
      } else { // downtrend: high -> low
        const retr = (last.close - low) / (high - low);
        for (const L of this.levels) {
          if (Math.abs(retr - L) < this.TOL) { 
            const strength = Math.min(10, 2 + (this.TOL - Math.abs(retr - L)) * 2000);
            this.propose(this.bot.currentSymbol, 'sell', `Fibo ${Math.round(L*100)}% BÃ¶lgesi`, strength); break; 
          }
        }
      }
    }
  }
  class VolumeProfileStrategy extends Strategy {
    constructor(bot) { super(bot, 'volumeProfile'); this.PERIOD = 20; this.SPIKE = 2.0; this.CLOSE_POS = 0.7; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < this.PERIOD + 1) return;
      const last = c[c.length-1];
      const vols = c.slice(-this.PERIOD-1, -1).map(x=>x.volume);
      const volSma = vols.reduce((a,b)=>a+b,0)/vols.length;
      const posUp = (last.close - last.low) / Math.max(1e-8,(last.high - last.low));
      const posDn = (last.high - last.close) / Math.max(1e-8,(last.high - last.low));
      const intensity = Math.min(2, last.volume / Math.max(1e-8, volSma));
      const strength = Math.min(10, 2 + (intensity-1)*8);
      if (last.volume > volSma * this.SPIKE && posUp > this.CLOSE_POS) {
        this.propose(this.bot.currentSymbol, 'buy', 'Hacim Spike - Ãst KapanÄ±Å', strength);
      } else if (last.volume > volSma * this.SPIKE && posDn > this.CLOSE_POS) {
        this.propose(this.bot.currentSymbol, 'sell', 'Hacim Spike - Alt KapanÄ±Å', strength);
      }
    }
  }
  class SmartMoneyConceptsStrategy extends Strategy {
    constructor(bot) { super(bot, 'smartMoneyConcepts'); this.GAP_MIN_PCT = 0.05/100; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < 3) return;
      const a = c[c.length-3], b = c[c.length-2], d = c[c.length-1];
      if ((d.low - a.high)/Math.max(1e-8, d.low) > this.GAP_MIN_PCT) this.propose(this.bot.currentSymbol, 'buy', 'Bullish FVG', 4);
      if ((a.low - d.high)/Math.max(1e-8, d.high) > this.GAP_MIN_PCT) this.propose(this.bot.currentSymbol, 'sell', 'Bearish FVG', 4);
    }
  }
  class DivergenceDetectionStrategy extends Strategy {
    constructor(bot) { super(bot, 'divergenceDetection'); this.LOOKBACK = 40; this.SWING = 3; }
    periodicAnalyze() {
      const c = this.bot.candles; const rsi = this.bot.indicators.rsi; 
      if (!rsi || c.length < this.LOOKBACK || rsi.length < this.LOOKBACK) return;
      const slice = c.slice(-this.LOOKBACK), r = rsi.slice(-this.LOOKBACK);
      const pivLows = []; const pivHighs = [];
      for (let i = this.SWING; i < slice.length - this.SWING; i++) {
        if (slice[i].low < Math.min(...slice.slice(i-this.SWING, i).map(x=>x.low)) && slice[i].low < Math.min(...slice.slice(i+1, i+1+this.SWING).map(x=>x.low))) pivLows.push(i);
        if (slice[i].high > Math.max(...slice.slice(i-this.SWING, i).map(x=>x.high)) && slice[i].high > Math.max(...slice.slice(i+1, i+1+this.SWING).map(x=>x.high))) pivHighs.push(i);
      }
      if (pivLows.length >= 2) {
        const i1 = pivLows[pivLows.length-2], i2 = pivLows[pivLows.length-1];
        const strength = Math.min(10, 2 + Math.abs(r[i2] - r[i1]) / 10);
        if (slice[i2].low < slice[i1].low && r[i2] > r[i1]) this.propose(this.bot.currentSymbol, 'buy', 'Bullish RSI Divergence (Pivot)', strength);
      }
      if (pivHighs.length >= 2) {
        const i1 = pivHighs[pivHighs.length-2], i2 = pivHighs[pivHighs.length-1];
        const strength = Math.min(10, 2 + Math.abs(r[i2] - r[i1]) / 10);
        if (slice[i2].high > slice[i1].high && r[i2] < r[i1]) this.propose(this.bot.currentSymbol, 'sell', 'Bearish RSI Divergence (Pivot)', strength);
      }
    }
  }
  class MarketStructureStrategy extends Strategy {
    constructor(bot) { super(bot, 'marketStructure'); this.SWING = 3; }
    periodicAnalyze() {
      const c = this.bot.candles; if (c.length < 2*this.SWING+5) return;
      const pivotHighs = [], pivotLows = [];
      for (let i = this.SWING; i < c.length - this.SWING; i++) {
        if (c[i].high > Math.max(...c.slice(i-this.SWING, i).map(x=>x.high)) && c[i].high > Math.max(...c.slice(i+1, i+1+this.SWING).map(x=>x.high))) pivotHighs.push(i);
        if (c[i].low < Math.min(...c.slice(i-this.SWING, i).map(x=>x.low)) && c[i].low < Math.min(...c.slice(i+1, i+1+this.SWING).map(x=>x.low))) pivotLows.push(i);
      }
      const last = c[c.length-1];
      const lastPH = pivotHighs.length ? c[pivotHighs[pivotHighs.length-1]].high : null;
      const lastPL = pivotLows.length ? c[pivotLows[pivotLows.length-1]].low : null;
      if (lastPH && last.close > lastPH) this.propose(this.bot.currentSymbol, 'buy', 'YapÄ± KÄ±rÄ±lÄ±mÄ± (BOS Up)', 4);
      if (lastPL && last.close < lastPL) this.propose(this.bot.currentSymbol, 'sell', 'YapÄ± KÄ±rÄ±lÄ±mÄ± (BOS Down)', 4);
    }
  }
  class InstitutionalOrderFlowStrategy extends Strategy {
    constructor(bot) { super(bot, 'institutionalOrderFlow'); this.TOP_N = 5; this.IMB_THRESHOLD = 2.0; }
    analyzeOrderBook(orderBook) {
      if (!orderBook.bids.length || !orderBook.asks.length) return;
      const topB = orderBook.bids.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
      const topA = orderBook.asks.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
      const ratio = Math.max(topB, topA) / Math.max(1e-8, Math.min(topB, topA));
      const strength = Math.min(10, 2 + (ratio-1) * 4);
      if (topB / Math.max(1e-8, topA) > this.IMB_THRESHOLD) {
        this.propose(this.bot.currentSymbol, 'buy', 'Orderbook Ä°mbalansÄ± (Bid AÄÄ±rlÄ±k)', strength);
      } else if (topA / Math.max(1e-8, topB) > this.IMB_THRESHOLD) {
        this.propose(this.bot.currentSymbol, 'sell', 'Orderbook Ä°mbalansÄ± (Ask AÄÄ±rlÄ±k)', strength);
      }
    }
  }
  class MicroSpreadArbitrageStrategy extends Strategy {
    constructor(bot) { super(bot, 'microSpreadArbitrage'); this.SPREAD_PCT = 0.08/100; }
    analyzeOrderBook(orderBook) {
      if (!orderBook.bids.length || !orderBook.asks.length) return;
      const bestBid = orderBook.bids[0][0], bestAsk = orderBook.asks[0][0];
      const mid = (bestAsk + bestBid)/2;
      const spreadPct = (bestAsk - bestBid) / mid;
      if (spreadPct > this.SPREAD_PCT) {
        const current = this.bot.marketData.price || mid;
        const strength = Math.min(10, 2 + (spreadPct / this.SPREAD_PCT - 1) * 3);
        if (current < mid) this.propose(this.bot.currentSymbol, 'buy', 'GeniÅ Spread - Mean Reversion', strength);
        else this.propose(this.bot.currentSymbol, 'sell', 'GeniÅ Spread - Mean Reversion', strength);
      }
    }
  }
  class VWAPReversionStrategy extends Strategy {
    constructor(bot) { super(bot, 'vwapReversion'); this.MULT = 1.0; }
    periodicAnalyze() {
      const price = this.bot.marketData.price, vwap = this.bot.indicators.vwap, atr = this.bot.indicators.atr;
      if (!price || !vwap || !atr) return;
      const dev = atr / price; 
      const diffPct = (price - vwap) / vwap;
      const intensity = Math.abs(diffPct) / Math.max(1e-8, this.MULT * dev);
      const strength = Math.min(10, 2 + Math.min(1, intensity) * 8);
      if (diffPct > this.MULT * dev) this.propose(this.bot.currentSymbol, 'sell', 'VWAP ÃstÃ¼ AÅÄ±rÄ± Sapma', strength);
      if (diffPct < -this.MULT * dev) this.propose(this.bot.currentSymbol, 'buy', 'VWAP AltÄ± AÅÄ±rÄ± Sapma', strength);
    }
  }
  class SuperTrendStrategy extends Strategy {
    constructor(bot) { super(bot, 'superTrend'); this.MULT = 3.0; this.PERIOD = 14; }
    periodicAnalyze() {
      const c = this.bot.candles; const atr = this.bot.indicators.atr;
      if (!atr || c.length < 2) return;
      const last = c[c.length-1];
      const m = (last.high + last.low) / 2;
      const upper = m + this.MULT * atr, lower = m - this.MULT * atr;
      const delta = Math.abs(last.close - m) / Math.max(1e-8, atr * this.MULT);
      const strength = Math.min(10, 2 + Math.min(1, delta) * 8);
      if (last.close > upper) this.propose(this.bot.currentSymbol, 'buy', 'ATR Kanal ÃstÃ¼ KÄ±rÄ±lÄ±m (SuperTrend)', strength);
      else if (last.close < lower) this.propose(this.bot.currentSymbol, 'sell', 'ATR Kanal AltÄ± KÄ±rÄ±lÄ±m (SuperTrend)', strength);
    }
  }

  /* =========================
     UYUM MOTORU (CONFLUENCE) + shadow/muted
     ========================= */
  class ConfluenceEngine {
    constructor(bot) { 
      this.bot = bot; 
      this.proposals = []; 
      this.lastSignalTime = 0; 
      this.lastSignalTimeByDirection = { buy: 0, sell: 0 };
      this.lastDirection = null;
    }
    propose(strategy, direction, reason, score) {
      const now = Date.now();
      this.proposals = this.proposals.filter(p => !(p.strategy === strategy));
      this.proposals.push({ strategy, direction, reason, score, timestamp: now, muted: this.bot.isShadowed(strategy) });
      const s = this.bot.strategyStats[strategy] || { alpha:3, beta:2, proposals:0, contrib:0, wins:0, losses:0, lastUpdate: now };
      s.proposals += 1; s.lastUpdate = now; this.bot.strategyStats[strategy] = s; this.bot.saveStrategyStats();
      this.checkConfluence();
    }

    _computeDirectional(direction) {
      const now = Date.now();
      const decaySec = this.bot.settings.optimization.timeDecaySec || 3;
      const groupSums = { trending: 0, meanReversion: 0, neutral: 0 };
      const used = [];
      const arr = this.proposals.filter(p => p.direction === direction);

      for (const p of arr) {
        const w = this.bot.getStrategyWeight(p.strategy);
        const ageSec = (now - p.timestamp)/1000;
        const decay = Math.exp(-ageSec / decaySec);
        let eff = (p.score || 0) * w * decay;

        if (p.muted) {
          const strong = (p.score || 0) >= (this.bot.shadowConfig?.strongScore || 7.5);
          const factor = strong ? 1.0 : (this.bot.shadowConfig?.factor || 0.15);
          eff *= factor;
        }

        const grp = this.bot.getStrategyGroup(p.strategy);
        groupSums[grp] = (groupSums[grp] || 0) + eff;
        used.push({ strategy: p.strategy, baseScore: p.score, weight: w, decay, effScore: eff, muted: !!p.muted });
      }
      const score = Math.sqrt(Math.max(0, groupSums.trending)**2 + Math.max(0, groupSums.meanReversion)**2 + Math.max(0, groupSums.neutral)**2);
      return { score, contributors: used, groupSums };
    }

    checkConfluence() {
      const now = Date.now();
      const cd = this.bot.settings?.cooldowns || {};
      const proposalTimeout = cd.proposalTimeoutMs ?? 3000;
      const signalCooldown = cd.signalMs ?? 15000;
      const sameDirCooldown = cd.sameDirectionMs ?? 30000;
      const oppCooldown = cd.oppositeDirectionMs ?? 20000;
      const reverseHys = cd.reverseHysteresisPoints ?? 2;
      const dirMargin = this.bot.settings.optimization.dirMargin ?? 0.5;
      const minThreshold = this.bot.getEffectiveThreshold();

      if (now - this.lastSignalTime < signalCooldown) return;
      this.proposals = this.proposals.filter(p => now - p.timestamp < proposalTimeout);

      const buy = this._computeDirectional('buy');
      const sell = this._computeDirectional('sell');

      // Penalties (market + HTF)
      const buyPenalty = this.bot.marketGatingPenalty('buy') + this.bot.getHTFPenalty('buy');
      const sellPenalty = this.bot.marketGatingPenalty('sell') + this.bot.getHTFPenalty('sell');

      // Probability gating via online logistic classifier
      const feats = this.bot.buildFeatures(buy, sell);
      const pTP = this.bot.classifier ? this.bot.classifier.predict(feats) : 0.55;
      const pThresh = this.bot.settings.optimization.probThreshold || 0.55;

      let chosen = null;
      if (buy.score >= (minThreshold + buyPenalty) && (buy.score > sell.score + dirMargin)) {
        if (now - this.lastSignalTimeByDirection.buy < sameDirCooldown) return;
        if (this.lastDirection === 'sell' && (now - this.lastSignalTime) < oppCooldown) {
          if (buy.score < (minThreshold + buyPenalty + reverseHys)) return;
        }
        chosen = { dir: 'buy', obj: buy };
      } else if (sell.score >= (minThreshold + sellPenalty) && (sell.score > buy.score + dirMargin)) {
        if (now - this.lastSignalTimeByDirection.sell < sameDirCooldown) return;
        if (this.lastDirection === 'buy' && (now - this.lastSignalTime) < oppCooldown) {
          if (sell.score < (minThreshold + sellPenalty + reverseHys)) return;
        }
        chosen = { dir: 'sell', obj: sell };
      } else {
        return;
      }

      // Probability threshold
      if (pTP < pThresh) return;

      this.generateFinalSignal(chosen.dir, chosen.obj.contributors, feats, pTP);
    }

    generateFinalSignal(direction, contributors, features, prob) {
      const contributingStrats = contributors.map(c => this.bot.strategies[c.strategy]?.displayName || c.strategy).join(', ');
      const weightedScore = contributors.reduce((s,c)=> s + c.effScore, 0);

      const signal = { 
        id: `sig_${Date.now()}`, timestamp: Date.now(), symbol: this.bot.currentSymbol, 
        direction, price: this.bot.marketData.price, score: weightedScore, 
        reason: contributingStrats, contributors, status: 'active', note: '',
        mfeR: 0, beDone: false, trailingStage: 0, features, prob: prob
      };
      this.bot.calculateDynamicTpSl(signal);
      this.bot.addFinalSignal(signal);

      this.proposals = [];
      const now = Date.now();
      this.lastSignalTime = now;
      this.lastSignalTimeByDirection[direction] = now;
      this.lastDirection = direction;
    }
  }

  /* =========================
     ÃEVRÄ°M Ä°ÃÄ° LOJÄ°STÄ°K SINIFLANDIRICI
     ========================= */
  class OnlineLogit {
    constructor(bot){ this.bot = bot; this.key='utc_logit'; this.model = this.bot.loadData(this.key) || { w: [] }; }
    sigmoid(z){ return 1/(1+Math.exp(-z)); }
    predict(feat){ const w=this.model.w; let z=0; for(let i=0;i<feat.length;i++){ z += (w[i]||0)*feat[i]; } return this.sigmoid(z); }
    update(y, feat, lr=0.05, l2=1e-4){
      const p = this.predict(feat);
      const w = this.model.w.length ? this.model.w : Array(feat.length).fill(0);
      for(let i=0;i<feat.length;i++){
        const grad = (p - y)*feat[i] + l2*w[i];
        w[i] = w[i] - lr*grad;
      }
      this.model.w = w; this.bot.saveData(this.key, this.model);
    }
  }

  /* =========================
     ANA UYGULAMA
     ========================= */
  class UltimateTradingCommandCenter {
    constructor() {
      this.allStrategiesMap = {
        'wallBounce': WallBounceStrategy, 'velocityScalping': VelocityScalpingStrategy, 'rsiDivergence': RsiDivergenceStrategy, 
        'orderFlowMomentum': OrderFlowMomentumStrategy, 'liquidityGaps': LiquidityGapsStrategy, 'fibonacciRetracement': FibonacciRetracementStrategy, 
        'volumeProfile': VolumeProfileStrategy, 'smartMoneyConcepts': SmartMoneyConceptsStrategy, 'divergenceDetection': DivergenceDetectionStrategy, 
        'breakoutPattern': BreakoutPatternStrategy, 'supportResistance': SupportResistanceStrategy, 'marketStructure': MarketStructureStrategy, 
        'institutionalOrderFlow': InstitutionalOrderFlowStrategy, 'microSpreadArbitrage': MicroSpreadArbitrageStrategy,
        'vwapReversion': VWAPReversionStrategy, 'superTrend': SuperTrendStrategy
      };
      this.allStrategyKeys = Object.keys(this.allStrategiesMap); 

      this.isRunning = false; 
      this.sockets = {}; 
      
      this.currentSymbol = this.loadData('utc_current_symbol') || 'BTCUSDT'; 
      this.currentTimeframe = this.loadData('utc_current_timeframe') || '15m';
      this.headerCollapsed = this.loadData('utc_header_collapsed') !== null ? (this.loadData('utc_header_collapsed') === 'true') : true; 
      this.currentMainView = this.loadData('utc_current_view') || 'chart';

      this.marketData = {}; 
      this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 
      this.aggTrades = []; 
      this.candles = [];
      this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null }; 
      this.signals = this.loadData('utc_signals') || [];
      this.stats = this.loadData('utc_stats') || { total: 0, tp: 0, sl: 0 };

      // Performans Ã¶Ärenme
      this.strategyStats = this.loadData('utc_strategy_stats') || this.initDefaultStrategyStats();
      this.ctxStats = this.loadData('utc_ctx_stats') || {};
      this.marketRegime = 'unknown';
      this.strategyGroups = {
        trending: ['breakoutPattern','orderFlowMomentum','marketStructure','volumeProfile','smartMoneyConcepts','superTrend'],
        meanReversion: ['vwapReversion','wallBounce','liquidityGaps','fibonacciRetracement','supportResistance','microSpreadArbitrage','divergenceDetection','rsiDivergence','institutionalOrderFlow']
      };
      
      // Shadowban & paper eval
      this.shadow = this.loadData('utc_shadow') || { byStrategy: {} };
      this.paperEval = { queue: [] };
      this.shadowConfig = {
        factor: 0.15,
        strongScore: 7.5,
        probationWinsNeeded: 4,
        probationWindow: 8,
        lookaheadMs: 15*60*1000,
        paperR: 0.5,
        banDurMs: 60*60*1000
      };

      this.settings = this.loadSettings();
      this.strategies = {};
      
      this.combatModeActive = false;
      this.reconnectAttempts = 0;
      this.reconnectDelay = 3000;
      this.chartManager = new ChartManager('live-chart');
      this.heatmapManager = new HeatmapManager('orderbook-heatmap');
      this.confluenceEngine = new ConfluenceEngine(this);
      this.classifier = new OnlineLogit(this);

      this.renderInterval = null; 
      this.analysisInterval = null;
      this.cooldownTuneInterval = null;
      this.thresholdTuneInterval = null;
      this._paperTimer = null;
      this._honorTimer = null;
      this._htfTimer = null;
      this.lastAutoToggleTs = 0;
      this.runtimeThresholdOffset = 0;
      this.riskState = 'neutral';
      this.htfTrend = 'flat';

      this.init();
    }

    initDefaultStrategyStats() {
      const stats = {};
      (this.allStrategyKeys || []).forEach(k => {
        stats[k] = { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0, lastUpdate: Date.now() };
      });
      return stats;
    }
    saveStrategyStats() { this.saveData('utc_strategy_stats', this.strategyStats); }
    saveCtxStats() { this.saveData('utc_ctx_stats', this.ctxStats); }

    getStrategyGroup(key) {
      if (this.strategyGroups.trending.includes(key)) return 'trending';
      if (this.strategyGroups.meanReversion.includes(key)) return 'meanReversion';
      return 'neutral';
    }
    getGroupBoost(key) {
      const grp = this.getStrategyGroup(key);
      let boost = 1.0;
      // Rejim boost
      if (this.marketRegime === 'trend' && grp === 'trending') boost *= 1.15;
      if (this.marketRegime === 'range' && grp === 'meanReversion') boost *= 1.15;
      // ATR gÃ¶re adaptif boost
      const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0;
      if (atrPct < 0.005) { // dÃ¼ÅÃ¼k vol
        if (grp === 'trending') boost *= 0.9;
        if (grp === 'meanReversion') boost *= 1.05;
      } else if (atrPct > 0.02) { // yÃ¼ksek vol
        if (grp === 'trending') boost *= 1.05;
        if (grp === 'meanReversion') boost *= 0.95;
      }
      return boost;
    }

    // BaÄlamsal anahtar
    getContextKey() {
      const regime = this.marketRegime || 'unknown';
      const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0;
      const volBucket = atrPct < 0.005 ? 'vlow' : atrPct < 0.012 ? 'low' : atrPct < 0.02 ? 'mid' : 'high';
      const ob = this.getOrderBookSnapshotInfo() || {};
      const liqBucket = (ob.minTopUsd || 0) < 5e4 ? 'thin' : (ob.minTopUsd < 2e5 ? 'mid' : 'deep');
      return `${regime}|${volBucket}|${liqBucket}|${this.currentTimeframe}`;
    }

    getStrategyWeight(name) {
      const global = this.strategyStats[name] || { alpha:3, beta:2 };
      const ctxKey = this.getContextKey();
      const ctxForStrat = (this.ctxStats[name] && this.ctxStats[name][ctxKey]) || null;
      const pick = ctxForStrat || global;
      const mean = pick.alpha / (pick.alpha + pick.beta);
      const variance = (pick.alpha * pick.beta) / (Math.pow(pick.alpha + pick.beta, 2) * (pick.alpha + pick.beta + 1));
      const uncertaintyPenalty = Math.max(0.75, 1 - Math.sqrt(variance) * 3);
      let w = (0.5 + mean) * uncertaintyPenalty;
      w *= this.getGroupBoost(name);
      w = Math.max(0.25, Math.min(2.2, w));
      return w;
    }

    init() {
      this.initStrategies(); 
      this.setupUI(); 
      this.setupEventListeners();
      this.renderSignals(true);
      this.renderStats(true);
      this.logToJournal('Sistem hazÄ±r. "SÄ°STEMÄ° BAÅLAT" butonuna tÄ±klayÄ±n.');
      
      if (this.headerCollapsed) document.body.classList.add('header-collapsed'); else document.body.classList.remove('header-collapsed');
      this.switchMainView(this.currentMainView);
    }

    initStrategies() {
  this.strategies = {};
  for (const key in this.allStrategiesMap) {
    const StrategyClass = this.allStrategiesMap[key];  // sÄ±nÄ±fÄ± al
    this.strategies[key] = new StrategyClass(this);    // Ã¶rnekle ve bot referansÄ± ver
  }
  this.updateActiveStrategies();
}
    updateActiveStrategies() { 
      for (const key in this.strategies) { this.strategies[key].DEFAULT_PROPOSAL_COOLDOWN_MS = this.settings.cooldowns.strategyProposalMs; } 
      this.activeStrategies = {}; 
      for (const key in this.strategies) { if (this.settings.activeStrategies[key]) this.activeStrategies[key] = this.strategies[key]; } 
    }

    setupUI() {
      document.getElementById('symbol-input').value = this.currentSymbol.replace('USDT', '');
      document.getElementById('timeframe-select').value = this.currentTimeframe;

      this.updateSettingsModalUI();
      const savedTheme = localStorage.getItem('utc_theme') || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme);
      this.chartManager.updateTheme(); 
      this.heatmapManager.updateTheme();
      this.updateSuperTopTicker();
    }
    updateSuperTopTicker() { document.getElementById('ticker-bar-symbol').textContent = this.currentSymbol.replace('USDT', '/USDT'); }

    updateSettingsModalUI() {
      document.getElementById('modal-confluence-threshold').value = this.settings.confluenceThreshold;
      document.getElementById('modal-param-rsi-period').value = this.settings.params.rsiPeriod;
      document.getElementById('modal-param-atr-period').value = this.settings.params.atrPeriod;
      document.getElementById('modal-param-wall-btc').value = this.settings.params.wallBtc;
      document.getElementById('modal-param-rr-ratio').value = this.settings.params.rrRatio;
      document.getElementById('modal-signal-cooldown-ms').value = this.settings.cooldowns.signalMs;
      document.getElementById('modal-same-direction-cooldown-ms').value = this.settings.cooldowns.sameDirectionMs;
      document.getElementById('modal-opposite-direction-cooldown-ms').value = this.settings.cooldowns.oppositeDirectionMs;
      document.getElementById('modal-reverse-hysteresis-points').value = this.settings.cooldowns.reverseHysteresisPoints;
      document.getElementById('modal-proposal-timeout-ms').value = this.settings.cooldowns.proposalTimeoutMs;
      document.getElementById('modal-strategy-proposal-cooldown-ms').value = this.settings.cooldowns.strategyProposalMs;

      const strategyModalContainer = document.getElementById('modal-strategy-toggles');
      strategyModalContainer.innerHTML = '';
      this.allStrategyKeys.forEach(key => { 
        const strategy = this.strategies[key];
        const isChecked = this.settings.activeStrategies[key];
        const isShadow = this.isShadowed(key);
        const toggleHtml = `<div class="form-group"><label class="checkbox-label">
          <input type="checkbox" class="strategy-toggle" data-strategy-key="${key}" ${isChecked ? 'checked' : ''}> ${strategy.displayName}${isShadow ? ' <span style="color:#ffc107;font-size:10px;">[shadow]</span>' : ''}
        </label></div>`;
        strategyModalContainer.innerHTML += toggleHtml;
      });
      this.renderSignals(true); 
      this.renderStats(true);   
    }

    setupEventListeners() {
      document.getElementById('start-btn').addEventListener('click', () => this.start());
      document.getElementById('stop-btn').addEventListener('click', () => this.stop());
      document.getElementById('theme-toggle-btn').addEventListener('click', () => this.toggleTheme());
      document.getElementById('symbol-input').addEventListener('change', (e) => {
        let newSymbol = e.target.value.toUpperCase();
        if (!newSymbol.endsWith('USDT')) newSymbol += 'USDT';
        this.changeSymbol(newSymbol);
        this.saveData('utc_current_symbol', newSymbol);
      });
      document.getElementById('timeframe-select').addEventListener('change', (e) => {
        this.changeTimeframe(e.target.value);
        this.saveData('utc_current_timeframe', e.target.value);
      });
      document.getElementById('header-main-bar').addEventListener('dblclick', () => {
        this.toggleControlsPanel();
        this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
      });
      document.getElementById('main-controls-btn').addEventListener('click', () => {
        this.toggleControlsPanel();
        this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
      });
      document.getElementById('chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
      document.getElementById('heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
      document.getElementById('open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
      document.getElementById('clear-markers-btn').addEventListener('click', () => this.clearChartMarkers()); 
      document.getElementById('chart-zoom-in').addEventListener('click', () => this.chartManager.zoomIn());
      document.getElementById('chart-zoom-out').addEventListener('click', () => this.chartManager.zoomOut());
      document.getElementById('chart-zoom-reset').addEventListener('click', () => this.chartManager.resetZoom());
      document.getElementById('close-settings-modal-btn').addEventListener('click', () => this.closeSettingsModal());
      document.getElementById('settings-modal-overlay').addEventListener('click', (e) => { if (e.target.id === 'settings-modal-overlay') this.closeSettingsModal(); });

      document.getElementById('modal-confluence-threshold').addEventListener('input', (e) => this.settings.confluenceThreshold = parseInt(e.target.value));
      document.getElementById('modal-param-rsi-period').addEventListener('change', (e) => this.settings.params.rsiPeriod = parseInt(e.target.value));
      document.getElementById('modal-param-atr-period').addEventListener('change', (e) => this.settings.params.atrPeriod = parseInt(e.target.value));
      document.getElementById('modal-param-wall-btc').addEventListener('change', (e) => this.settings.params.wallBtc = parseInt(e.target.value));
      document.getElementById('modal-param-rr-ratio').addEventListener('change', (e) => this.settings.params.rrRatio = parseFloat(e.target.value));
      document.getElementById('modal-signal-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.signalMs = parseInt(e.target.value) || 0);
      document.getElementById('modal-same-direction-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.sameDirectionMs = parseInt(e.target.value) || 0);
      document.getElementById('modal-opposite-direction-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.oppositeDirectionMs = parseInt(e.target.value) || 0);
      document.getElementById('modal-reverse-hysteresis-points').addEventListener('change', (e) => this.settings.cooldowns.reverseHysteresisPoints = parseInt(e.target.value) || 0);
      document.getElementById('modal-proposal-timeout-ms').addEventListener('change', (e) => this.settings.cooldowns.proposalTimeoutMs = parseInt(e.target.value) || 1000);
      document.getElementById('modal-strategy-proposal-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.strategyProposalMs = parseInt(e.target.value) || 0);

      document.getElementById('modal-strategy-toggles').addEventListener('change', (e) => {
        if (e.target.classList.contains('strategy-toggle')) {
          const key = e.target.dataset.strategyKey;
          this.settings.activeStrategies[key] = e.target.checked;
          this.updateActiveStrategies(); 
          this.showNotification(`${this.strategies[key].displayName} ${e.target.checked ? 'aktif' : 'pasif'}.`, 'info');
          this.saveSettings();
        }
      });

      document.getElementById('modal-clear-signals-btn').addEventListener('click', () => this.clearAllSignals());
      document.getElementById('reset-all-settings-btn').addEventListener('click', () => this.resetAllSettings());
      document.getElementById('save-settings-btn').addEventListener('click', () => { this.saveSettings(); this.showNotification('Ayarlar kaydedildi!', 'success'); this.closeSettingsModal(); });

      // Åeref panosu
      document.getElementById('honor-btn').addEventListener('click', () => this.openBoardModal('honor'));
      document.getElementById('dishonor-btn').addEventListener('click', () => this.openBoardModal('dishonor'));
      document.getElementById('banned-btn').addEventListener('click', () => this.openBoardModal('banned'));
      document.getElementById('close-board-modal-btn').addEventListener('click', () => this.closeBoardModal());
      document.getElementById('board-modal-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'board-modal-overlay') this.closeBoardModal();
      });
    }

    toggleControlsPanel() {
      document.body.classList.toggle('header-collapsed');
      this.headerCollapsed = document.body.classList.contains('header-collapsed'); 
      setTimeout(() => { window.dispatchEvent(new Event('resize')); }, 360);
    }
    switchMainView(viewName) {
      this.currentMainView = viewName;
      const chartView = document.getElementById('chart-container-view');
      const heatmapView = document.getElementById('heatmap-container-view');
      if (viewName === 'chart') {
        chartView.classList.remove('hidden-view'); heatmapView.classList.add('hidden-view');
        setTimeout(() => { this.chartManager.chart.resize(chartView.clientWidth, chartView.clientHeight); this.chartManager.chart.timeScale().fitContent(); }, 0); 
      } else {
        chartView.classList.add('hidden-view'); heatmapView.classList.remove('hidden-view');
        setTimeout(() => { this.heatmapManager._resizeCanvas(); }, 0); 
      }
    }

    openSettingsModal() { this.updateSettingsModalUI(); document.getElementById('settings-modal-overlay').classList.add('visible'); }
    closeSettingsModal() { document.getElementById('settings-modal-overlay').classList.remove('visible'); this.updateActiveStrategies(); this.calculateAllIndicators(); window.dispatchEvent(new Event('resize')); }

    openBoardModal() { document.getElementById('board-modal-overlay').classList.add('visible'); this.renderHonorBoards(); }
    closeBoardModal() { document.getElementById('board-modal-overlay').classList.remove('visible'); }

    resetAllSettings() {
      if (confirm('TÃ¼m ayarlarÄ± ve sinyal geÃ§miÅini sÄ±fÄ±rlamak istediÄinizden emin misiniz? Bu iÅlem geri alÄ±namaz.')) {
        localStorage.removeItem('utc_settings');
        localStorage.removeItem('utc_signals');
        localStorage.removeItem('utc_stats');
        localStorage.removeItem('utc_strategy_stats');
        localStorage.removeItem('utc_ctx_stats');
        localStorage.removeItem('utc_shadow');
        localStorage.removeItem('utc_logit');
        localStorage.removeItem('utc_current_symbol'); 
        localStorage.removeItem('utc_current_timeframe'); 
        localStorage.removeItem('utc_header_collapsed'); 
        localStorage.removeItem('utc_current_view'); 
        
        this.settings = this.loadSettings(); 
        this.signals = []; 
        this.stats = { total: 0, tp: 0, sl: 0 }; 
        this.strategyStats = this.initDefaultStrategyStats();
        this.ctxStats = {};
        this.shadow = { byStrategy: {} };
        this.currentSymbol = 'BTCUSDT'; 
        this.currentTimeframe = '15m'; 
        this.headerCollapsed = true;
        this.currentMainView = 'chart'; 

        this.initStrategies(); 
        this.updateSettingsModalUI(); 
        this.renderSignals(true); 
        this.renderStats(true);   
        this.chartManager.clearMarkers(); 
        this.showNotification('TÃ¼m ayarlar ve veriler sÄ±fÄ±rlandÄ±!', 'info');
        this.stop(); 
        document.body.classList.add('header-collapsed'); 
        this.switchMainView('chart');
      }
    }

    async start() {
      if (this.isRunning) return;
      this.isRunning = true; 
      document.getElementById('start-btn').disabled = true; 
      document.getElementById('stop-btn').disabled = false;
      
      this.showNotification('Sistem BaÅlatÄ±ldÄ±: CanlÄ± veri akÄ±ÅÄ± baÅlatÄ±lÄ±yor...', 'success');
      await this.fetchInitialData(); 
      await this.fetchHTFTrend('1h', 120).catch(()=>{});
      this.connectWebSockets();
      this.renderInterval = setInterval(() => this.render(), 250);
      this.analysisInterval = setInterval(() => this.runPeriodicAnalysis(), 5000);
      this.cooldownTuneInterval = setInterval(() => this.autoTuneCooldowns(), 60000);
      this.thresholdTuneInterval = setInterval(() => this.autoTuneThresholds(), 60000);
      this._paperTimer = setInterval(() => this.evaluatePaperProposals(), 30000);
      this._honorTimer = setInterval(() => this.renderHonorBoards(), 5000);
      this._htfTimer = setInterval(()=> this.fetchHTFTrend('1h', 120).catch(()=>{}), 120000);
    }

    stop() {
      if (!this.isRunning) return;
      this.isRunning = false; 
      document.getElementById('start-btn').disabled = false; 
      document.getElementById('stop-btn').disabled = true; 
      this.disconnectWebSockets();
      if (this.renderInterval) clearInterval(this.renderInterval); 
      if (this.analysisInterval) clearInterval(this.analysisInterval);
      if (this.cooldownTuneInterval) clearInterval(this.cooldownTuneInterval);
      if (this.thresholdTuneInterval) clearInterval(this.thresholdTuneInterval);
      if (this._paperTimer) clearInterval(this._paperTimer);
      if (this._honorTimer) clearInterval(this._honorTimer);
      if (this._htfTimer) clearInterval(this._htfTimer);
      this.updateConnectionStatus(false, "BAÄLANTI KESÄ°LDÄ°"); 
      if (this.combatModeActive) this.deactivateCombatMode();
      this.showNotification('Sistem Durduruldu.', 'danger');
    }

    async changeSymbol(newSymbol) {
      if (this.currentSymbol === newSymbol) return;
      this.currentSymbol = newSymbol; 
      this.showNotification(`${this.currentSymbol.replace('USDT', '/USDT')} sembolÃ¼ne geÃ§ildi.`, 'info');
      this.resetDataForNewSymbol();
      this.updateSuperTopTicker(); 
      if (this.isRunning) { this.stop(); await this.start(); }
    }
    async changeTimeframe(newTimeframe) {
      this.currentTimeframe = newTimeframe; 
      this.showNotification(`Zaman aralÄ±ÄÄ± ${this.currentTimeframe} olarak deÄiÅtirildi.`, 'info');
      this.resetDataForNewSymbol();
      if (this.isRunning) { this.stop(); await this.start(); }
    }
    resetDataForNewSymbol() {
      this.candles = []; this.aggTrades = []; this.marketData = {}; this.orderBook = { bids: [], asks: [], lastUpdateId: null };
      this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null };
      this.chartManager.setData([]); this.chartManager.clearMarkers(); this.render();
    }

    async fetchInitialData() {
      try {
        this.logToJournal(`${this.currentSymbol} iÃ§in geÃ§miÅ mum verileri Ã§ekiliyor...`);
        const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=${this.currentTimeframe}&limit=500`;
        const response = await fetch(url); if (!response.ok) throw new Error(`API HatasÄ±: ${response.statusText}`);
        const data = await response.json();
        this.candles = data.map(d => ({ time: d[0], open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]), }));
        this.chartManager.setData(this.candles); this.logToJournal(`${this.candles.length} adet mum yÃ¼klendi.`);
        this.calculateAllIndicators();
      } catch (error) { this.showNotification(`GeÃ§miÅ veri alÄ±namadÄ±: ${error.message}`, 'danger'); console.error("GeÃ§miÅ veri hatasÄ±:", error); }
    }

    connectWebSockets() {
      this.disconnectWebSockets(); 
      this.reconnectAttempts = 0;
      const symbolLower = this.currentSymbol.toLowerCase();
      const streams = [`${symbolLower}@ticker`, `${symbolLower}@depth20@100ms`, `${symbolLower}@aggTrade`, `${symbolLower}@kline_${this.currentTimeframe}`];
      const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams.join('/')}`); 
      this.sockets['main'] = ws;
      
      ws.onopen = () => { this.updateConnectionStatus(true); this.reconnectAttempts = 0; this.logToJournal("WebSocket baÄlantÄ±sÄ± baÅarÄ±yla kuruldu."); };
      ws.onmessage = (event) => { const message = JSON.parse(event.data); this.handleMarketData(message.stream, message.data); };
      ws.onerror = (error) => console.error('WebSocket HatasÄ±:', error);
      ws.onclose = () => { 
        if (this.isRunning) { 
          this.reconnectAttempts++;
          this.reconnectDelay = Math.min(30000, 3000 * Math.pow(2, this.reconnectAttempts - 1));
          const message = `YENÄ°DEN BAÄLANILIYOR... (${this.reconnectDelay / 1000}s)`;
          this.updateConnectionStatus(false, message); 
          this.logToJournal(`BaÄlantÄ± kapandÄ±. ${this.reconnectDelay/1000} saniye sonra yeniden denenecek. (Deneme: ${this.reconnectAttempts})`);
          setTimeout(() => this.connectWebSockets(), this.reconnectDelay); 
        } 
      };
    }
    disconnectWebSockets() { if (this.sockets['main']) { this.sockets['main'].onclose = null; this.sockets['main'].close(1000, "Ä°stemci tarafÄ±ndan kapatÄ±ldÄ±"); } }

    handleMarketData(stream, data) {
      const streamType = stream.split('@')[1];
      if (streamType === 'ticker') {
        this.marketData = { price: parseFloat(data.c), change24h: parseFloat(data.P), volume24h: parseFloat(data.q), symbol: data.s, btcPrice: (data.s==='BTCUSDT'?parseFloat(data.c):this.marketData.btcPrice) }; 
        // Pozisyon yÃ¶netimi + TP/SL kontrol
        this.manageOpenPositions();
        this.checkAutoCloseSignals();
      } 
      else if (streamType.startsWith('depth')) {
        this.orderBook = { bids: data.b.map(([p, q]) => [parseFloat(p), parseFloat(q)]), asks: data.a.map(([p, q]) => [parseFloat(p), parseFloat(q)]), lastUpdateId: data.u };
        this.heatmapManager.draw(this.orderBook, this.marketData.price);
        for (const key in this.activeStrategies) { this.activeStrategies[key].analyzeOrderBook(this.orderBook); }
      } else if (streamType.startsWith('kline')) {
        if (this.candles.length > 0) {
          const kline = data.k; this.chartManager.updateRealtime(kline);
          if (kline.x) {
            const newCandle = { time: kline.t, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c), volume: parseFloat(kline.v) };
            const lastCandle = this.candles[this.candles.length - 1];
            if (lastCandle.time === kline.t) this.candles[this.candles.length - 1] = newCandle; else this.candles.push(newCandle);
            if (this.candles.length > 500) this.candles.shift(); this.calculateAllIndicators();
          }
          // Kline kapanÄ±ÅlarÄ±nda da pozisyon yÃ¶netimini kontrol edelim
          this.manageOpenPositions();
          this.checkAutoCloseSignals();
        }
      } else if (streamType === 'aggTrade') {
        const trade = { price: parseFloat(data.p), quantity: parseFloat(data.q), isBuyerMaker: data.m, timestamp: data.T };
        for (const key in this.activeStrategies) { if (typeof this.activeStrategies[key].processTrade === 'function') this.activeStrategies[key].processTrade(trade); }
      }
    }
    
    runPeriodicAnalysis() { if (!this.isRunning) return; for (const key in this.activeStrategies) { this.activeStrategies[key].periodicAnalyze(); } }
    
    calculateAllIndicators() {
      const rsiPeriod = this.settings.params.rsiPeriod;
      const closes = this.candles.map(c => c.close);
      if (closes.length < rsiPeriod) return;
      let avgGain = 0, avgLoss = 0;
      for (let i = 1; i <= rsiPeriod; i++) { const diff = closes[i] - closes[i - 1]; if (diff > 0) avgGain += diff; else avgLoss -= diff; }
      avgGain /= rsiPeriod; avgLoss /= rsiPeriod;
      const rsi = []; for (let i = 0; i < rsiPeriod; i++) rsi.push(NaN);
      rsi.push(100 - (100 / (1 + (avgGain / avgLoss))));
      for (let i = rsiPeriod + 1; i < closes.length; i++) {
        const diff = closes[i] - closes[i - 1];
        avgGain = (avgGain * (rsiPeriod - 1) + (diff > 0 ? diff : 0)) / rsiPeriod;
        avgLoss = (avgLoss * (rsiPeriod - 1) + (diff < 0 ? -diff : 0)) / rsiPeriod;
        rsi.push(100 - (100 / (1 + (avgLoss === 0 ? 100 : avgGain / avgLoss))));
      }
      this.indicators.rsi = rsi;

      const atrPeriod = this.settings.params.atrPeriod;
      if (this.candles.length < atrPeriod) return;
      let trs = [];
      for (let i = 1; i < this.candles.length; i++) {
        const c = this.candles[i], p = this.candles[i - 1];
        trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
      }
      if (trs.length === 0) return;
      let atrSum = trs.slice(0, atrPeriod).reduce((a, b) => a + b, 0);
      this.indicators.atr = atrSum / atrPeriod;

      const sma = (arr, n) => arr.slice(-n).reduce((a,b)=>a+b,0)/Math.max(1, Math.min(arr.length, n));
      if (closes.length >= 20) this.indicators.sma20 = sma(closes, 20);
      if (closes.length >= 50) this.indicators.sma50 = sma(closes, 50);
      const volumes = this.candles.map(x=>x.volume);
      if (volumes.length >= 20) this.indicators.volSma20 = sma(volumes, 20);
      let cumPV = 0, cumV = 0;
      for (const k of this.candles) { const tp = (k.high + k.low + k.close)/3; cumPV += tp * k.volume; cumV += k.volume; }
      this.indicators.vwap = cumV ? (cumPV / cumV) : null;

      // ADX (stabil): per-bar dx ve periodluk ortalama
      this.indicators.adx = this.calcADX(this.candles, this.settings.params.atrPeriod);
      this.marketRegime = (this.indicators.adx && this.indicators.adx > 22) ? 'trend' : 'range';
    }

    calcADX(candles, period = 14) {
      if (!candles || candles.length < period + 2) return null;
      const tr = [], plusDM = [], minusDM = [];
      for (let i = 1; i < candles.length; i++) {
        const c = candles[i], p = candles[i-1];
        const upMove = c.high - p.high;
        const downMove = p.low - c.low;
        const trueRange = Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close));
        tr.push(trueRange);
        plusDM.push((upMove > downMove && upMove > 0) ? upMove : 0);
        minusDM.push((downMove > upMove && downMove > 0) ? downMove : 0);
      }
      const smooth = (arr) => {
        let s = arr.slice(0, period).reduce((a,b)=>a+b,0);
        const out = [s];
        for (let i = period; i < arr.length; i++) { s = s - (s/period) + arr[i]; out.push(s); }
        return out;
      };
      const trS = smooth(tr), pS = smooth(plusDM), mS = smooth(minusDM);
      const pDI = [], mDI = [], dxArr = [];
      for (let i = 0; i < Math.min(trS.length, pS.length, mS.length); i++) {
        const atr = trS[i] / period;
        const pdi = 100 * ((pS[i] / period) / Math.max(1e-8, atr));
        const mdi = 100 * ((mS[i] / period) / Math.max(1e-8, atr));
        pDI.push(pdi); mDI.push(mdi);
        const dx = 100 * Math.abs(pdi - mdi) / Math.max(1, (pdi + mdi));
        dxArr.push(dx);
      }
      const last = dxArr.slice(-period);
      if (!last.length) return null;
      return last.reduce((a,b)=>a+b,0)/last.length;
    }

    getOrderBookSnapshotInfo() {
      const ob = this.orderBook;
      if (!ob || !ob.bids || !ob.asks || ob.bids.length === 0 || ob.asks.length === 0) return null;
      const bestBid = ob.bids[0][0], bestAsk = ob.asks[0][0];
      const mid = (bestAsk + bestBid)/2;
      const spreadPct = (bestAsk - bestBid) / mid;
      const topN = this.settings.optimization.gating.topN || 5;
      const price = this.marketData.price || mid || 1;
      const sumUsd = (levels) => levels.slice(0, topN).reduce((s,[p,q])=> s + (p*q), 0);
      const topBidUsd = sumUsd(ob.bids);
      const topAskUsd = sumUsd(ob.asks);
      const minTopUsd = Math.min(topBidUsd, topAskUsd);
      return { bestBid, bestAsk, spreadPct, topBidUsd, topAskUsd, minTopUsd, mid, price };
    }
    marketGatingPenalty(direction) {
      const info = this.getOrderBookSnapshotInfo();
      if (!info) return 0;
      const g = this.settings.optimization.gating;
      let penalty = 0;
      if (info.spreadPct > g.spreadMaxPct) penalty += 1;
      if (info.minTopUsd < g.minDepthUsd) penalty += 1;
      return penalty;
    }

    // HTF trend (1h)
    async fetchHTFTrend(interval='1h', len=120) {
      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=${interval}&limit=${len}`;
      const r = await fetch(url); const d = await r.json();
      const kl = d.map(x => ({ c: parseFloat(x[4]) }));
      const sma = (arr,n)=> arr.slice(-n).reduce((a,b)=>a+b,0)/Math.min(n,arr.length);
      const sma20 = sma(kl.map(k=>k.c), 20), sma50 = sma(kl.map(k=>k.c), 50);
      const last = kl[kl.length-1]?.c || 0;
      this.htfTrend = (last > sma50 && sma20 > sma50) ? 'up' : (last < sma50 && sma20 < sma50) ? 'down' : 'flat';
    }
    getHTFPenalty(direction) {
      if (!this.htfTrend || this.htfTrend === 'flat') return 0;
      if (direction === 'buy' && this.htfTrend === 'down') return 1;
      if (direction === 'sell' && this.htfTrend === 'up') return 1;
      return 0;
    }

    getEffectiveThreshold() { return (this.settings.confluenceThreshold || 3) + (this.runtimeThresholdOffset || 0); }

    buildFeatures(buyObj, sellObj) {
      const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr/this.marketData.price) : 0;
      const adx = this.indicators.adx || 0;
      const ob = this.getOrderBookSnapshotInfo() || {};
      const spread = ob.spreadPct || 0, depth = Math.min(3e5, ob.minTopUsd||0)/3e5;
      const dirDiff = (buyObj.score||0) - (sellObj.score||0);
      const top = (arr)=> (arr?.contributors||[]).map(c=>c.effScore||0).sort((a,b)=>b-a).slice(0,3);
      const topB = top(buyObj), topS = top(sellObj);
      return [
        dirDiff,
        buyObj.score||0, sellObj.score||0,
        (buyObj.groupSums?.trending||0), (buyObj.groupSums?.meanReversion||0),
        (sellObj.groupSums?.trending||0), (sellObj.groupSums?.meanReversion||0),
        atrPct, adx/100, spread, depth,
        (topB[0]||0), (topB[1]||0), (topB[2]||0),
        (topS[0]||0), (topS[1]||0), (topS[2]||0)
      ];
    }

    calculateDynamicTpSl(signal) {
      const atr = this.indicators.atr;
      const price = this.marketData.price || signal.price;
      let rrRatioBase = this.settings.params.rrRatio;

      // Kaliteye gÃ¶re RR (lojistik olasÄ±lÄ±k)
      const p = (this.classifier && signal.features) ? this.classifier.predict(signal.features) : (signal.prob || 0.55);
      const grpBias = signal.reason?.toLowerCase().includes('trend') ? 1.15 : 1.0;
      let rr = Math.min(2.8, Math.max(1.1, rrRatioBase * (0.9 + p*0.6) * grpBias));

      // risk state adaptasyonu
      if (this.riskState === 'conservative') rr = Math.max(1.1, rr * 0.9);
      if (this.riskState === 'aggressive') rr = Math.min(3.0, rr * 1.1);

      if (!atr || atr === 0) {
        signal.sl = signal.direction === 'buy' ? price * 0.995 : price * 1.005;
        signal.tp = signal.direction === 'buy' ? price * (1 + 0.01*rr) : price * (1 - 0.01*rr);
      } else {
        const atrMultiplier = Math.max(0.8, 1.6 - p); 
        const slDistance = atr * atrMultiplier;
        const tpDistance = slDistance * rr;
        if (signal.direction === 'buy') { signal.sl = price - slDistance; signal.tp = price + tpDistance; }
        else { signal.sl = price + slDistance; signal.tp = price - tpDistance; }
        signal.entrySlDistance = slDistance;
        signal.entryTpDistance = tpDistance;
      }
    }

    manageOpenPositions() {
      const price = this.marketData.price;
      if (!price || this.signals.length === 0) return;
      const settings = this.settings.optimization.breakeven || {};
      if (!settings.enabled) return;
      let changed = false;

      const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
      for (const s of activeSignals) {
        if (!s.entrySlDistance || s.entrySlDistance <= 0) continue;
        const rNow = s.direction === 'buy' ? (price - s.price) / s.entrySlDistance : (s.price - price) / s.entrySlDistance;
        s.mfeR = Math.max(s.mfeR || 0, rNow);
        // Breakeven
        if (!s.beDone && s.mfeR >= (settings.beAtR || 0.8)) {
          s.sl = s.price; s.beDone = true;
          s.note = (s.note || '') + ' | SL->BE';
          changed = true;
        }
        // Trailing
        if (s.mfeR >= (settings.trailAfterR || 1.5) && (s.trailingStage || 0) < 1) {
          const addR = (settings.trailToR || 0.5) * s.entrySlDistance;
          if (s.direction === 'buy') s.sl = Math.min(s.tp, s.price + addR);
          else s.sl = Math.max(s.tp, s.price - addR);
          s.trailingStage = 1;
          s.note = (s.note || '') + ' | Trail1';
          changed = true;
        }
      }
      if (changed) this.saveData('utc_signals', this.signals);
    }

    checkAutoCloseSignals() {
      const price = this.marketData.price;
      if (!price || this.signals.length === 0) return;
      const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
      const now = Date.now();
      for (const s of activeSignals) {
        if (s.direction === 'buy') {
          if (price >= s.tp) { this.updateSignalResult(s.id, 'tp'); }
          else if (price <= s.sl) { this.updateSignalResult(s.id, 'sl'); }
        } else if (s.direction === 'sell') {
          if (price <= s.tp) { this.updateSignalResult(s.id, 'tp'); }
          else if (price >= s.sl) { this.updateSignalResult(s.id, 'sl'); }
        }
        // time stop: belirli sÃ¼rede 0.3R gÃ¶rÃ¼lmezse kapat
        if (s.entrySlDistance && (now - s.timestamp) > (this.settings.optimization.timeStopMs || 20*60*1000)) {
          const rNow = s.direction==='buy' ? (price - s.price)/s.entrySlDistance : (s.price - price)/s.entrySlDistance;
          if ((s.mfeR||0) < 0.3 && rNow < 0.1) this.updateSignalResult(s.id,'sl');
        }
      }
    }

    render() { this.renderPriceDisplay(); }
    renderPriceDisplay() {
      const priceEl = document.getElementById('current-price');
      const tickerPriceEl = document.getElementById('ticker-bar-price');
      const oldPriceText = tickerPriceEl ? tickerPriceEl.textContent : '0';
      const oldPrice = this.marketData.price ? parseFloat(oldPriceText.replace(/,/g, '')) : 0;
      
      if (this.marketData.price) {
        const formattedPrice = this.formatPrice(this.marketData.price);
        if (priceEl) priceEl.textContent = formattedPrice;
        if(tickerPriceEl) tickerPriceEl.textContent = formattedPrice;

        if (!isNaN(oldPrice) && oldPrice !== 0) { 
          const color = this.marketData.price > oldPrice ? 'var(--positive)' : (this.marketData.price < oldPrice ? 'var(--negative)' : '');
          if(color) { if (priceEl) priceEl.style.color = color; if(tickerPriceEl) tickerPriceEl.style.color = color; }
        }
      }
      const change = this.marketData.change24h || 0;
      const changeEl = document.getElementById('price-change-24h');
      if (changeEl) { changeEl.textContent = `${change.toFixed(2)}%`; changeEl.style.color = change >= 0 ? 'var(--positive)' : 'var(--negative)'; }
      const volumeEl = document.getElementById('volume-24h'); if(volumeEl) volumeEl.textContent = this.formatVolume(this.marketData.volume24h);
      const atrEl = document.getElementById('atr-value'); if(atrEl) atrEl.textContent = this.indicators.atr ? this.indicators.atr.toFixed(this.getDecimalPlaces(this.indicators.atr)) : '-';
    }

    addFinalSignal(signal) {
      this.signals.unshift(signal); if (this.signals.length > 200) this.signals.pop();
      this.saveData('utc_signals', this.signals);
      this.renderSignals(true); 
      this.renderStats(true); 
      this.chartManager.addSignalMarker(signal);
      this.showNotification(`YENÄ° SÄ°NYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '/USDT')} | Skor: ${typeof signal.score==='number'?signal.score.toFixed(1):signal.score}`, signal.direction === 'buy' ? 'success' : 'danger');
      playSignal(signal.direction); 
      if (signal.score >= 8) { this.activateCombatMode(); }
    }

    updateSignalResult(signalId, result) {
      const signal = this.signals.find(s => s.id === signalId);
      if(signal && signal.status === 'active') {
        signal.status = result;
        this.stats.total++;
        this.stats[result]++;
        // Strateji performans gÃ¼ncelle
        this.updateStrategyStats(signal);

        // Model eÄitimi
        const y = (signal.status === 'tp') ? 1 : 0;
        if (signal.features) { this.classifier.update(y, signal.features); }

        this.saveData('utc_signals', this.signals);
        this.saveData('utc_stats', this.stats);
        this.renderSignals(true); 
        this.renderStats(true);   
        this.showNotification(`Sinyal ${result.toUpperCase()} olarak iÅaretlendi.`, 'info');
      }
    }

    updateStrategyStats(signal) {
      const isWin = signal.status === 'tp';
      const contributors = signal.contributors || [];
      const totalEff = contributors.reduce((s, c) => s + (c.effScore || (c.baseScore * (c.weight||1))), 0) || 1;
      const decay = 0.995;
      const ctxKey = this.getContextKey();

      for (const c of contributors) {
        const credit = (c.effScore || (c.baseScore * (c.weight||1))) / totalEff;

        // global
        const stat = this.strategyStats[c.strategy] || { alpha:3, beta:2, proposals:0, contrib:0, wins:0, losses:0, lastUpdate: Date.now() };
        stat.alpha *= decay; stat.beta *= decay;
        if (isWin) { stat.wins += credit; stat.alpha += credit; }
        else { stat.losses += credit; stat.beta += credit; }
        stat.contrib += 1; stat.lastUpdate = Date.now();
        this.strategyStats[c.strategy] = stat;

        // context
        this.ctxStats[c.strategy] = this.ctxStats[c.strategy] || {};
        const cs = this.ctxStats[c.strategy][ctxKey] || { alpha:2, beta:2, contrib:0, wins:0, losses:0 };
        cs.alpha *= decay; cs.beta *= decay;
        if (isWin) { cs.wins += credit; cs.alpha += credit; } else { cs.losses += credit; cs.beta += credit; }
        cs.contrib += 1;
        this.ctxStats[c.strategy][ctxKey] = cs;
      }

      // Strateji proposal cooldown adaptasyonu
      for (const key of Object.keys(this.activeStrategies)) {
        const w = this.getStrategyWeight(key);
        const base = this.settings.cooldowns.strategyProposalMs || 10000;
        const factor = Math.max(0.5, Math.min(2.0, 1.2 / Math.max(0.01,w))); 
        const newCd = Math.max(500, Math.round(base * factor));
        this.strategies[key].DEFAULT_PROPOSAL_COOLDOWN_MS = newCd;
      }

      // HÄ±zlÄ± shadow tetikleyici (aÄÄ±rlÄ±k ciddi dÃ¼Åerse)
      for (const c of contributors) {
        const w = this.getStrategyWeight(c.strategy);
        if (w < 0.5) this.shadowBan(c.strategy, `rapid decay w=${w.toFixed(2)}`);
      }

      this.saveStrategyStats();
      this.saveCtxStats();
      // Pano gÃ¼ncelle
      this.renderHonorBoards();
    }

    autoToggleStrategies() {
      if (!this.settings.optimization.autoToggle) return;
      const now = Date.now();
      if (now - this.lastAutoToggleTs < 15*60*1000) return;
      this.lastAutoToggleTs = now;
      const minW = this.settings.optimization.minWeightToStay || 0.6;
      const minContrib = this.settings.optimization.minContribForToggle || 30;

      for (const key of this.allStrategyKeys) {
        const w = this.getStrategyWeight(key);
        const stat = this.strategyStats[key] || {};
        const active = !!this.settings.activeStrategies[key];
        if (active && w < minW && (stat.contrib || 0) >= minContrib) {
          this.shadowBan(key, `low weight w=${w.toFixed(2)}`, this.shadowConfig.banDurMs);
        } else {
          if (this.isShadowed(key) && w >= 1.0) {
            this.liftShadow(key, `weight ${w.toFixed(2)}`);
          }
        }
      }
      this.updateActiveStrategies();
      this.saveSettings();
    }

    autoTuneCooldowns() {
      if (!this.isRunning) return;
      const now = Date.now();
      const WINDOW_MS = 5 * 60 * 1000;
      const recent = this.signals.filter(s => now - s.timestamp <= WINDOW_MS).slice(0, 100).sort((a,b)=> a.timestamp - b.timestamp);

      let quickFlips = 0, totalPairs = 0;
      for (let i = 1; i < recent.length; i++) {
        totalPairs++;
        const dt = recent[i].timestamp - recent[i-1].timestamp;
        if (recent[i-1].direction !== recent[i].direction && dt <= 15000) quickFlips++;
      }
      const flipRatio = totalPairs ? (quickFlips / totalPairs) : 0;
      const volPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0.001;

      const cd = this.settings.cooldowns;
      const baseSame = cd.sameDirectionMs || 30000;
      const baseOpp = cd.oppositeDirectionMs || 20000;
      const baseSignal = cd.signalMs || 15000;

      const newSame = Math.max(10000, Math.min(120000, Math.round(baseSame * (1 + flipRatio * 0.8))));
      const newOpp  = Math.max(5000, Math.min(120000, Math.round(baseOpp  * (1 + flipRatio * 1.2))));
      const volFactor = volPct < 0.005 ? 0.8 : (volPct > 0.02 ? 1.3 : 1.0);
      const newSignal = Math.max(3000, Math.min(60000, Math.round(baseSignal * volFactor)));
      const newProposalTimeout = Math.max(1500, Math.min(8000, Math.round(2000 + 6000 * volPct)));

      const changed = Math.abs(newSame - baseSame) / baseSame > 0.1 ||
                      Math.abs(newOpp - baseOpp) / baseOpp > 0.1 ||
                      Math.abs(newSignal - baseSignal) / baseSignal > 0.1 ||
                      Math.abs(newProposalTimeout - cd.proposalTimeoutMs) / Math.max(1, cd.proposalTimeoutMs) > 0.1;

      if (changed) {
        this.settings.cooldowns.sameDirectionMs = newSame;
        this.settings.cooldowns.oppositeDirectionMs = newOpp;
        this.settings.cooldowns.signalMs = newSignal;
        this.settings.cooldowns.proposalTimeoutMs = newProposalTimeout;
        this.saveSettings();
        this.showNotification(`Cooldown optimize (flip: ${(flipRatio*100).toFixed(0)}%, vol: ${(volPct*100).toFixed(2)}%).`, 'warning');
      }

      // Strateji auto-toggle (shadowban)
      this.autoToggleStrategies();
    }

    autoTuneThresholds() {
      if (!this.isRunning) return;
      const windowSignals = this.signals.filter(s => s.symbol === this.currentSymbol).slice(0, 40);
      const recent = windowSignals.slice(0, 20);
      const tp = recent.filter(s => s.status === 'tp').length;
      const sl = recent.filter(s => s.status === 'sl').length;
      const winRate = (tp + sl) > 0 ? tp / (tp + sl) : 0.5;

      // hÄ±zlÄ± flip oranÄ±
      let quickFlips = 0, pairs = 0;
      const ordered = recent.slice().sort((a,b)=> a.timestamp - b.timestamp);
      for (let i = 1; i < ordered.length; i++) {
        pairs++;
        if (ordered[i-1].direction !== ordered[i].direction && (ordered[i].timestamp - ordered[i-1].timestamp) <= 15000) quickFlips++;
      }
      const flipRatio = pairs ? quickFlips / pairs : 0;

      let targetOffset = 0;
      if (winRate <= 0.4 || flipRatio > 0.25) targetOffset = 1;
      if (winRate <= 0.3) targetOffset = 2;
      if (winRate >= 0.6 && flipRatio < 0.1) targetOffset = 0;

      // Risk state
      if (winRate <= 0.35) this.riskState = 'conservative';
      else if (winRate >= 0.65) this.riskState = 'aggressive';
      else this.riskState = 'neutral';

      // YumuÅak geÃ§iÅ
      this.runtimeThresholdOffset = 0.7 * (this.runtimeThresholdOffset||0) + 0.3 * targetOffset;
    }

    // Shadow helpers
    isShadowed(name) {
      const s = this.shadow && this.shadow.byStrategy && this.shadow.byStrategy[name];
      if (!s) return false;
      if (s.until && Date.now() > s.until) {
        delete this.shadow.byStrategy[name];
        this.saveData('utc_shadow', this.shadow);
        return false;
      }
      return !!s.active;
    }
    shadowBan(name, reason = 'low performance', durMs) {
      const until = Date.now() + (durMs || this.shadowConfig.banDurMs);
      this.shadow.byStrategy[name] = {
        active: true, since: Date.now(), until, reason,
        paper: { wins: 0, losses: 0, last: [] }
      };
      this.saveData('utc_shadow', this.shadow);
      this.showNotification(`${this.strategies[name]?.displayName || name} shadowban: ${reason}`, 'warning');
    }
    liftShadow(name, why = 'probation pass') {
      if (this.shadow.byStrategy[name]) {
        delete this.shadow.byStrategy[name];
        this.saveData('utc_shadow', this.shadow);
        this.showNotification(`${this.strategies[name]?.displayName || name} shadowban kaldÄ±rÄ±ldÄ± (${why}).`, 'success');
      }
    }
    recordPaperProposal(strategy, direction, price) {
      const atr = this.indicators.atr || (price * 0.005);
      const dist = Math.max(atr * this.shadowConfig.paperR, price * 0.002);
      const tp = direction === 'buy' ? price + dist : price - dist;
      const sl = direction === 'buy' ? price - dist : price + dist;
      this.paperEval.queue.push({ strategy, direction, price, tp, sl, t0: Date.now(), evaluated: false });
      if (this.paperEval.queue.length > 500) this.paperEval.queue.shift();
    }
    evaluatePaperProposals() {
      const now = Date.now();
      const c = this.candles || [];
      if (!c.length) return;

      const lookMs = this.shadowConfig.lookaheadMs;
      for (const p of this.paperEval.queue) {
        if (p.evaluated || (now - p.t0) < lookMs) continue;

        const seg = c.filter(k => k.time >= p.t0);
        if (!seg.length) continue;
        const maxH = Math.max(...seg.map(k => k.high));
        const minL = Math.min(...seg.map(k => k.low));

        let win = false, loss = false;
        if (p.direction === 'buy') { win = maxH >= p.tp; loss = minL <= p.sl; }
        else { win = minL <= p.tp; loss = maxH >= p.sl; }

        const sb = this.shadow.byStrategy[p.strategy];
        if (sb) {
          const paper = sb.paper || (sb.paper = { wins: 0, losses: 0, last: [] });
          if (win && !loss) { paper.wins += 1; paper.last.push(1); }
          else if (loss && !win) { paper.losses += 1; paper.last.push(0); }
          else { paper.losses += 0.5; paper.last.push(0); }

          const W = this.shadowConfig.probationWindow;
          while (paper.last.length > W) paper.last.shift();
          const winsInWindow = paper.last.reduce((a,b)=>a+b,0);
          if (paper.last.length >= W && winsInWindow >= this.shadowConfig.probationWinsNeeded) {
            this.liftShadow(p.strategy, `paper ${winsInWindow}/${paper.last.length}`);
          }
          this.saveData('utc_shadow', this.shadow);
        }
        p.evaluated = true;
      }
    }

    // Åeref Panosu
    getStratMetrics(key) {
      const s = this.strategyStats[key] || { wins:0, losses:0, contrib:0 };
      const wins = s.wins || 0, losses = s.losses || 0;
      const total = wins + losses;
      const wr = total > 0 ? wins / total : NaN;
      const w = this.getStrategyWeight(key);
      const banned = this.isShadowed(key);
      return { key, display: this.strategies[key]?.displayName || key, w, wr, contrib: s.contrib || 0, banned };
    }
    classifyStrategies() {
      const honor = [], dishonor = [], banned = [];
      const minContrib = 20;
      for (const key of this.allStrategyKeys) {
        const m = this.getStratMetrics(key);
        if (m.banned) { banned.push(m); continue; }
        if (m.contrib >= minContrib) {
          if (m.w >= 1.0 && (isNaN(m.wr) ? false : m.wr >= 0.55)) honor.push(m);
          else if (m.w < 0.6 || (isNaN(m.wr) ? false : m.wr <= 0.45)) dishonor.push(m);
        }
      }
      honor.sort((a,b)=> b.w - a.w); dishonor.sort((a,b)=> b.w - a.w);
      banned.sort((a,b)=> a.display.localeCompare(b.display));
      return { honor, dishonor, banned };
    }
    renderBoardTable(arr, kind='honor') {
      if (!arr || !arr.length) return '<div style="padding:8px;color:var(--text-secondary)">KayÄ±t yok.</div>';
      const head = `
        <table class="data-table">
          <thead>
            <tr><th>Strateji</th><th>w</th><th>WR</th><th>Contrib</th></tr>
          </thead><tbody>
      `;
      const rows = arr.map(m => {
        const w = (isFinite(m.w) ? m.w.toFixed(2) : '-');
        const wr = (isFinite(m.wr) ? (m.wr*100).toFixed(0)+'%' : '-');
        const color = kind==='honor' ? 'var(--positive)' : (kind==='dishonor' ? 'var(--negative)' : 'var(--text-main)');
        return `<tr>
          <td>${m.display}</td>
          <td style="color:${color}">${w}</td>
          <td>${wr}</td>
          <td>${m.contrib || 0}</td>
        </tr>`;
      }).join('');
      return head + rows + '</tbody></table>';
    }
    renderHonorBoards() {
      const cls = this.classifyStrategies();
      const honorEl = document.getElementById('honor-list');
      const dishEl  = document.getElementById('dishonor-list');
      const banEl   = document.getElementById('banned-list');
      if (honorEl) honorEl.innerHTML = this.renderBoardTable(cls.honor, 'honor');
      if (dishEl)  dishEl.innerHTML  = this.renderBoardTable(cls.dishonor, 'dishonor');
      if (banEl)   banEl.innerHTML   = this.renderBoardTable(cls.banned, 'banned');
    }

    activateCombatMode() {
      if (this.combatModeActive) return; this.combatModeActive = true; document.documentElement.setAttribute('data-theme', 'war');
      this.chartManager.updateTheme(); this.heatmapManager.updateTheme(); 
      playSignal('combat'); 
      this.showNotification('!!! SAVAÅ MODU AKTÄ°F !!!', 'warning');
    }
    deactivateCombatMode() {
      this.combatModeActive = false; const savedTheme = localStorage.getItem('utc_theme') || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme);
      this.chartManager.updateTheme(); this.heatmapManager.updateTheme();
    }

    formatPrice(price) { if(!price && price !== 0) return '-'; return price.toLocaleString('en-US', { minimumFractionDigits: this.getDecimalPlaces(price), maximumFractionDigits: this.getDecimalPlaces(price) }); }
    getDecimalPlaces(price) { if(price === undefined || price === null) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
    formatVolume(volume) { if (!volume) return '-'; if (volume >= 1e9) return `${(volume / 1e9).toFixed(2)}B`; if (volume >= 1e6) return `${(volume / 1e6).toFixed(2)}M`; return `${(volume / 1e3).toFixed(1)}K`; }
    toggleTheme() { if (this.combatModeActive) { this.deactivateCombatMode(); return; } const ct = document.documentElement.getAttribute('data-theme'); const nt = (ct === 'dark') ? 'light' : 'dark'; document.documentElement.setAttribute('data-theme', nt); localStorage.setItem('utc_theme', nt); this.chartManager.updateTheme(); this.heatmapManager.updateTheme(); }
    
    updateConnectionStatus(isConnected, message = 'BAÄLANTI YOK') { 
      const sd = document.getElementById('connection-status');
      const st = document.getElementById('connection-text');
      const tickerSymbolEl = document.getElementById('ticker-bar-symbol');
      if(isConnected) { sd.classList.add('online'); st.textContent = `BAÄLI (${this.currentSymbol.replace('USDT', '/USDT')})`; if(tickerSymbolEl) tickerSymbolEl.textContent = this.currentSymbol.replace('USDT', '/USDT'); }
      else { sd.classList.remove('online'); st.textContent = message; } 
    }

    showNotification(message, type = 'info') { const c=document.getElementById('notifications-container'); if(!c) return; const n = document.createElement('div'); n.className=`notification ${type}`; n.textContent=message; c.prepend(n); setTimeout(() => { n.style.transition='opacity 0.5s ease'; n.style.opacity=0; setTimeout(()=>n.remove(), 500); }, 5000); }
    logToJournal(message) { console.log(`[LOG] ${new Date().toLocaleTimeString()} - ${message}`); }
    
    saveSettings() { localStorage.setItem('utc_settings', JSON.stringify(this.settings)); }
    loadSettings() {
      const defaultActive = {};
      this.allStrategyKeys.forEach((key, i) => defaultActive[key] = i < 5); 
      const defaults = {
        confluenceThreshold: 3,
        params: { rsiPeriod: 14, atrPeriod: 14, wallBtc: 20, rrRatio: 1.5 },
        cooldowns: { 
          signalMs: 15000, sameDirectionMs: 30000, proposalTimeoutMs: 3000, strategyProposalMs: 10000,
          oppositeDirectionMs: 20000, reverseHysteresisPoints: 2
        },
        optimization: {
          enabled: true,
          timeDecaySec: 3,
          dirMargin: 0.5,
          gating: { spreadMaxPct: 0.0015, minDepthUsd: 50000, topN: 5 },
          breakeven: { enabled: true, beAtR: 0.8, trailAfterR: 1.5, trailToR: 0.5 },
          autoToggle: true,
          minWeightToStay: 0.6,
          minContribForToggle: 30,
          probThreshold: 0.55,
          timeStopMs: 20*60*1000
        },
        activeStrategies: defaultActive
      };
      const saved = this.loadData('utc_settings');
      if(saved) {
        return {
          ...defaults,
          ...saved,
          params: { ...defaults.params, ...(saved.params||{}) },
          cooldowns: { ...defaults.cooldowns, ...(saved.cooldowns||{}) },
          optimization: { ...defaults.optimization, ...(saved.optimization||{}) },
          activeStrategies: { ...defaults.activeStrategies, ...(saved.activeStrategies||{}) }
        };
      }
      return defaults;
    }
    saveData(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); } catch(e) { console.error("Veri kaydedilemedi:", e); } }
    loadData(key) { try { const data = localStorage.getItem(key); return data ? JSON.parse(data) : null; } catch(e) { console.error("Veri okunamadÄ±:", e); return null; } }
  }

  document.addEventListener('DOMContentLoaded', () => { 
    try { 
      window.app = new UltimateTradingCommandCenter(); 
      setTimeout(() => window.dispatchEvent(new Event('resize')), 100);
    } 
    catch(e) {
      console.error("Uygulama baÅlatÄ±lÄ±rken kritik bir hata oluÅtu:", e);
      document.body.innerHTML = `<div style="color: red; padding: 20px; font-family: monospace;">Uygulama baÅlatÄ±lamadÄ±. Konsolu kontrol edin. Hata: ${e.message}</div>`;
    }
  });
</script>
</body>
</html>


birinci konular:
abi bu projenin tÃ¼m Ã¶zellik ve fonksyonlarÄ±nÄ±n kendi kendini optimize etmesi gerekiyor.fakat sadece cooldown optimiz oluyor.sitratejiler ve skor otomatik olarak optimize edilmesi gerekmezmi sencede? sinyallerin Ã§ogu baÅarÄ±sÄ±z oluyor. bu sorunu optimize ve geliÅtirmelerle Ã§Ã¶zebilirmisin.
programÄ±n mevcut Ã¶zelliklerini bozmadan.

diÄer konu:
abi ceza sisteminde cezalÄ± stratijiler shadowban yesin arkaplanda Ã§alÄ±Åmaya devam etsin.gÃ¼Ã§lendiÄinde katÄ±lÄ±m saÄlasÄ±n.daha mantÄ±klÄ± deÄilmi sence?
ceza sistemini daha iyi hale getirecek dÃ¼ÅÃ¼ncelerin varsa bunlarÄ± konuÅalÄ±m.
diÄer konu:


Åerefli ve Åerefsizler butonu koy en Ã¼steki butonlarÄ±n yanÄ±na. buradaki stratejiler baÅarÄ±lÄ± ve baÅarÄ±sÄ±zlar olarak sÃ¼rekli gÃ¼ncellensin dinamik olarak.ban yiyenleride ayrÄ± butona koy onarÄ±da gÃ¶relim. vatan hainleri ifÅa olsunki kullanÄ±cÄ± kimn hain kimin dost olduÄunu bilsin.
sorunlu stratejilerin iÃ§ dinamiklerindeki parametrelerde ameliyat edilebilsin. anbladÄ±nmÄ± Åerefsizler Åerefsizlikte Ä±srar ederse optimizasyon iÃ§ dinamiklere sÄ±Ã§rayacak.
gÃ¼nÃ¼n Åerefsizi gibi birÅeyler dÃ¼ÅÃ¼nÃ¼yorum.
 tts konuÅmalarÄ±ndada komik yada set Åerefsizler iÃ§in metinler ekleyebilirsin.senin yaratÄ±cÄ±lÄ±ÄÄ±na kalmÄ±Å.
bu kÄ±sÄ±m iÃ§in farklÄ± yaklaÅÄ±mÄ±n varsa konuÅalÄ±m.